/* Design Tool
 * @author  netbaseteam
 * @link http://netbaseteam.com
 * @version 1.0
 * @created Oct 2021
 * */

// Get Api key by parameters
var url_string = window.location.href;
var url = new URL(url_string);
var api_key_bearer = url.searchParams.get('api_key');
var product_id = url.searchParams.get('product_id');
var side_id = url.searchParams.get('side_id');
var design_id = url.searchParams.get('design_id');
var template_id = url.searchParams.get('template_id');
var is_template = url.searchParams.get('is_template');
var is_admin = url.searchParams.get('is_admin');
var parentUrl = url.searchParams.get('parentUrl');
var task = url.searchParams.get('task') ? url.searchParams.get('task') : 'new';
var font_perpage = 50;

var customSettings = {};

angular.element(function() {
    window.addEventListener(
        "message",
        (event) => {
            if(event.origin && parentUrl) {
                var _originUrl = new URL(event.origin);
                var _parentUrl = new URL(parentUrl);
                if (_originUrl.host === _parentUrl.host && event.data.message === 'customSettings') {
                    customSettings = event.data.settings;
                }
            }
        },
        false
    );

    window.parent.postMessage({message: 'finishLoad'}, parentUrl);
})

// API author
var apiPre = 'https://api.printcart.com/v1/';
// var apiPre = 'http://localhost:8001/v1/';

var apiAuthBearer = {
    'X-PrintCart-Unauth-Token': api_key_bearer
};


var configGetSides = {
    headers: apiAuthBearer
}

var s3PreUrl = 'https://d2lp2jhrzjca64.cloudfront.net/';

var s3PreMedia = 'https://dpeuzbvf3y4lr.cloudfront.net/';

// Get API
function getDesignConfig() {
    return axios.get(s3PreUrl+'assets/datas/configs.json');
}

function getProductDetails() {
    if(product_id) {
        return axios.get(apiPre+'products/'+product_id, {headers: apiAuthBearer});
    }
}

function getStores() {
    if(product_id) {
        return axios.get(apiPre+'stores/store-details', {headers: apiAuthBearer});
    }
}

function getSideByProduct() {
    if( !side_id && !template_id) {
        return axios.get(apiPre+'products/'+product_id+'/sides', {headers: apiAuthBearer});
    }
}

function getSideById() {
    if(side_id) {
        return axios.get(apiPre+'sides/'+side_id, {headers: apiAuthBearer});
    }
}

function getDesignLayerById() {
    if( template_id ) {
        return axios.get(apiPre+'templates/'+template_id, {headers: apiAuthBearer});
    }
    if( design_id ) {
        return axios.get(apiPre+'designs/'+design_id, {headers: apiAuthBearer});
    }
}

function getFontDefault() {
    return axios.get(apiPre+'fonts/default?limit='+font_perpage+'&sortBy=id&sort=asc', {headers: apiAuthBearer});
}

function getFonts() {
    return axios.get(apiPre+'fonts?limit='+font_perpage+'&sortBy=id&sort=asc', {headers: apiAuthBearer});
}

function getSides() {
    return axios.get(s3PreUrl+'sides/sides.json');
}

var langs = {
    alert_upload_term: 'Please accept the upload term conditions',
};

var urlCloudFront = "https://d2lp2jhrzjca64.cloudfront.net/assets/";

var mediaUrl = "https://studio.cmsmart.net/v1";

var nbd_window = window;

var dependModules = ['angularSpectrumColorpicker'];

var NBDESIGNCONFIG = null;

var defaultFonts = null;

var myFonts = null;

var dataDesignLayers = null;

var productSides = null;

var productSettings = null;

var appConfig = {
    isModern: true,
    ready: false,
    isVisual: false,
};

var photoFrames = [{"areas":"\"a\"","rows":"","columns":""},{"areas":"\"a b\"","rows":"","columns":""},{"areas":"\"a\" \"b\"","rows":"","columns":""},{"areas":"\"a\" \"b\"","rows":"2fr 1fr","columns":""},{"areas":"\"a\"","rows":"","columns":""},{"areas":"\"a b\"","rows":"","columns":""},{"areas":"\"a\" \"b\"","rows":"","columns":""},{"areas":"\"a\" \"b\"","rows":"2fr 1fr","columns":""},{"areas":"\"b\" \"a\"","rows":"1fr 2fr","columns":""},{"areas":"\"a b\"","rows":"","columns":"2fr 1fr"},{"areas":"\"b a\"","rows":"","columns":"1fr 2fr"},{"areas":"\"a b c\"","rows":"","columns":""},{"areas":"\"a\" \"b\" \"c\"","rows":"","columns":""},{"areas":"\"a b\" \"c c\"","rows":"","columns":""},{"areas":"\"a a\" \"b c\"","rows":"","columns":""},{"areas":"\"a b\" \"a c\"","rows":"","columns":""},{"areas":"\"a c\" \"b c\"","rows":"","columns":""},{"areas":"\"a a\" \"b c\"","rows":"2fr 1fr","columns":""},{"areas":"\"b c\" \"a a\"","rows":"1fr 2fr","columns":""},{"areas":"\"a b\" \"a c\"","rows":"","columns":"2fr 1fr"},{"areas":"\"b a\" \"c a\"","rows":"","columns":"1fr 2fr"},{"areas":"\"a a\" \"b c\"","rows":"2fr 1fr","columns":"1fr 2fr"},{"areas":"\"a b\" \"a c\"","rows":"1fr 2fr","columns":"2fr 1fr"},{"areas":"\"a b\" \"c c\"","rows":"2fr 1fr","columns":"1fr 2fr"},{"areas":"\"a a\" \"b c\"","rows":"1fr 2fr","columns":"1fr 2fr"},{"areas":"\"a b\" \"a c\"","rows":"1fr 2fr","columns":"1fr 2fr"},{"areas":"\"a b\" \"c b\"","rows":"1fr 2fr","columns":"2fr 1fr"},{"areas":"\"a b\" \"a c\"","rows":"","columns":"1fr 2fr"},{"areas":"\"a b\" \"c b\"","rows":"","columns":"2fr 1fr"},{"areas":"\"a a\" \"b c\"","rows":"","columns":"7fr 5fr"},{"areas":"\"a b\" \"c c\"","rows":"2fr 1fr","columns":"2fr 1fr"},{"areas":"\"a b\" \"a c\"","rows":"2fr 1fr","columns":"2fr 1fr"},{"areas":"\"a b c d\"","rows":"","columns":""},{"areas":"\"a\" \"b\" \"c\" \"d\"","rows":"","columns":""},{"areas":"\"a b\" \"c d\"","rows":"","columns":""},{"areas":"\"a a a\" \"b c d\"","rows":"2fr 1fr","columns":""},{"areas":"\"a b c\" \"d d d\"","rows":"1fr 2fr","columns":""},{"areas":"\"a b\" \"a c\" \"a d\"","rows":"","columns":"2fr 1fr"},{"areas":"\"a d\" \"b d\" \"c d\"","rows":"","columns":"1fr 2fr"},{"areas":"\"a b\" \"c d\"","rows":"","columns":"1fr 2fr"},{"areas":"\"a b\" \"c d\"","rows":"","columns":"2fr 1fr"},{"areas":"\"a b\" \"c d\"","rows":"2fr 1fr","columns":"1fr 2fr"},{"areas":"\"a a\" \"b d\" \"c d\"","rows":"2fr 1fr 1fr","columns":"1fr 2fr"},{"areas":"\"a a b\" \"c d d\"","rows":"1fr 2fr","columns":""},{"areas":"\"a b b\" \"c c d\"","rows":"2fr 1fr","columns":"2fr 1fr 3fr"},{"areas":"\"a b c\" \"a d d\"","rows":"","columns":""},{"areas":"\"a a b\" \"c d d\"","rows":"2fr 1fr","columns":""},{"areas":"\"a b\" \"c b\" \"c d\"","rows":"2fr 1fr 3fr","columns":"2fr 1fr"},{"areas":"\"a a\" \"b c\" \"b d\"","rows":"3fr 2fr 2fr","columns":""},{"areas":"\"a b\" \"a d\" \"c d\"","rows":"","columns":"2fr 1fr"},{"areas":"\"a b c d e\"","rows":"","columns":""},{"areas":"\"a\" \"b\" \"c\" \"d\" \"e\"","rows":"","columns":""},{"areas":"\"a a\" \"b c\" \"d e\"","rows":"","columns":""},{"areas":"\"a b\" \"c d\" \"e e\"","rows":"","columns":""},{"areas":"\"a b d\" \"a c e\"","rows":"","columns":""},{"areas":"\"a b e\" \"c d e\"","rows":"","columns":""},{"areas":"\"a a a a\" \"b c d e\"","rows":"","columns":""},{"areas":"\"a b c d\" \"e e e e\"","rows":"","columns":""},{"areas":"\"a b\" \"a c\" \"a d\" \"a e\"","rows":"","columns":""},{"areas":"\"a e\" \"b e\" \"c e\" \"d e\"","rows":"","columns":""},{"areas":"\"a c d\" \"b c e\"","rows":"","columns":"1fr 2fr 1fr"},{"areas":"\"a a a\" \"b c e\" \"d d e\"","rows":"2fr 1fr 2fr","columns":"1fr 1fr 3fr"},{"areas":"\"a a b\" \"c e e\" \"d e e\"","rows":"","columns":""},{"areas":"\"a a b\" \"a a c\" \"e d c\"","rows":"","columns":""},{"areas":"\"a c c\" \"b c c\" \"d d e\"","rows":"1fr 1fr 2fr","columns":"1fr 1fr 2fr"},{"areas":"\"a e e\" \"b e e\" \"c c d\"","rows":"","columns":"1fr 1fr 2fr"},{"areas":"\"a a a\" \"b c e\" \"b d e\"","rows":"3fr 1fr 1fr","columns":"2fr 1fr 2fr"},{"areas":"\"a a b\" \"d c b\" \"d e e\"","rows":"","columns":""},{"areas":"\"a b c\" \"a d c\" \"e e e\"","rows":"","columns":"3fr 5fr 3fr"},{"areas":"\"a c c\" \"a d e\" \"b d e\"","rows":"","columns":""},{"areas":"\"a c d\" \"b c e\"","rows":"","columns":""},{"areas":"\"a a b b\" \"c d d e\"","rows":"","columns":"2fr 1fr 1fr 2fr"},{"areas":"\"a b\" \"c c\" \"d e\"","rows":"","columns":""},{"areas":"\"a a a a\" \"b c d e\"","rows":"3fr 1fr","columns":""},{"areas":"\"a b c d e f\"","rows":"","columns":""},{"areas":"\"a\" \"b\" \"c\" \"d\" \"e\" \"f\"","rows":"","columns":""},{"areas":"\"a b c\" \"d e f\"","rows":"","columns":""},{"areas":"\"a b\" \"c d\" \"e f\"","rows":"","columns":""},{"areas":"\"a a a a a\" \"b c d e f\"","rows":"2fr 1fr","columns":""},{"areas":"\"a b c d e\" \"f f f f f\"","rows":"1fr 2fr","columns":""},{"areas":"\"a b\" \"a c\" \"a d\" \"a e\" \"a f\"","rows":"","columns":"2fr 1fr"},{"areas":"\"a f\" \"b f\" \"c f\" \"d f\" \"e f\"","rows":"","columns":"1fr 2fr"},{"areas":"\"a a b b\" \"c d e f\"","rows":"2fr 1fr","columns":""},{"areas":"\"a b c d\" \"e e f f\"","rows":"1fr 2fr","columns":""},{"areas":"\"a c\" \"a d\" \"b e\" \"b f\"","rows":"","columns":"2fr 1fr"},{"areas":"\"a e\" \"b e\" \"c f\" \"d f\"","rows":"","columns":"1fr 2fr"},{"areas":"\"a b b\" \"c b b\" \"d e f\"","rows":"","columns":""},{"areas":"\"a a e\" \"a a f\" \"b c d\"","rows":"","columns":""},{"areas":"\"a b c\" \"d d e\" \"d d f\"","rows":"","columns":""},{"areas":"\"a b c\" \"d f f\" \"e f f\"","rows":"","columns":""},{"areas":"\"a b c\" \"d b f\" \"d e f\"","rows":"","columns":""},{"areas":"\"a a b\" \"c d d\" \"e e f\"","rows":"","columns":""},{"areas":"\"a a b b\" \"c d d f\" \"c e e f\"","rows":"4fr 1fr 1fr","columns":"2fr 1fr 1fr 2fr"},{"areas":"\"a a e\" \"b c e\" \"b c f\" \"d d f\"","rows":"2fr 1fr 1fr 2fr","columns":"1fr 1fr 2fr"},{"areas":"\"a a b\" \"c d b\" \"c d e\" \"f f e\"","rows":"","columns":"1fr 1fr 2fr"},{"areas":"\"a a c\" \"b b c\" \"d e f\"","rows":"","columns":""},{"areas":"\"a b c\" \"a d e\" \"f f f\"","rows":"1fr 1fr 4fr","columns":"4fr 1fr 1fr"},{"areas":"\"a a b c\" \"a a d d\" \"f e d d\"","rows":"","columns":""},{"areas":"\"a b b\" \"c d e\" \"c f f\"","rows":"2fr 1fr 1fr","columns":"2fr 1fr 1fr"},{"areas":"\"a a a a\" \"b b c c\" \"d e e f\"","rows":"2fr 1fr 1fr","columns":"2fr 1fr 1fr 2fr"},{"areas":"\"a a b\" \"c d b\" \"e f b\"","rows":"2fr 1fr 1fr","columns":"1fr 1fr 2fr"},{"areas":"\"a a b\" \"a a c\" \"f e d\"","rows":"","columns":""},{"areas":"\"a a a a\" \"b c d e\" \"f f d e\"","rows":"2fr 1fr 1fr","columns":"1fr 1fr 2fr 2fr"},{"areas":"\"a a b\" \"a a c\" \"d e e\" \"f e e\"","rows":"","columns":"1fr 2fr 1fr"},{"areas":"\"a b c d e f g\"","rows":"","columns":""},{"areas":"\"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\"","rows":"","columns":""},{"areas":"\"a a b b c c\" \"d e e f f g\"","rows":"","columns":"3fr 1fr 2fr 2fr 1fr 3fr"},{"areas":"\"a b b c c d\" \"e e f f g g\"","rows":"","columns":"3fr 1fr 2fr 2fr 1fr 3fr"},{"areas":"\"a a a a a a\" \"b c d e f g\"","rows":"3fr 1fr","columns":""},{"areas":"\"a b c d e f\" \"g g g g g g\"","rows":"1fr 3fr","columns":""},{"areas":"\"a a a\" \"b c d\" \"e f g\"","rows":"3fr 1fr 1fr","columns":""},{"areas":"\"a b c\" \"d e f\" \"g g g\"","rows":"1fr 1fr 2fr","columns":""},{"areas":"\"b a e\" \"c a f\" \"d a g\"","rows":"","columns":"1fr 2fr 1fr"},{"areas":"\"b c d\" \"a a a\" \"e f g\"","rows":"1fr 2fr 1fr","columns":""},{"areas":"\"a a b\" \"c d b\" \"e f g\"","rows":"","columns":""},{"areas":"\"a b f\" \"c c g\" \"d e g\"","rows":"2fr 1fr 2fr","columns":"1fr 1fr 2fr"},{"areas":"\"a a b c\" \"d e f c\" \"g g g g\"","rows":"1fr 1fr 3fr","columns":""},{"areas":"\"a c c\" \"b c c\" \"d d e\" \"d d f\" \"g g g\"","rows":"1fr 1fr 1fr 1fr 2fr","columns":""},{"areas":"\"a b b\" \"c d e\" \"c f g\"","rows":"2fr 1fr 1fr","columns":""},{"areas":"\"a b b c\" \"d b b e\" \"f f g g\"","rows":"","columns":""},{"areas":"\"a b b\" \"a c d\" \"a e e\" \"a f g\"","rows":"","columns":"2fr 1fr 1fr"},{"areas":"\"a b b\" \"c d e\" \"c f g\"","rows":"2fr 1fr 1fr","columns":"2fr 1fr 1fr"},{"areas":"\"a b c d e f g h\"","rows":"","columns":""},{"areas":"\"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\"","rows":"","columns":""},{"areas":"\"a b c d\" \"e f g h\"","rows":"","columns":""},{"areas":"\"a b\" \"c d\" \"e f\" \"g h\"","rows":"","columns":""},{"areas":"\"a b c d\" \"e f g h\"","rows":"1fr 3fr","columns":""},{"areas":"\"a b c d\" \"e f g h\"","rows":"3fr 1fr","columns":""},{"areas":"\"a e\" \"b f\" \"c g\" \"d h\"","rows":"","columns":"3fr 1fr"},{"areas":"\"a b\" \"c d\" \"e f\" \"g h\"","rows":"","columns":"1fr 3fr"},{"areas":"\"a c e g\" \"a d e h\" \"b d f h\"","rows":"1fr 2fr 1fr","columns":""},{"areas":"\"a a b\" \"c d d\" \"e e f\" \"g h h\"","rows":"","columns":"1fr 2fr 1fr"},{"areas":"\"a a b b\" \"c d e f\" \"g g h h\"","rows":"1fr 2fr 1fr","columns":""},{"areas":"\"a a b b\" \"c c d d\" \"e f g h\"","rows":"1fr 1fr 2fr","columns":""},{"areas":"\"a a b b c c\" \"d e e f f g\" \"h h h h h h\"","rows":"1fr 2fr 1fr","columns":"3fr 1fr 2fr 2fr 1fr 3fr"},{"areas":"\"a b b c\" \"d d e e\" \"f g g h\"","rows":"1fr 2fr 1fr","columns":"2fr 1fr 1fr 2fr"},{"areas":"\"a a d d\" \"b c d d\" \"e e f g\" \"e e h h\"","rows":"","columns":""},{"areas":"\"a a b\" \"c d e\" \"c d f\" \"g g h\"","rows":"","columns":"1fr 1fr 2fr"},{"areas":"\"a b b c\" \"d d e e\" \"f g g h\"","rows":"","columns":"2fr 1fr 1fr 2fr"},{"areas":"\"a a b b\" \"a a c c\" \"d e c c\" \"d e f f\" \"h h f f\" \"h h g g\"","rows":"3fr 1fr 2fr 2fr 1fr 3fr","columns":""},{"areas":"\"a a a a\" \"b c d d\" \"e e f g\" \"h h h h\"","rows":"3fr 2fr 2fr 3fr","columns":""},{"areas":"\"a a b b\" \"c c b b\" \"d e h i\" \"f g h i\"","rows":"2fr 2fr 1fr 1fr","columns":"1fr 1fr 2fr 2fr"},{"areas":"\"a a b b\" \"c d d e\" \"f f g g\" \"h h h h\"","rows":"1fr 1fr 1fr 2fr","columns":"2fr 1fr 1fr 2fr"},{"areas":"\"a b c\" \"d d d\" \"e f g\" \"h h h\"","rows":"","columns":""},{"areas":"\"a d f\" \"b d g\" \"b e g\" \"c e h\"","rows":"2fr 1fr 1fr 2fr","columns":"1fr 2fr 1fr"},{"areas":"\"a b b c\" \"d d e e\" \"f g g h\"","rows":"","columns":"2fr 1fr 1fr 2fr"},{"areas":"\"a d d\" \"b d d\" \"c e f\" \"c g h\"","rows":"","columns":""},{"areas":"\"a a a a\" \"b b b b\" \"c d f g\" \"c e f h\"","rows":"2fr 2fr 1fr 1fr","columns":""},{"areas":"\"a d f\" \"b d g\" \"b e g\" \"c e h\"","rows":"2fr 1fr 1fr 2fr","columns":""},{"areas":"\"a b c d e f g h i\"","rows":"","columns":""},{"areas":"\"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\"","rows":"","columns":""},{"areas":"\"a b c\" \"d e f\" \"g h i\"","rows":"","columns":""},{"areas":"\"a b c\" \"d e f\" \"g h i\"","rows":"","columns":"2fr 3fr 2fr"},{"areas":"\"a a b b\" \"c d d e\" \"f g h i\"","rows":"1fr 3fr 1fr","columns":""},{"areas":"\"a a a a\" \"b c c d\" \"e e f f\" \"g h h i\"","rows":"2fr 1fr 1fr 1fr","columns":"2fr 1fr 1fr 2fr"},{"areas":"\"a b c c\" \"d d e f\" \"g h i i\"","rows":"","columns":""},{"areas":"\"a a b d\" \"a a c d\" \"e f g d\" \"h h h i\"","rows":"1fr 1fr 1fr 3fr","columns":"1fr 1fr 1fr 3fr"},{"areas":"\"a b b c\" \"d d e e\" \"f g g h\"","rows":"","columns":"2fr 1fr 1fr 2fr"},{"areas":"\"a b c\" \"d b e\" \"f g h\" \"f i h\"","rows":"2fr 2fr 1fr 1fr","columns":"2fr 3fr 2fr"},{"areas":"\"a b b\" \"c b b\" \"d d e\" \"d d f\" \"g h h\" \"i h h\"","rows":"","columns":""},{"areas":"\"a b c d\" \"e e e e\" \"f g h i\"","rows":"1fr 3fr 1fr","columns":""},{"areas":"\"a a b c\" \"d e e f\" \"g e e f\" \"g h h f\" \"i h h f\"","rows":"","columns":"1fr 1fr 1fr 2fr"},{"areas":"\"a b c\" \"d b e\" \"f b g\" \"h b i\"","rows":"","columns":"1fr 2fr 1fr"},{"areas":"\"a a b b\" \"c c d d\" \"e f f g\" \"h f f i\"","rows":"","columns":""},{"areas":"\"a b c\" \"d d e\" \"d d f\" \"g h i\"","rows":"","columns":"1fr 1fr 2fr"},{"areas":"\"a a a b\" \"a a a c\" \"d e e c\" \"f g i i\" \"f h i i\"","rows":"2fr 1fr 1fr 1fr 1fr","columns":"2fr 1fr 1fr 2fr"},{"areas":"\"a b c d\" \"e f g h\" \"i i i i\"","rows":"1fr 1fr 2fr","columns":""},{"areas":"\"a b c\" \"a d e\" \"a f g\" \"a h i\"","rows":"","columns":"2fr 1fr 1fr"},{"areas":"\"a b c\" \"d e f\" \"g h i\"","rows":"2fr 1fr 1fr","columns":"2fr 1fr 1fr"},{"areas":"\"a a b d d\" \"a a c d d\" \"e f f f g\" \"h f f f i\"","rows":"","columns":""},{"areas":"\"a a b b\" \"c f f g\" \"d f f h\" \"e f f i\"","rows":"3fr 1fr 1fr 1fr","columns":"1fr 2fr 2fr 1fr"},{"areas":"\"a d g\" \"b d h\" \"c e i\" \"c f i\"","rows":"3fr 1fr 1fr 3fr","columns":""},{"areas":"\"a d g\" \"b d h\" \"b e h\" \"c f i\"","rows":"1fr 1fr 1fr 2fr","columns":""},{"areas":"\"a b c d e f g h i j\"","rows":"","columns":""},{"areas":"\"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\"","rows":"","columns":""},{"areas":"\"a a a a a\" \"b c d e f\" \"g h i j k\"","rows":"","columns":""},{"areas":"\"a b\" \"c d\" \"e f\" \"g h\" \"i j\"","rows":"","columns":""},{"areas":"\"a a a\" \"b c d\" \"e f g\" \"h i j\"","rows":"2fr 1fr 1fr 1fr","columns":""},{"areas":"\"a b c d\" \"a e f g\" \"a h i j\"","rows":"","columns":"2fr 1fr 1fr 1fr"},{"areas":"\"a b c\" \"d e f\" \"g h i\" \"j j j\"","rows":"1fr 1fr 1fr 2fr","columns":""},{"areas":"\"a b c j\" \"d e f j\" \"g h i j\"","rows":"","columns":"1fr 1fr 1fr 2fr"},{"areas":"\"a a b c\" \"a a d e\" \"f g j j\" \"h i j j\"","rows":"","columns":""},{"areas":"\"a b c d\" \"e e f f\" \"g h i j\"","rows":"1fr 2fr 1fr","columns":""},{"areas":"\"a b b c\" \"d e e f\" \"g h i j\"","rows":"","columns":""},{"areas":"\"a b c\" \"d e g\" \"d f g\" \"h i j\"","rows":"2fr 1fr 1fr 2fr","columns":""},{"areas":"\"a b e f\" \"c d e f\" \"g h i i\" \"g h j j\"","rows":"","columns":""},{"areas":"\"a b c d\" \"a b c e\" \"a b c f\" \"g g g j\" \"h h h j\" \"i i i j\"","rows":"","columns":"1fr 1fr 1fr 3fr"},{"areas":"\"a a b c\" \"a a d e\" \"f g j j\" \"h i j j\"","rows":"","columns":""},{"areas":"\"a a b c\" \"d e b j\" \"f g i j\" \"h h i j\"","rows":"2fr 1fr 1fr 2fr","columns":"1fr 1fr 2fr 2fr"},{"areas":"\"a b b b\" \"c d e h\" \"c f g h\" \"i i i j\"","rows":"2fr 1fr 1fr 2fr","columns":"2fr 1fr 1fr 2fr"},{"areas":"\"a a b c\" \"d e e f\" \"g e e f\" \"g h h f\" \"i h h j\"","rows":"","columns":"1fr 1fr 1fr 2fr"},{"areas":"\"a a a j\" \"b b b j\" \"c c c j\" \"d e f j\" \"g h i j\"","rows":"","columns":"1fr 1fr 1fr 2fr"},{"areas":"\"a a a b b b\" \"c d e f g h\" \"i i i j j j\"","rows":"3fr 1fr 2fr","columns":""},{"areas":"\"a a a a b\" \"a a a a c\" \"a a a a d\" \"a a a a e\" \"j i h g f\"","rows":"","columns":""},{"areas":"\"a a b b\" \"c d d e\" \"f f f f\" \"g h h i\" \"j j k k\"","rows":"","columns":"2fr 1fr 1fr 2fr"},{"areas":"\"a c d e\" \"a f g h\" \"b f g h\" \"b i j k\"","rows":"2fr 1fr 1fr 2fr","columns":"2fr 1fr 1fr 1fr"},{"areas":"\"a b c d\" \"e f g d\" \"e f g k\" \"h i j k\"","rows":"2fr 1fr 1fr 2fr","columns":"1fr 1fr 1fr 2fr"},{"areas":"\"a b k\" \"c d k\" \"e f k\" \"g h k\" \"i j k\"","rows":"","columns":""},{"areas":"\"a b c\" \"a d e\" \"a f g\" \"a h i\" \"a j k\"","rows":"","columns":""},{"areas":"\"a b c d e\" \"f g h i j\" \"k k k k k\"","rows":"","columns":""},{"areas":"\"a a a a a\" \"b c d e f\" \"g h i j k\"","rows":"","columns":""},{"areas":"\"a b c d e\" \"f f f f f\" \"g h i j k\"","rows":"","columns":""},{"areas":"\"a f g\" \"b f h\" \"c f i\" \"d f j\" \"e f k\"","rows":"","columns":"4fr 7fr 4fr"},{"areas":"\"a a b b b\" \"c d e f g\" \"h h h i i\" \"j j k k k\"","rows":"4fr 3fr 4fr 4fr","columns":""},{"areas":"\"a b c d e\" \"f f f f e\" \"f f f f g\" \"h i j k g\"","rows":"","columns":""},{"areas":"\"a a b b\" \"a a c d\" \"e e f f\" \"g h f f\" \"i i j j\" \"i i k k\"","rows":"","columns":""},{"areas":"\"a a a b\" \"a a a c\" \"d e f g\" \"h i j k\"","rows":"","columns":""},{"areas":"\"a b e e e\" \"c d e e e\" \"f f f g h\" \"f f f i j\" \"k k k k k\"","rows":"1fr 1fr 1fr 1fr 2fr","columns":"1fr 1fr 2fr 1fr 1fr"},{"areas":"\"a a a a\" \"b c d k\" \"e f g k\" \"h i j k\"","rows":"3fr 1fr 1fr 1fr","columns":"1fr 1fr 1fr 3fr"},{"areas":"\"a f g\" \"b f h\" \"c f i\" \"d f j\" \"e f k\"","rows":"","columns":"1fr 3fr 1fr"},{"areas":"\"a b c d e\" \"f f f f f\" \"g h i j k\"","rows":"1fr 3fr 1fr","columns":""},{"areas":"\"a b b d\" \"a c c d\" \"e f g k\" \"e h h k\" \"e i j k\"","rows":"3fr 3fr 2fr 2fr 2fr","columns":"2fr 1fr 1fr 2fr"},{"areas":"\"a b c d\" \"e f f g\" \"h i j k\"","rows":"","columns":""},{"areas":"\"a a b\" \"a a c\" \"a a d\" \"e h h\" \"f h h\" \"g h h\"","rows":"","columns":"1fr 3fr 1fr"},{"areas":"\"a a g i\" \"b c g j\" \"d e h j\" \"f f h k\"","rows":"2fr 1fr 1fr 2fr","columns":"1fr 1fr 2fr 2fr"},{"areas":"\"a a b c\" \"d e e f\" \"g e e f\" \"g h h f\" \"i j j k\"","rows":"","columns":"1fr 1fr 1fr 2fr"},{"areas":"\"a a b c c\" \"d e e e f\" \"g e e e h\" \"i i j k k\"","rows":"","columns":""},{"areas":"\"a a b c d\" \"a a e e e\" \"f g e e e\" \"h h i i j\" \"h h i i k\"","rows":"1fr 2fr 1fr 1fr 1fr","columns":""},{"areas":"\"a b c d e f\" \"g h i j k l\"","rows":"","columns":""},{"areas":"\"a b\" \"c d\" \"e f\" \"g h\" \"i j\" \"k l\"","rows":"","columns":""},{"areas":"\"a b c d\" \"e f g h\" \"i j k l\"","rows":"","columns":""},{"areas":"\"a b c\" \"d e f\" \"g h i\" \"j k l\"","rows":"","columns":""},{"areas":"\"a a b b\" \"a a c d\" \"a a e f\" \"g h l l\" \"i j l l\" \"k k l l\"","rows":"","columns":""},{"areas":"\"a a b b\" \"a a c d\" \"e e f f\" \"g h f f\" \"i i j j\" \"i i k l\"","rows":"","columns":""},{"areas":"\"a a b\" \"c d d\" \"e e f\" \"g h h\" \"i i j\" \"k l l\"","rows":"","columns":"2fr 1fr 2fr"},{"areas":"\"a b c c\" \"d d e f\" \"g h i i\" \"j j k l\"","rows":"","columns":""},{"areas":"\"a b c c\" \"d b e f\" \"g h i j\" \"k k l l\"","rows":"","columns":""},{"areas":"\"a a a b\" \"a a a c\" \"d e f g\" \"h i j j\" \"k l j j\"","rows":"","columns":""},{"areas":"\"a c d f\" \"b c e f\" \"g h j k\" \"g i j l\"","rows":"","columns":""},{"areas":"\"a b c d\" \"e f g h\" \"i j k l\"","rows":"1fr 2fr 1fr","columns":""},{"areas":"\"a a b b\" \"c d d e\" \"f f g g\" \"h i i j\" \"k k l l\"","rows":"1fr 1fr 2fr 1fr 1fr","columns":"2fr 1fr 1fr 2fr"},{"areas":"\"a c c d\" \"b c c d\" \"e f g h\" \"i j j k\" \"i j j l\"","rows":"1fr 1fr 2fr 1fr 1fr","columns":"2fr 1fr 1fr 2fr"},{"areas":"\"a a a b\" \"c d e l\" \"f g h l\" \"i j k l\"","rows":"3fr 1fr 1fr 1fr","columns":"1fr 1fr 1fr 3fr"},{"areas":"\"a b c d\" \"a e e d\" \"f g g h\" \"f i j h\"","rows":"1fr 2fr 2fr 1fr","columns":"1fr 2fr 2fr 1fr"},{"areas":"\"a a a a a a\" \"b c c d d e\" \"f f g g h h\" \"i j j k k l\"","rows":"3fr 1fr 1fr 1fr","columns":"3fr 1fr 2fr 2fr 1fr 3fr"},{"areas":"\"a a b c d\" \"e f f g g\" \"h f f g g\" \"h i i g g\" \"j k k l l\"","rows":"","columns":""},{"areas":"\"a b b c\" \"d e f g\" \"h i j g\" \"h k k m\" \"l k k m\"","rows":"2fr 1fr 1fr 1fr 1fr","columns":"2fr 1fr 1fr 2fr"},{"areas":"\"a b b c\" \"d e f g\" \"d h i g\" \"j k k l\"","rows":"","columns":""},{"areas":"\"a a b d\" \"a a c d\" \"e f h h\" \"e g h h\" \"i i j l\" \"i i k l\"","rows":"","columns":"2fr 1fr 1fr 2fr"},{"areas":"\"a b c d\" \"l l l e\" \"l l l f\" \"l l l g\" \"k j i h\"","rows":"","columns":""},{"areas":"\"a b c d\" \"e e c f\" \"e e c g\" \"h i l l\" \"h j l l\" \"h k l l\"","rows":"","columns":""},{"areas":"\"a a a b b\" \"a a a c d\" \"a a a e f\" \"g h i l l\" \"g j k l l\"","rows":"2fr 1fr 1fr 1fr 1fr","columns":"2fr 1fr 1fr 1fr 1fr"},{"areas":"\"a a a a a a\" \"b c d e f g\" \"h i j k l m\"","rows":"","columns":""},{"areas":"\"a b c d e f\" \"g g g g g g\" \"h i j k l m\"","rows":"","columns":""},{"areas":"\"a b c d e f\" \"g h i j k l\" \"m m m m m m\"","rows":"","columns":""},{"areas":"\"a b h\" \"a c i\" \"a d j\" \"a e k\" \"a f l\" \"a g m\"","rows":"","columns":""},{"areas":"\"a g h\" \"b g i\" \"c g j\" \"d g k\" \"e g l\" \"f g m\"","rows":"","columns":""},{"areas":"\"a b m\" \"c d m\" \"e f m\" \"g h m\" \"i j m\" \"k l m\"","rows":"","columns":""},{"areas":"\"a a a a a a\" \"b c d e f g\" \"h i j k l m\"","rows":"3fr 1fr 1fr","columns":""},{"areas":"\"a b c d\" \"a e f g\" \"a h i j\" \"a k l m\"","rows":"","columns":"2fr 1fr 1fr 1fr"},{"areas":"\"a b c\" \"d e f\" \"g g g\" \"h i j\" \"k l m\"","rows":"","columns":""},{"areas":"\"a b c d\" \"e e f f\" \"g g g g\" \"h h i i\" \"j k l m\"","rows":"","columns":""},{"areas":"\"a b c d e\" \"f g g g h\" \"i j k l m\"","rows":"1fr 3fr 1fr","columns":""},{"areas":"\"a b c d e\" \"f f g h h\" \"i j k l m\"","rows":"1fr 2fr 1fr","columns":""},{"areas":"\"a a b c d\" \"e f g h h\" \"i i i j k\" \"i i i l m\"","rows":"","columns":""},{"areas":"\"a a a l\" \"b b b l\" \"c d e l\" \"f g h m\" \"i j k m\"","rows":"","columns":"1fr 1fr 1fr 2fr"},{"areas":"\"a b c d d\" \"e f c d d\" \"g g h i j\" \"g g h k l\" \"m m m m m\"","rows":"1fr 1fr 1fr 1fr 2fr","columns":"1fr 1fr 2fr 1fr 1fr"},{"areas":"\"a b c d\" \"e f f g\" \"h f f i\" \"j k l m\"","rows":"1fr 2fr 2fr 1fr","columns":"1fr 2fr 2fr 1fr"},{"areas":"\"a b c d\" \"e f f g\" \"h f f i\" \"j k l m\"","rows":"","columns":""},{"areas":"\"a a b c\" \"d e f g\" \"h i j j\" \"k k l m\"","rows":"","columns":""},{"areas":"\"a b c d\" \"e f f g\" \"h f f g\" \"i j j j\" \"k l l m\"","rows":"","columns":"1fr 1fr 1fr 2fr"},{"areas":"\"a d f i k\" \"b d g i l\" \"b e g j l\" \"c e h j m\"","rows":"2fr 1fr 1fr 2fr","columns":""},{"areas":"\"a a a b c d\" \"a a a b e f\" \"a a a m m m\" \"g h i m m m\" \"g j k m m m\" \"l l l m m m\"","rows":"1fr 1fr 2fr 1fr 1fr 2fr","columns":"2fr 1fr 1fr 2fr 1fr 1fr"},{"areas":"\"a b c d e f g\" \"h i j k l m n\"","rows":"","columns":""},{"areas":"\"a b\" \"c d\" \"e f\" \"g h\" \"i j\" \"k l\" \"m n\"","rows":"","columns":""},{"areas":"\"a a b c\" \"a a d e\" \"a a f g\" \"h i n n\" \"j k n n\" \"l m n n\"","rows":"","columns":""},{"areas":"\"a a b b\" \"c d e f\" \"g h i j\" \"k l m n\"","rows":"3fr 1fr 1fr 1fr","columns":""},{"areas":"\"a a b b c c\" \"d e e f f g\" \"h h i i j j\" \"k l l m m n\"","rows":"","columns":"3fr 1fr 2fr 2fr 1fr 3fr"},{"areas":"\"a a b b c c\" \"d e e f f g\" \"h i i j j k\" \"l l m m n n\"","rows":"","columns":"3fr 1fr 2fr 2fr 1fr 3fr"},{"areas":"\"a a b c c d\" \"e e e f f f\" \"g h h i j j\" \"k k l m m n\"","rows":"","columns":"3fr 1fr 3fr 3fr 1fr 3fr"},{"areas":"\"a b c d\" \"e e f f\" \"g h i j\" \"k l m n\"","rows":"1fr 2fr 1fr 1fr","columns":""},{"areas":"\"a a b b\" \"c d e f\" \"g h i j\" \"k l m n\"","rows":"2fr 1fr 1fr 1fr","columns":""},{"areas":"\"a a b c d\" \"a a e f g\" \"h i j k k\" \"l m n k k\"","rows":"","columns":""},{"areas":"\"a b g g\" \"c d g g\" \"e f h i\" \"j j k l\" \"j j m n\"","rows":"","columns":""},{"areas":"\"a b c d d\" \"e e c d d\" \"e e f f g\" \"h i k l l\" \"j j k l l\" \"j j k m n\"","rows":"","columns":"1fr 1fr 2fr 1fr 1fr"},{"areas":"\"a c c d f f\" \"b c c e f f\" \"g g g g g g\" \"h h i k k l\" \"h h j k k m\" \"n n n n n n\"","rows":"1fr 1fr 2fr 1fr 1fr 2fr","columns":""},{"areas":"\"a a a b c\" \"a a a d e\" \"a a a f g\" \"h i n n n\" \"j k n n n\" \"l m n n n\"","rows":"","columns":"1fr 1fr 2fr 1fr 1fr"},{"areas":"\"a b c c d e\" \"f f f g g g\" \"h i j j k l\" \"m m m n n n\"","rows":"3fr 2fr 3fr 2fr","columns":"2fr 2fr 1fr 1fr 2fr 2fr"},{"areas":"\"a a b b c c\" \"d e b b j k\" \"f g i i l m\" \"h h i i n n\"","rows":"2fr 1fr 1fr 2fr","columns":""},{"areas":"\"a b c c d d\" \"e e f g d d\" \"h h h h h h\" \"i j k l m n\"","rows":"1fr 1fr 2fr 1fr","columns":""},{"areas":"\"a b b c c d\" \"e e f f g g\" \"h i i j j k\" \"l l m m n n\"","rows":"","columns":"3fr 1fr 2fr 2fr 1fr 3fr"},{"areas":"\"a b c d e\" \"f g h i j\" \"k l m n o\"","rows":"","columns":""},{"areas":"\"a b c\" \"d e f\" \"g h i\" \"j k l\" \"m n o\"","rows":"","columns":""},{"areas":"\"a b c d e\" \"f g g g i\" \"h g g g i\" \"h g g g j\" \"k l m n o\"","rows":"","columns":""},{"areas":"\"a b c d e\" \"f f g h h\" \"i i g j j\" \"k l m n o\"","rows":"","columns":""},{"areas":"\"a a b c d\" \"e f g h h\" \"i i j k l\" \"i i m n o\"","rows":"","columns":""},{"areas":"\"a a b c c\" \"d d e c c\" \"f g h c c\" \"i j k k l\" \"m j n o o\"","rows":"","columns":""},{"areas":"\"a a a b c\" \"a a a d d\" \"e f g g h\" \"i j j k l\" \"m j j n o\"","rows":"","columns":""},{"areas":"\"a b b c d\" \"e f f f g\" \"h f f f i\" \"j k k l l\" \"m m n n o\"","rows":"","columns":""},{"areas":"\"a a a b b\" \"c d d e f\" \"g h i j k\" \"l m n n o\"","rows":"2fr 1fr 1fr 1fr","columns":""},{"areas":"\"a b c d d\" \"e f g d d\" \"h i j d d\" \"k l m n o\"","rows":"","columns":""},{"areas":"\"a b i i i\" \"c d i i i\" \"e f i i i\" \"g h j j k\" \"l l m n o\"","rows":"","columns":""},{"areas":"\"a b c d d\" \"a e f g h\" \"i e f g j\" \"k e f g l\" \"m m n o l\"","rows":"","columns":""},{"areas":"\"a b b b c\" \"d e f g h\" \"d i i i h\" \"d j k l h\" \"m n n n o\"","rows":"","columns":""},{"areas":"\"a b b c d\" \"e f g g d\" \"e f h i j\" \"k l l i j\" \"k m n n o\"","rows":"","columns":""},{"areas":"\"a b c d e\" \"f g g h h\" \"i g g h h\" \"j k k h h\" \"l m n o o\"","rows":"","columns":""},{"areas":"\"a b b c c d\" \"e f f f f g\" \"h f f f f i\" \"j f f f f k\" \"l m m n n o\"","rows":"1fr 1fr 1fr 2fr 1fr","columns":""},{"areas":"\"a b c d e\" \"n o o o f\" \"m o o o g\" \"l k j i h\"","rows":"","columns":""},{"areas":"\"a a a b c\" \"a a a d e\" \"f g j j j\" \"h i j j j\" \"k k k l m\" \"k k k n o\"","rows":"","columns":"1fr 1fr 2fr 1fr 1fr"},{"areas":"\"a b c d e f\" \"g m m m m j\" \"h m m m m k\" \"i m m m m l\" \"n n n o o o\"","rows":"1fr 1fr 1fr 1fr 2fr","columns":""},{"areas":"\"a a a b c c\" \"a a a d d d\" \"e f g d d d\" \"e h i d d d\" \"j k k k l m\" \"j k k k n o\"","rows":"2fr 2fr 1fr 1fr 1fr 1fr","columns":"2fr 1fr 1fr 2fr 1fr 1fr"},{"areas":"\"a a b b c\" \"a a d e h\" \"a a f g h\" \"i j m m h\" \"k l m m h\" \"n n m m o\"","rows":"2fr 1fr 1fr 1fr 1fr 2fr","columns":"1fr 1fr 1fr 1fr 4fr"},{"areas":"\"a b c d e f g h\" \"i j k l m n o p\"","rows":"","columns":""},{"areas":"\"a i\" \"b j\" \"c k\" \"d l\" \"e m\" \"f n\" \"g o\" \"h p\"","rows":"","columns":""},{"areas":"\"a b c d\" \"e f g h\" \"i j k l\" \"m n o p\"","rows":"","columns":""},{"areas":"\"a a a a a\" \"b c d e f\" \"g h i j k\" \"l m n o p\"","rows":"2fr 1fr 1fr 1fr","columns":""},{"areas":"\"a a a b b\" \"c d d e f\" \"g h i j k\" \"l m n o p\"","rows":"2fr 1fr 1fr 1fr","columns":""},{"areas":"\"a b c d e\" \"f g g g h\" \"i g g g j\" \"k k l m m\" \"n n o p p\"","rows":"","columns":""},{"areas":"\"a b c d e\" \"f f g i k\" \"f f h j k\" \"l m n o p\"","rows":"2fr 1fr 1fr 1fr","columns":""},{"areas":"\"a b c c d\" \"e f c c g\" \"h h i j k\" \"h h l m m\" \"n n o p p\"","rows":"","columns":""},{"areas":"\"a b c d\" \"a e f g\" \"a h i j\" \"a k l m\" \"a n o p\"","rows":"","columns":"2fr 1fr 1fr 1fr"},{"areas":"\"a a a b c\" \"d e f g h\" \"i j k k k\" \"l m n o p\"","rows":"","columns":""},{"areas":"\"a a b c d\" \"e f g h h\" \"i i j k l\" \"m n o p p\"","rows":"","columns":""},{"areas":"\"a b c d\" \"e f g d\" \"h i j d\" \"k l m d\" \"n o p d\"","rows":"","columns":"1fr 1fr 1fr 2fr"},{"areas":"\"a a b b c d\" \"a a b b e f\" \"a a g h k k\" \"a a i j k k\" \"l m p p p p\" \"n o p p p p\"","rows":"1fr 1fr 1fr 1fr 2fr 2fr","columns":"2fr 2fr 1fr 1fr 1fr 1fr"},{"areas":"\"a b c d e\" \"f g g h h\" \"i g g h h\" \"j k k h h\" \"l m n o p\"","rows":"","columns":""},{"areas":"\"a a a a b c\" \"a a a a d e\" \"f j j m o o\" \"g j j n o o\" \"h j j p p p\" \"i k l p p p\"","rows":"","columns":""},{"areas":"\"a b c d e\" \"f g g g h\" \"i g g g j\" \"k g g g l\" \"m n o p q\"","rows":"","columns":""},{"areas":"\"a b c d d\" \"e f g h i\" \"j f g h k\" \"l f g h m\" \"n n o p q\"","rows":"","columns":""},{"areas":"\"a b c d d\" \"e f f f g\" \"h i i i j\" \"k l l l m\" \"n n o p q\"","rows":"","columns":""},{"areas":"\"a a b c c\" \"d d e f f\" \"g h i j k\" \"l l m n n\" \"o o p q q\"","rows":"","columns":""},{"areas":"\"a b c d d\" \"e f g h i\" \"e j g k i\" \"e l g m i\" \"n n o p q\"","rows":"","columns":""},{"areas":"\"a b c d e\" \"a b f d e\" \"g h i j k\" \"l m n o p\" \"l m q o p\"","rows":"","columns":""},{"areas":"\"a b c d e\" \"f g h i j\" \"f g k i j\" \"l m n o p\" \"l m q o p\"","rows":"","columns":""},{"areas":"\"a a b b c\" \"d e f g c\" \"d h i j k\" \"l m n o k\" \"l p p q q\"","rows":"","columns":""},{"areas":"\"a b b c d\" \"e f g h d\" \"e f i j k\" \"l m n j k\" \"l o p p q\"","rows":"","columns":""},{"areas":"\"a b b c c\" \"d d e e f\" \"g h i j k\" \"l m m n n\" \"o o p p q\"","rows":"","columns":""},{"areas":"\"a b c d\" \"e f g h\" \"i f g j\" \"k l l m\" \"n o p q\"","rows":"1fr 1fr 1fr 2fr 1fr","columns":"1fr 2fr 2fr 1fr"},{"areas":"\"a b c d e\" \"f g g h h\" \"i g g l l\" \"j k k l l\" \"m n o p q\"","rows":"","columns":""},{"areas":"\"a b c d e f\" \"g h i j k l\" \"m n o p q r\"","rows":"","columns":""},{"areas":"\"a b c\" \"d e f\" \"g h i\" \"j k l\" \"m n o\" \"p q r\"","rows":"","columns":""},{"areas":"\"a b c d e\" \"f g h i e\" \"j k l m n\" \"j o p q r\"","rows":"","columns":""},{"areas":"\"a a b c c\" \"d d e f f\" \"g h i i j\" \"k l m n o\" \"p p q r r\"","rows":"","columns":""},{"areas":"\"a a b c c\" \"d d e f f\" \"g h i j k\" \"l l m n n\" \"o o p q r\"","rows":"","columns":""},{"areas":"\"a b c d e f\" \"a g h i j f\" \"a k l m n f\" \"a o p q r f\"","rows":"","columns":""},{"areas":"\"a b c c c c\" \"d e c c c c\" \"f g c c c c\" \"h i c c c c\" \"j k l m n o\" \"p p q q r r\"","rows":"","columns":""},{"areas":"\"a a b b c c\" \"d d e e f f\" \"g h i j k l\" \"m n o p q r\"","rows":"2fr 2fr 1fr 1fr","columns":""},{"areas":"\"a b c d e f\" \"g h i j k l\" \"m n o p q r\"","rows":"","columns":""},{"areas":"\"a b c d e f\" \"g g h h i i\" \"j k l m n o\" \"p p q q r r\"","rows":"","columns":""},{"areas":"\"a b c c d d\" \"e f c c d d\" \"g g h i j j\" \"g g k l j j\" \"m m n n o p\" \"m m n n q r\"","rows":"","columns":""},{"areas":"\"a b b c c d\" \"e f g g h h\" \"i i j k l l\" \"m m n o p p\" \"q q q r r r\"","rows":"","columns":""},{"areas":"\"a b c d e\" \"f g h i j\" \"k g h i l\" \"m g h i n\" \"o p q r s\"","rows":"","columns":""},{"areas":"\"a b c d e\" \"f g g g j\" \"k h h h l\" \"m i i i n\" \"o p q r s\"","rows":"","columns":""},{"areas":"\"a b b b c\" \"d e f g h\" \"i j j j k\" \"l m n o p\" \"q r r r s\"","rows":"","columns":""},{"areas":"\"a b c d e\" \"f g h i e\" \"j k k k e\" \"j l m n o\" \"j p q r s\"","rows":"","columns":""},{"areas":"\"a b c d e\" \"f g h i j\" \"f k k k j\" \"f l m n j\" \"o p q r s\"","rows":"","columns":""},{"areas":"\"a a a b c\" \"d e f g h\" \"i j j j k\" \"l m n o p\" \"q r s s s\"","rows":"","columns":""},{"areas":"\"a b c d e\" \"f g h i e\" \"j k h l e\" \"j m h n o\" \"j p q r s\"","rows":"","columns":""},{"areas":"\"a b b b c\" \"d e f g h\" \"i j f k l\" \"m n f o p\" \"q r r r s\"","rows":"","columns":""},{"areas":"\"a b c d e\" \"f g h d i\" \"j k h d l\" \"m k h n o\" \"p k q r s\"","rows":"","columns":""},{"areas":"\"a b c d e f g h i j\" \"k l m n o p q r s t\"","rows":"","columns":""},{"areas":"\"a k\" \"b l\" \"c m\" \"d n\" \"e o\" \"f p\" \"g q\" \"h r\" \"i s\" \"j t\"","rows":"","columns":""},{"areas":"\"a b c d e\" \"f g h i j\" \"k l m n o\" \"p q r s t\"","rows":"","columns":""},{"areas":"\"a b c d e f g h i\" \"j j j j j j j j j\" \"k l m n o p q r s\" \"t t t t t t t t t\"","rows":"","columns":""},{"areas":"\"a b c d e f g h i\" \"j j j j j j j j j\" \"k k k k k k k k k\" \"l m n o p q r s t\"","rows":"","columns":""},{"areas":"\"a b c d\" \"a e c d\" \"f g h i\" \"f g j i\" \"k l m n\" \"o l m n\" \"p q r s\" \"p q r t\"","rows":"","columns":""},{"areas":"\"a a a a a\" \"b c c c c\" \"b d e f g\" \"b h i j g\" \"k l m n g\" \"o o p q r\" \"o o s s s\" \"t t t t t\"","rows":"","columns":""},{"areas":"\"a a a a b\" \"a a a a c\" \"d e f g h\" \"i i i j k\" \"l m n n o\" \"p q r s t\"","rows":"1fr 3fr 1fr 1fr 1fr 1fr","columns":""},{"areas":"\"a a a a a\" \"b c d e f\" \"b g g h i\" \"b g g j i\" \"k l m n i\" \"o o p p p\" \"o o q r s\" \"t t t t t\"","rows":"","columns":""},{"areas":"\"a b c j j j\" \"d e f j j j\" \"g h i j j j\" \"k k k l m n\" \"k k k o p q\" \"k k k r s t\"","rows":"","columns":""},{"areas":"\"a a a b c d\" \"a a a e f g\" \"a a a h i j\" \"k l m t t t\" \"n o p t t t\" \"q r s t t t\"","rows":"","columns":""},{"areas":"\"a a a a b\" \"a a a a c\" \"a a a a h\" \"d e f g h\" \"i i j k l\" \"m n o p q\" \"r s t t t\"","rows":"1fr 1fr 2fr 1fr 1fr 1fr 1fr","columns":""},{"areas":"\"a b c d e f g\" \"h i j k l m n\" \"o p q r s t u\"","rows":"","columns":""},{"areas":"\"a b c\" \"d e f\" \"g h i\" \"j k l\" \"m n o\" \"p q r\" \"s t u\"","rows":"","columns":""},{"areas":"\"a b b c c d\" \"e f f g g h\" \"i j j k k l\" \"m m n n o o\" \"p p q q r r\" \"s s t t u u\"","rows":"","columns":"3fr 1fr 2fr 2fr 1fr 3fr"},{"areas":"\"a b c d d\" \"e f g h h\" \"i j k l m\" \"n n o p q\" \"r r s t u\"","rows":"","columns":""},{"areas":"\"a b c c d d e f\" \"g g g h i j k k\" \"l l m n n o o o\" \"p q q r s t u u\"","rows":"","columns":""},{"areas":"\"a a b c d e e\" \"f f f g g g h\" \"i j k l m m n\" \"o o o p q q q\" \"r r s s t u u\"","rows":"","columns":""},{"areas":"\"a a a a b c c d\" \"a a a a e e f g\" \"h i j k l l l m\" \"n n n o l l l p\" \"q q r r s t t u\"","rows":"","columns":""},{"areas":"\"a a b b c c d d\" \"e e f f f f g h\" \"i j f f f f k l\" \"m m m n o o o p\" \"q q r r s t t u\"","rows":"","columns":""},{"areas":"\"a b b c c d\" \"e e f f g g\" \"h i i j j k\" \"l l m m n n\" \"o p p q q r\" \"s s t t u u\"","rows":"","columns":"3fr 1fr 2fr 2fr 1fr 3fr"},{"areas":"\"a b b c d\" \"e b b f g\" \"h i j j k\" \"l m j j n\" \"o p p q r\" \"s p p t u\"","rows":"","columns":""},{"areas":"\"a b c d e f\" \"t u u u u g\" \"s u u u u h\" \"r u u u u i\" \"q u u u u j\" \"p o n m l k\"","rows":"","columns":""},{"areas":"\"a a b c\" \"a a d e\" \"f g h h\" \"i i j k\" \"l m n o\" \"p p q r\" \"s s t t\" \"s s u u\"","rows":"","columns":""},{"areas":"\"a b c d e f g h i j k\" \"l m n o p q r s t u v\"","rows":"","columns":""},{"areas":"\"a l\" \"b m\" \"c n\" \"d o\" \"e p\" \"f q\" \"g r\" \"h s\" \"i t\" \"j u\" \"k v\"","rows":"","columns":""},{"areas":"\"a a a a a a a\" \"b c d e f g h\" \"i j k l m n o\" \"p q r s t u v\"","rows":"2fr 1fr 1fr 1fr","columns":""},{"areas":"\"a b c d d\" \"e f g h i\" \"j j k l l\" \"m n o p q\" \"r r s t u\"","rows":"","columns":""},{"areas":"\"a a b c d e\" \"f g h i j k\" \"l m n o p q\" \"r s t u v v\"","rows":"","columns":""},{"areas":"\"a b e e e\" \"c b e e e\" \"d d e e e\" \"f g i i j\" \"h h i i k\" \"l m n o p\" \"q r r s p\" \"t r r u v\"","rows":"","columns":""},{"areas":"\"a a b b c\" \"a a b b d\" \"e g g h i\" \"f g g j k\" \"l m m n n\" \"o m m n n\" \"p q r r s\" \"t u r r v\"","rows":"","columns":""},{"areas":"\"a b c d e k k k k k\" \"f g h i j k k k k k\" \"l l l l l m n o p q\" \"l l l l l r s t u v\"","rows":"","columns":""},{"areas":"\"a b c d e k\" \"f g h i j k\" \"l m n o p v\" \"q r s t u v\"","rows":"","columns":"1fr 1fr 1fr 1fr 1fr 5fr"},{"areas":"\"a b c c d d e f\" \"g g g h i j k k\" \"l m n o o p p p\" \"q r r s t u v v\"","rows":"","columns":""},{"areas":"\"a b c d e f\" \"t u u u u g\" \"s u u u u h\" \"r v v v v i\" \"q v v v v j\" \"p o n m l k\"","rows":"","columns":""},{"areas":"\"a b c d e f\" \"t u u v v g\" \"s u u v v h\" \"r u u v v i\" \"q u u v v j\" \"p o n m l k\"","rows":"","columns":""},{"areas":"\"a a a a b b c d\" \"a a a a b b e f\" \"a a a a g h k k\" \"a a a a i j k k\" \"l l m n v v v v\" \"l l o p v v v v\" \"q r u u v v v v\" \"s t u u v v v v\"","rows":"","columns":""},{"areas":"\"a a a b b b\" \"a a a b b b\" \"c d g g h i\" \"e f g g j k\" \"l l l m m m\" \"n o r r s t\" \"p q r r u v\"","rows":"1fr 1fr 1fr 1fr 2fr 1fr 1fr","columns":"1fr 1fr 2fr 2fr 1fr 1fr"},{"areas":"\"a b e f g g\" \"a c e f g g\" \"d d e f h i\" \"d d e f h j\" \"k k k q q q\" \"l m o q q q\" \"l n o q q q\" \"p p o q q q\"","rows":"1fr 1fr 1fr 1fr 4fr 1fr 1fr 2fr","columns":"1fr 1fr 2fr 2fr 1fr 1fr"},{"areas":"\"a a a a b b b b\" \"c d e f f g h i\" \"j k l m m n o p\" \"q r s t t u v w\"","rows":"2fr 1fr 1fr 1fr","columns":"2fr 2fr 2fr 1fr 1fr 2fr 2fr 2fr"},{"areas":"\"a b c d e f g\" \"h h h h h h h\" \"i j k l m n o\" \"p p p p p p p\" \"q r s t u v w\"","rows":"","columns":""},{"areas":"\"a a a a b\" \"a a a a c\" \"d e f f c\" \"g h i j k\" \"l l l m n\" \"o p q q r\" \"s t u v w\"","rows":"1fr 2fr 1fr 1fr 1fr 1fr 1fr","columns":""},{"areas":"\"a a b b c\" \"a a b b d\" \"e g g h i\" \"f g g j k\" \"l l m n n\" \"o o p n n\" \"q r s s v\" \"t u s s w\"","rows":"","columns":""},{"areas":"\"a a a a b b b c c c c\" \"d d e e e f g g g h h\" \"i j j k k l m m n n o\" \"p p q q q r s s s t t\" \"u u u u v v v w w w w\"","rows":"","columns":"2fr 1fr 1fr 1fr 1fr 3fr 1fr 1fr 1fr 1fr 2fr"},{"areas":"\"a c c d d\" \"b c c d d\" \"e f g g h\" \"i j g g k\" \"i l l n o\" \"m l l p q\" \"r s t t u\" \"v v t t w\"","rows":"","columns":""},{"areas":"\"a b e e f h h\" \"c d e e g h h\" \"i k k l n h h\" \"j k k m o h h\" \"p p q s u u v\" \"p p r t u u w\"","rows":"","columns":""},{"areas":"\"a b e e e\" \"c b e e e\" \"d d e e e\" \"f g i i j\" \"h h i i k\" \"l m n o p\" \"q r r s t\" \"u r r v w\"","rows":"","columns":""},{"areas":"\"a b b b c d\" \"e b b b f g\" \"h i j k k l\" \"m n n o p q\" \"r s t u v w\"","rows":"","columns":""},{"areas":"\"a b b b c d\" \"e b b b f g\" \"h h i j j g\" \"l m m j j k\" \"n n o p q r\" \"s t u v w w\"","rows":"","columns":""},{"areas":"\"a b c d e f\" \"t u u v v g\" \"s u u v v h\" \"r w w w w i\" \"q w w w w j\" \"p o n m l k\"","rows":"","columns":""},{"areas":"\"a b c d e f\" \"g h i i j k\" \"l l l l l l\" \"m n o o p q\" \"r s t u v w\"","rows":"1fr 1fr 2fr 1fr 1fr","columns":""},{"areas":"\"a b c d e f\" \"g h i j k l\" \"m n o p q r\" \"s t u v w x\"","rows":"","columns":""},{"areas":"\"a b c d\" \"e f g h\" \"i j k l\" \"m n o p\" \"q r s t\" \"u v w x\"","rows":"","columns":""},{"areas":"\"a b c d e f g h\" \"i j k l m n o p\" \"q r s t u v w x\"","rows":"","columns":""},{"areas":"\"a b c\" \"d e f\" \"g h i\" \"j k l\" \"m n o\" \"p q r\" \"s t u\" \"v w x\"","rows":"","columns":""},{"areas":"\"a a b c c c\" \"d e f c c c\" \"g g g h i j\" \"g g g k l m\" \"n o p q q r\" \"s u u v x x\" \"t u u w x x\"","rows":"","columns":""},{"areas":"\"a b c d d e\" \"f g h d d i\" \"j k k k k l\" \"m k k k k r\" \"m n o p q r\" \"s s t v v w\" \"s s u v v x\"","rows":"","columns":""},{"areas":"\"a b e e f\" \"c d e e g\" \"h h h h i\" \"h h h h j\" \"k l m n n\" \"o o p n n\" \"o o r s t\" \"u v w w x\"","rows":"","columns":""},{"areas":"\"a c c d d e\" \"b c c d d f\" \"g g h i j j\" \"g g k l j j\" \"m m n n o o\" \"p p n n q q\" \"p p r s q q\" \"t u v v w x\"","rows":"","columns":""},{"areas":"\"a b e e e e\" \"c b e e e e\" \"d d e e e e\" \"f g i i j k\" \"h h i i l k\" \"m n o p q q\" \"r t t u q q\" \"s t t v w x\"","rows":"","columns":""},{"areas":"\"a a a a b c\" \"a a a a d d\" \"e f g h i j\" \"k k k l m n\" \"o p q q r r\" \"s t u v w x\"","rows":"1fr 3fr 1fr 1fr 1fr 1fr","columns":""},{"areas":"\"a b c d e f\" \"t u u v v g\" \"s u u v v h\" \"r w w x x i\" \"q w w x x j\" \"p o n m l k\"","rows":"","columns":""},{"areas":"\"a a b d e f\" \"a a c g g h\" \"k l m g g i\" \"n o o t u j\" \"p o o v x x\" \"q r s w x x\"","rows":"","columns":""},{"areas":"\"a b c d e\" \"f g h i j\" \"k l m n o\" \"p q r s t\" \"u v w x y\"","rows":"","columns":""},{"areas":"\"a b c d y\" \"e f g h y\" \"i j k l y\" \"m n o p y\" \"q r s t y\" \"u v w x y\"","rows":"","columns":"1fr 1fr 1fr 1fr 4fr"},{"areas":"\"a a a a a a\" \"b c d e f g\" \"h i j k l m\" \"n o p q r s\" \"t u v w x y\"","rows":"4fr 1fr 1fr 1fr 1fr","columns":""},{"areas":"\"a b c d e f\" \"g h i j k l\" \"m n o p q r\" \"s t u v w x\" \"y y y y y y\"","rows":"1fr 1fr 1fr 1fr 4fr","columns":""},{"areas":"\"a b c d e\" \"a f g h i\" \"a j k l m\" \"a n o p q\" \"a r s t u\" \"a v w x y\"","rows":"","columns":"4fr 1fr 1fr 1fr 1fr"},{"areas":"\"a b c d e f g\" \"h h h i i i i\" \"j k l m n o p\" \"q q q q r r r\" \"s t u v w x y\"","rows":"","columns":""},{"areas":"\"a h j q s\" \"b h k q t\" \"c h l q u\" \"d i m q v\" \"e i n r w\" \"f i o r x\" \"g i p r y\"","rows":"","columns":""},{"areas":"\"a b c c d e\" \"f g c c h i\" \"j k k l l m\" \"o k k l l n\" \"o p q r s n\" \"t u u w w x\" \"v u u w w y\"","rows":"","columns":""},{"areas":"\"a b m n o\" \"c d m p q\" \"e f m r s\" \"g h m t u\" \"i j m v w\" \"k l m x y\"","rows":"","columns":"1fr 1fr 3fr 1fr 1fr"},{"areas":"\"a b c d d d\" \"e f g d d d\" \"h h h i j k\" \"h h h l m n\" \"o p q r r s\" \"t v v w y y\" \"u v v x y y\"","rows":"","columns":""},{"areas":"\"a a a a b b c c c d d\" \"e e f f g h h i i j j\" \"k l l m n n o o o o o\" \"p p q q q q r r s s t\" \"u v v w x x y y y y y\"","rows":"","columns":"2fr 1fr 1fr 2fr 2fr 1fr 1fr 1fr 1fr 1fr 2fr"},{"areas":"\"a b c d e f\" \"g h i i j k\" \"l l m m n n\" \"o p q q r s\" \"t u v w x y\"","rows":"1fr 1fr 2fr 1fr 1fr","columns":""},{"areas":"\"a a a a b b c d\" \"a a a a b b e f\" \"a a a a g h k k\" \"a a a a i j k k\" \"l l m n q q r r\" \"l l o p q q r r\" \"s t w w x x y y\" \"u v w w x x y y\"","rows":"","columns":""},{"areas":"\"a a b d f f\" \"a a c e g g\" \"h i j j k l\" \"m n o p q r\" \"s s t u v v\" \"w w x y v v\"","rows":"","columns":""},{"areas":"\"a b c d\" \"e f g h\" \"i j k k\" \"l m n o\" \"p q r s\" \"t t u v\" \"w w x x\" \"w w y y\"","rows":"","columns":""},{"areas":"\"a b c d e f g h i\" \"j k l m n o p q r\" \"s t u v w x y z aa\"","rows":"","columns":""},{"areas":"\"a b c\" \"d e f\" \"g h i\" \"j k l\" \"m n o\" \"p q r\" \"s t u\" \"v w x\" \"y z aa\"","rows":"","columns":""},{"areas":"\"a b c d e f g\" \"h i j k l m n\" \"o p q r s t u\" \"v w x y z aa ab\"","rows":"","columns":""},{"areas":"\"a b c d\" \"e f g h\" \"i j k l\" \"m n o p\" \"q r s t\" \"u v w x\" \"y z aa ab\"","rows":"","columns":""},{"areas":"\"a b c d e f\" \"g h i j k l\" \"m n o p q r\" \"s t u v w x\" \"y z aa ab ac ad\"","rows":"","columns":""},{"areas":"\"a b c d e\" \"f g h i j\" \"k l m n o\" \"p q r s t\" \"u v w x y\" \"z aa ab ac ad\"","rows":"","columns":""},{"areas":"\"a b c d e f g h i j\" \"k l m n o p q r s t\" \"u v w x y z aa ab ac ad\"","rows":"","columns":""},{"areas":"\"a b c\" \"d e f\" \"g h i\" \"j k l\" \"m n o\" \"p q r\" \"s t u\" \"v w x\" \"y z aa\" \"ab ac ad\"","rows":"","columns":""},{"areas":"\"a b c d e f g h\" \"i j k l m n o p\" \"q r s t u v w x\" \"y z aa ab ac ad ae af\"","rows":"","columns":""},{"areas":"\"a b c d\" \"e f g h\" \"i j k l\" \"m n o p\" \"q r s t\" \"u v w x\" \"y z aa ab\" \"ac ad ae af\"","rows":"","columns":""},{"areas":"\"a b c d e f g\" \"h i j k l m n\" \"o p q r s t u\" \"v w x y z aa ab\" \"ac ad ae af ag ah ai\"","rows":"","columns":""},{"areas":"\"a b c d e\" \"f g h i j\" \"k l m n o\" \"p q r s t\" \"u v w x y\" \"z aa ab ac ad\" \"ae af ag ah ai\"","rows":"","columns":""},{"areas":"\"a b c d e f g h i\" \"j k l m n o p q r\" \"s t u v w x y z aa\" \"ab ac ad ae af ag ah ai aj\"","rows":"","columns":""},{"areas":"\"a b c d\" \"e f g h\" \"i j k l\" \"m n o p\" \"q r s t\" \"u v w x\" \"y z aa ab\" \"ac ad ae af\" \"ag ah ai aj\"","rows":"","columns":""},{"areas":"\"a b c d e f\" \"g h i j k l\" \"m n o p q r\" \"s t u v w x\" \"y z aa ab ac ad\" \"ae af ag ah ai aj\"","rows":"","columns":""},{"areas":"\"a b c d e f g h\" \"i j k l m n o p\" \"q r s t u v w x\" \"y z aa ab ac ad ae af\" \"ag ah ai aj ak al am an\"","rows":"","columns":""},{"areas":"\"a b c d e\" \"f g h i j\" \"k l m n o\" \"p q r s t\" \"u v w x y\" \"z aa ab ac ad\" \"ae af ag ah ai\" \"aj ak al am an\"","rows":"","columns":""},{"areas":"\"a b c d e f g h i j\" \"k l m n o p q r s t\" \"u v w x y z aa ab ac ad\" \"ae af ag ah ai aj ak al am an\"","rows":"","columns":""},{"areas":"\"a b c d\" \"e f g h\" \"i j k l\" \"m n o p\" \"q r s t\" \"u v w x\" \"y z aa ab\" \"ac ad ae af\" \"ag ah ai aj\" \"ak al am an\"","rows":"","columns":""},{"areas":"\"a b c d e f g\" \"h i j k l m n\" \"o p q r s t u\" \"v w x y z aa ab\" \"ac ad ae af ag ah ai\" \"aj ak al am an ao ap\"","rows":"","columns":""},{"areas":"\"a b c d e f\" \"g h i j k l\" \"m n o p q r\" \"s t u v w x\" \"y z aa ab ac ad\" \"ae af ag ah ai aj\" \"ak al am an ao ap\"","rows":"","columns":""},{"areas":"\"a b c d e f g h i\" \"j k l m n o p q r\" \"s t u v w x y z aa\" \"ab ac ad ae af ag ah ai aj\" \"ak al am an ao ap aq ar as\"","rows":"","columns":""},{"areas":"\"a b c d e\" \"f g h i j\" \"k l m n o\" \"p q r s t\" \"u v w x y\" \"z aa ab ac ad\" \"ae af ag ah ai\" \"aj ak al am an\" \"ao ap aq ar as\"","rows":"","columns":""},{"areas":"\"a b c d e f g h\" \"i j k l m n o p\" \"q r s t u v w x\" \"y z aa ab ac ad ae af\" \"ag ah ai aj ak al am an\" \"ao ap aq ar as at au av\"","rows":"","columns":""},{"areas":"\"a b c d e f\" \"g h i j k l\" \"m n o p q r\" \"s t u v w x\" \"y z aa ab ac ad\" \"ae af ag ah ai aj\" \"ak al am an ao ap\" \"aq ar as at au av\"","rows":"","columns":""},{"areas":"\"a b c d e f g\" \"h i j k l m n\" \"o p q r s t u\" \"v w x y z aa ab\" \"ac ad ae af ag ah ai\" \"aj ak al am an ao ap\" \"aq ar as at au av aw\"","rows":"","columns":""},{"areas":"\"a b c d e f g h i j\" \"k l m n o p q r s t\" \"u v w x y z aa ab ac ad\" \"ae af ag ah ai aj ak al am an\" \"ao ap aq ar as at au av aw ax\"","rows":"","columns":""},{"areas":"\"a b c d e\" \"f g h i j\" \"k l m n o\" \"p q r s t\" \"u v w x y\" \"z aa ab ac ad\" \"ae af ag ah ai\" \"aj ak al am an\" \"ao ap aq ar as\" \"at au av aw ax\"","rows":"","columns":""},{"areas":"\"a b c d e f g h i\" \"j k l m n o p q r\" \"s t u v w x y z aa\" \"ab ac ad ae af ag ah ai aj\" \"ak al am an ao ap aq ar as\" \"at au av aw ax ay az ba bb\"","rows":"","columns":""},{"areas":"\"a b c d e f\" \"g h i j k l\" \"m n o p q r\" \"s t u v w x\" \"y z aa ab ac ad\" \"ae af ag ah ai aj\" \"ak al am an ao ap\" \"aq ar as at au av\" \"aw ax ay az ba bb\"","rows":"","columns":""},{"areas":"\"a b c d e f g h\" \"i j k l m n o p\" \"q r s t u v w x\" \"y z aa ab ac ad ae af\" \"ag ah ai aj ak al am an\" \"ao ap aq ar as at au av\" \"aw ax ay az ba bb bc bd\"","rows":"","columns":""},{"areas":"\"a b c d e f g\" \"h i j k l m n\" \"o p q r s t u\" \"v w x y z aa ab\" \"ac ad ae af ag ah ai\" \"aj ak al am an ao ap\" \"aq ar as at au av aw\" \"ax ay az ba bb bc bd\"","rows":"","columns":""},{"areas":"\"a b c d e f g h i j\" \"k l m n o p q r s t\" \"u v w x y z aa ab ac ad\" \"ae af ag ah ai aj ak al am an\" \"ao ap aq ar as at au av aw ax\" \"ay az ba bb bc bd be bf bg bh\"","rows":"","columns":""},{"areas":"\"a b c d e f\" \"g h i j k l\" \"m n o p q r\" \"s t u v w x\" \"y z aa ab ac ad\" \"ae af ag ah ai aj\" \"ak al am an ao ap\" \"aq ar as at au av\" \"aw ax ay az ba bb\" \"bc bd be bf bg bh\"","rows":"","columns":""},{"areas":"\"a b c d e f g\" \"h i j k l m n\" \"o p q r s t u\" \"v w x y z aa ab\" \"ac ad ae af ag ah ai\" \"aj ak al am an ao ap\" \"aq ar as at au av aw\" \"ax ay az ba bb bc bd\" \"be bf bg bh bi bj bk\"","rows":"","columns":""},{"areas":"\"a b c d e f g h i\" \"j k l m n o p q r\" \"s t u v w x y z aa\" \"ab ac ad ae af ag ah ai aj\" \"ak al am an ao ap aq ar as\" \"at au av aw ax ay az ba bb\" \"bc bd be bf bg bh bi bj bk\"","rows":"","columns":""},{"areas":"\"a b c d e f g h\" \"i j k l m n o p\" \"q r s t u v w x\" \"y z aa ab ac ad ae af\" \"ag ah ai aj ak al am an\" \"ao ap aq ar as at au av\" \"aw ax ay az ba bb bc bd\" \"be bf bg bh bi bj bk bl\"","rows":"","columns":""},{"areas":"\"a b c d e f g h i j\" \"k l m n o p q r s t\" \"u v w x y z aa ab ac ad\" \"ae af ag ah ai aj ak al am an\" \"ao ap aq ar as at au av aw ax\" \"ay az ba bb bc bd be bf bg bh\" \"bi bj bk bl bm bn bo bp bq br\"","rows":"","columns":""},{"areas":"\"a b c d e f g\" \"h i j k l m n\" \"o p q r s t u\" \"v w x y z aa ab\" \"ac ad ae af ag ah ai\" \"aj ak al am an ao ap\" \"aq ar as at au av aw\" \"ax ay az ba bb bc bd\" \"be bf bg bh bi bj bk\" \"bl bm bn bo bp bq br\"","rows":"","columns":""},{"areas":"\"a b c d e f g h i\" \"j k l m n o p q r\" \"s t u v w x y z aa\" \"ab ac ad ae af ag ah ai aj\" \"ak al am an ao ap aq ar as\" \"at au av aw ax ay az ba bb\" \"bc bd be bf bg bh bi bj bk\" \"bl bm bn bo bp bq br bs bt\"","rows":"","columns":""},{"areas":"\"a b c d e f g h\" \"i j k l m n o p\" \"q r s t u v w x\" \"y z aa ab ac ad ae af\" \"ag ah ai aj ak al am an\" \"ao ap aq ar as at au av\" \"aw ax ay az ba bb bc bd\" \"be bf bg bh bi bj bk bl\" \"bm bn bo bp bq br bs bt\"","rows":"","columns":""},{"areas":"\"a b c d e f g h i j\" \"k l m n o p q r s t\" \"u v w x y z aa ab ac ad\" \"ae af ag ah ai aj ak al am an\" \"ao ap aq ar as at au av aw ax\" \"ay az ba bb bc bd be bf bg bh\" \"bi bj bk bl bm bn bo bp bq br\" \"bs bt bu bv bw bx by bz ca cb\"","rows":"","columns":""},{"areas":"\"a b c d e f g h\" \"i j k l m n o p\" \"q r s t u v w x\" \"y z aa ab ac ad ae af\" \"ag ah ai aj ak al am an\" \"ao ap aq ar as at au av\" \"aw ax ay az ba bb bc bd\" \"be bf bg bh bi bj bk bl\" \"bm bn bo bp bq br bs bt\" \"bu bv bw bx by bz ca cb\"","rows":"","columns":""},{"areas":"\"a b c d e f g h i\" \"j k l m n o p q r\" \"s t u v w x y z aa\" \"ab ac ad ae af ag ah ai aj\" \"ak al am an ao ap aq ar as\" \"at au av aw ax ay az ba bb\" \"bc bd be bf bg bh bi bj bk\" \"bl bm bn bo bp bq br bs bt\" \"bu bv bw bx by bz ca cb cc\"","rows":"","columns":""},{"areas":"\"a b c d e f g h i j\" \"k l m n o p q r s t\" \"u v w x y z aa ab ac ad\" \"ae af ag ah ai aj ak al am an\" \"ao ap aq ar as at au av aw ax\" \"ay az ba bb bc bd be bf bg bh\" \"bi bj bk bl bm bn bo bp bq br\" \"bs bt bu bv bw bx by bz ca cb\" \"cc cd ce cf cg ch ci cj ck cl\"","rows":"","columns":""},{"areas":"\"a b c d e f g h i\" \"j k l m n o p q r\" \"s t u v w x y z aa\" \"ab ac ad ae af ag ah ai aj\" \"ak al am an ao ap aq ar as\" \"at au av aw ax ay az ba bb\" \"bc bd be bf bg bh bi bj bk\" \"bl bm bn bo bp bq br bs bt\" \"bu bv bw bx by bz ca cb cc\" \"cd ce cf cg ch ci cj ck cl\"","rows":"","columns":""},{"areas":"\"a b c d e f g h i j\" \"k l m n o p q r s t\" \"u v w x y z aa ab ac ad\" \"ae af ag ah ai aj ak al am an\" \"ao ap aq ar as at au av aw ax\" \"ay az ba bb bc bd be bf bg bh\" \"bi bj bk bl bm bn bo bp bq br\" \"bs bt bu bv bw bx by bz ca cb\" \"cc cd ce cf cg ch ci cj ck cl\" \"cm cn co cp cq cr cs ct cu cv\"","rows":"","columns":""}];

// Hiển thị các tab trong tab Elements
var tabElementSettings = {
    combination_color: true,
    background_color: true,
    draw:  true,
    shapes: true,
    icons: true,
    flaticon: true,
    storyset: false,
    qrcode: true,
    vcard: true,
    frame: true,
    photoFrame: true,
    imageShape: true,
}

// Settings trong view
var viewSettings = {
    showGrid: false,
    bleedLine: false,
    showDimensions: false,
    showRuler: false,
    snapMode: {status: false, type: 'layer'},
    showWarning: {
        oss: true,
        ilr: true,
    }
}

/* Default Settings */
var defaultSettings = {
    lang_rtl: 'ltr',

    nbdesigner_default_color: '#cc324b',
    nbdesigner_object_center_scaling: 'no',
    nbdesigner_enable_text_free_transform: 'no',
    // Text options
    nbdesigner_text_rotate: 1,
    nbdesigner_text_opacity: 1,
    nbdesigner_text_shadow: 1,
    nbdesigner_text_change_font: 1,
    nbdesigner_text_font_size: 1,
    nbdesigner_text_color: 1,
    nbdesigner_text_align_left: 1,
    nbdesigner_text_align_center: 1,
    nbdesigner_text_align_right: 1,
    nbdesigner_text_case: 1,
    nbdesigner_text_bold: 1,
    nbdesigner_text_italic: 1,
    nbdesigner_text_spacing: 1,
    nbdesigner_text_line_height: 1,
    nbdesigner_text_outline: 1,
    nbdesigner_text_background: 1,
    nbdesigner_default_text: 'Text here',

    nbdesigner_show_all_color: 'yes',
    nbdesigner_enable_eyedropper: 'yes',
    nbdesigner_show_design_border: 'yes',
    nbdesigner_show_layer_size: 'yes',
    // tabs
    nbdesigner_enable_text: 'yes',
    nbdesigner_enable_curvedtext: 'yes',
    nbdesigner_enable_clipart: 'yes',
    nbdesigner_enable_image: 'yes',
    nbdesigner_enable_upload_image: 'yes',
    nbdesigner_enable_image_url: 'yes',
    nbdesigner_enable_pixabay: 'no',
    nbdesigner_enable_unsplash: 'no',
    nbdesigner_enable_pexels: 'no',
    nbdesigner_upload_show_term: 'no',
    nbdesigner_upload_multiple_images: 'yes',
    nbdesigner_enable_svg_code: 'yes',
    nbdesigner_hide_typo_section: 'no',
    nbdesigner_max_upload_files_at_once: 10,

    ui_mode: 1,
    task: 'new',
    is_mobile: checkMobileDevice(),
    is_logged: 1,
    showRuler: false,
    // Clipart options
    nbdesigner_clipart_rotate:1,
    nbdesigner_clipart_opacity:1,
    folder_font: 'https://fonts.gstatic.com/s/roboto/v18/',
    nbdesigner_enable_cloud2print_api: 'yes',
    nbdesigner_enable_font_to_outlines: 'no',
    nbdesigner_clipart_change_path_color: 1,
    nbdesigner_enable_template_mapping: 'yes',
    nbdesigner_cache_uploaded_image: 'yes',
    nbdesigner_auto_fill_template_masks: 'yes',
    nbdesigner_limit_photo_by_masks: 'no',
    nbdesigner_dimensions_unit: 'cm',
    nbdesigner_prevent_add_more_layer: 'no',
    nbdesigner_enable_text_check_lang: 'no',
    nbdesigner_prevent_delete_template_layer: 'no',
    nbdesigner_save_latest_design: 'no',
    nbdesigner_always_show_layer_action: 'no',
    nbdesigner_boosting_load_template: 'no',
    template_fields: [],
    vcard_fields: [],
    nbes_settings: {
        "force_fg": "0",
        "td_preview": "0",
        "td_folder_name": "",
        "td_custom_mesh_name": "custom",
        "sticker_preview": "0"
    },
    nbes_enable_settings: {
        "clipart": "0",
        "font": "0",
        "background": "0",
        "foreground": "0",
        "combination": "0"
    },
    // Langs
    nbdlangs: {
        "cliparts": "Cliparts",
        "alert_upload_term": "Please accept the upload term conditions",
        "path": "Vector",
        "image": "Image",
        "rect": "Rectangle",
        "triangle": "Triangle",
        "line": "Line",
        "polygon": "Polygon",
        "circle": "Circle",
        "ellipse": "Ellipse",
        "group": "Group",
        "pro_license_alert": "This item is not available in Lite version!",
        "confirm_delete_design": "Do you want to delete this design?",
        "my_design": "My design",
        "cover": "Cover",
        "front_cover": "Front cover",
        "back_cover": "Back cover",
        "page": "Page",
        "pages": "Pages",
        "image-layer": "Group",
        "mask": "Mask",
        "iosPlaceholderText": "Click here to open camera.",
        "templates": "Templates",
        "supported_extensions": "Supported extensions: PNG, JPE, JPEG, SVG",
        "supported_extensions2": "Supported extensions: PNG, JPE, JPEG, SVG, PDF",
        "min_file_size": "Min file size: ",
        "max_file_size": "Max file size: ",
        "wrong_to_convert_outline_font": "Wrong to convert font to outlines!"
    },
    // Subset
    subsets: {
        "all": {
            "name": "All language",
            "preview_text": "Abc Xyz",
            "default_font": "Roboto"
        },
        "arabic": {
            "name": "Arabic",
            "preview_text": "ءيوهن",
            "default_font": "Cairo"
        },
        "bengali": {
            "name": "Bengali",
            "preview_text": "অআইঈউ",
            "default_font": "Hind Siliguri"
        },
        "cyrillic": {
            "name": "Cyrillic",
            "preview_text": "БВГҐД",
            "default_font": "Roboto"
        },
        "cyrillic-ext": {
            "name": "Cyrillic Extended",
            "preview_text": "БВГҐД",
            "default_font": "Roboto"
        },
        "chinese-simplified": {
            "name": "Chinese (Simplified)",
            "preview_text": "一二三四五",
            "default_font": "ZCOOL XiaoWei"
        },
        "devanagari": {
            "name": "Devanagari",
            "preview_text": "आईऊऋॠ",
            "default_font": "Noto Sans"
        },
        "greek": {
            "name": "Greek",
            "preview_text": "αβγδε",
            "default_font": "Roboto"
        },
        "greek-ext": {
            "name": "Greek Extended",
            "preview_text": "αβγδε",
            "default_font": "Roboto"
        },
        "gujarati": {
            "name": "Gujarati",
            "preview_text": "આઇઈઉઊ",
            "default_font": "Shrikhand"
        },
        "gurmukhi": {
            "name": "Gurmukhi",
            "preview_text": "ਆਈਊਏਐ",
            "default_font": "Baloo Paaji"
        },
        "hebrew": {
            "name": "Hebrew",
            "preview_text": "אבגדה",
            "default_font": "Arimo"
        },
        "japanese": {
            "name": "Japanese",
            "preview_text": "一二三四五",
            "default_font": "Sawarabi Mincho"
        },
        "kannada": {
            "name": "Kannada",
            "preview_text": "ಅಆಇಈಉ",
            "default_font": "Baloo Tamma"
        },
        "khmer": {
            "name": "Khmer",
            "preview_text": "កខគឃង",
            "default_font": "Hanuman"
        },
        "korean": {
            "name": "Korean",
            "preview_text": "가개갸거게",
            "default_font": "Nanum Gothic"
        },
        "latin": {
            "name": "Latin",
            "preview_text": "Abc Xyz",
            "default_font": "Roboto"
        },
        "latin-ext": {
            "name": "Latin Extended",
            "preview_text": "Abc Xyz",
            "default_font": "Roboto"
        },
        "malayalam": {
            "name": "Malayalam",
            "preview_text": "അആഇഈഉ",
            "default_font": "Baloo Chettan"
        },
        "myanmar": {
            "name": "Myanmar",
            "preview_text": "ကခဂဃင",
            "default_font": "Padauk"
        },
        "oriya": {
            "name": "Oriya",
            "preview_text": "ଅଆଇଈଉ",
            "default_font": "Baloo Bhaina"
        },
        "sinhala": {
            "name": "Sinhala",
            "preview_text": "අආඇඈඉ",
            "default_font": "Abhaya Libre"
        },
        "tamil": {
            "name": "Tamil",
            "preview_text": "க்ங்ச்ஞ்ட்",
            "default_font": "Catamaran"
        },
        "telugu": {
            "name": "Telugu",
            "preview_text": "అఆఇఈఉ",
            "default_font": "Gurajada"
        },
        "thai": {
            "name": "Thai",
            "preview_text": "กขคฆง",
            "default_font": "Kanit"
        },
        "vietnamese": {
            "name": "Vietnamese",
            "preview_text": "Abc Xyz",
            "default_font": "Roboto"
        }
    },

}

// Font default
var fontDefaultSettings = {
    alias: "Roboto",
    cat: ['99'],
    file: {
        r: 'https://fonts.gstatic.com/s/roboto/v18/KFOmCnqEu92Fr1Me5Q.ttf',
        i: 'https://fonts.gstatic.com/s/roboto/v18/KFOkCnqEu92Fr1Mu52xP.ttf',
        b: 'https://fonts.gstatic.com/s/roboto/v18/KFOlCnqEu92Fr1MmWUlvAw.ttf',
        bi: 'https://fonts.gstatic.com/s/roboto/v18/KFOjCnqEu92Fr1Mu51TzBhc9.ttf'
    },
    id: 'cac18776-c761-4912-a025-6742ce84430f',
    name: "Roboto",
    subset: "latin",
    type: "google",
}

// settings mặc định của Site
var printcart_default_settings = {
    color: '#cc324b',
    fontSizes: ['6','8','10','12','14','16','18','21','24','28','32','36','42','48','56','64','72','80','88','96','104','120','144','288','576','1152'],
    defaultPalette: [
        ['#ff5c5c', '#ffbd4a', '#fff952', '#99e265', '#35b729', '#44d9e6', '#2eb2ff', '#5271ff', '#b760e6', '#ff63b1'],
        ['#000000', '#666666', '#a8a8a8', '#d9d9d9', '#ffffff']
    ],
}

function arrayMin(arr) {
    return arr.reduce(function (p, v) {
        p *= 1;
        v *= 1;
        return (p < v ? p : v);
    });
};
function arrayMax(arr) {
    return arr.reduce(function (p, v) {
        p *= 1;
        v *= 1;
        return (p > v ? p : v);
    });
};
var  nbdApp = angular.module('nbd-app', dependModules);
nbdApp.constant("_", window._);
nbdApp.config(function( $controllerProvider, $compileProvider, $filterProvider ){
    nbdApp.controller = function( name, constructor ) {
        $controllerProvider.register( name, constructor );
        $compileProvider.imgSrcSanitizationWhitelist(/^\s*(https?|ftp|file|blob):|data:image\//);
        return( this );
    };
    nbdApp.directive = function( name, factory ) {
        $compileProvider.directive( name, factory );
        return( this );
    };
    nbdApp.filter = function( name, filter ) {
        $filterProvider.register( name, filter );
        return( this );
    };
});
nbdApp.config([
    '$compileProvider', function( $compileProvider ){
        $compileProvider.imgSrcSanitizationWhitelist(/^\s*(https?|ftp|file|blob):|data:image\/|data:img\//);
    }
]);
nbdApp.controller('designCtrl', ['$scope', 'FabricWindow', 'NBDDataFactory', 'filterFontFilter', 'filterArtFilter', '$window', '$timeout', '$http', '$document', '$interval',
    function($scope, FabricWindow, NBDDataFactory, filterFontFilter, filterArtFilter, $window, $timeout, $http, $document, $interval){
        Promise.all([getFonts(), getFontDefault(), getSideByProduct(), getSideById(), getDesignLayerById(), getProductDetails(), getStores()])
        .then( function(results) {
            var checkLoadPage = true;
            if(results[0].status === 200 && results[1].status === 200 ) {
                myFonts = results[0].data;
                defaultFonts = results[1].data;
                if( !side_id && !template_id && angular.isDefined(results[2]) && angular.isDefined(results[5]) && results[2].status === 200 && results[5].status === 200 ) {
                    productSides = results[2].data.data;
                    productSettings = results[5].data.data;
                } 
                if( side_id && task == 'create_template' ) {
                    if( angular.isDefined(results[3]) && results[3].status === 200 && angular.isDefined(results[3].data.data.product)) {
                        productSides = [];
                        productSides.push(results[3].data.data);
                        productSettings = results[3].data.data.product;
                    }
                    if(template_id) {
                        if( angular.isDefined(results[4]) && results[4].status === 200 ) {
                            dataDesignLayers = {
                                layers: results[4].data.data.layers,
                                viewport: results[4].data.data.viewport,
                            }
                        }
                    }
                }
                if( ( template_id && task == 'edit_template') || ( design_id && task == 'edit') ) {
                    if( angular.isDefined(results[4]) && results[4].status === 200 && angular.isDefined(results[4].data.data.product)) {
                        productSides = [];
                        productSides.push(results[4].data.data.side);
                        productSettings = results[4].data.data.product;
                        dataDesignLayers = {
                            layers: results[4].data.data.layers,
                            viewport: results[4].data.data.viewport,
                        }
                    }
                }
                if( angular.isDefined(results[6]) && results[6].status === 200 ) {
                    var dataStore = results[6].data.data;
                    if(dataStore) {
                        if(dataStore.pixabay_key) {
                            defaultSettings.nbdesigner_enable_pixabay  = "yes";
                            defaultSettings.nbdesigner_pixabay_api_key  = dataStore.pixabay_key;
                        }
                        if(dataStore.unsplash_key) {
                            defaultSettings.nbdesigner_enable_unsplash  = "yes";
                            defaultSettings.nbdesigner_unsplash_api_key  = dataStore.unsplash_key;
                        }
                        if(dataStore.pexels_key) {
                            defaultSettings.nbdesigner_enable_pexels  = "yes";
                            defaultSettings.nbdesigner_pexels_api_key  = dataStore.pexels_key;
                        }
                    }
                } 

                if( !productSides || !productSettings ) checkLoadPage = false;
                
            } else {
                checkLoadPage = false;
            }
            if(!checkLoadPage) {
                alert('Error load page');
                return;
            }
            $scope.loadedPage();
        });
        $scope.loadedPage = () => {
            $scope.stages = [];
            var d = new Date(),
            t = d.getTime();
            $scope.defaultStageStates = {
                isActiveLayer: false,
                isLayer: false,
                isGroup: false,
                isNativeGroup: false,
                isText: false,
                isImage: false,
                isPath: false,
                isShape: false,
                isEditing: false,
                isRedoable: false,
                isUndoable: false,
                elementUpload: false,
                isShowToolBox: false,
                enableRotate: true,
                enableOpacity: true,
                enableShadow: true,
                enableChangePathColor: true,
                oos: false,
                ilr: false,
                boundingObject: {},
                corners: [],
                boundingRealSize: {},
                coordinates: { lastCheck: t },
                rotate: {},
                uploadZone: {},
                opacity: 100,
                snaplines: {},
                itemId: null,
                tempParameters: null,
                usedFonts: [],
                type: null,
                text: {
                    fontFamily: {
                        alias: fontDefaultSettings.alias,
                        r: fontDefaultSettings.file.r,
                        b: fontDefaultSettings.file.b,
                        i: fontDefaultSettings.file.i,
                        bi: fontDefaultSettings.file.bi
                    },
                    fontSize: 14,
                    fontFamily: fontDefaultSettings.alias,
                    textAlign: 'left',
                    fontWeight: false,
                    textDecoration: false,
                    fontStyle: '',
                    spacing: 0,
                    lineHeight: 1.16,
                    is_uppercase: false,
                    fill: '#06d79c'
                }, 
                svg: {groupPath: {}, currentPath: null},
                image: {},
                scaleRange: [],
                currentScaleIndex: 0,
                fitScaleIndex: 0,
                fillScaleIndex: 0,
                lostCharLayers: [],
                shadow: {
                    color: printcart_default_settings.color,
                    offsetX: 0,
                    offsetY: 0,
                    blur: 10,
                    opacity: 0.75
                }
            };
            $scope.preventLoadDesign = false;
            $scope.globalPicker = {
                color: printcart_default_settings.color,
                attr: 'text.stroke',
                active: false
            };

            viewSettings.showGrid = angular.isDefined(customSettings) && angular.isDefined(customSettings.showGrid) ? customSettings.showGrid : viewSettings.showGrid;
            viewSettings.bleedLine = angular.isDefined(customSettings) && angular.isDefined(customSettings.showBleedLine) ? customSettings.showBleedLine : viewSettings.bleedLine;
            viewSettings.showDimensions = angular.isDefined(customSettings) && angular.isDefined(customSettings.showDimensions) ? customSettings.showDimensions : viewSettings.showDimensions;
            viewSettings.showRuler = angular.isDefined(customSettings) && angular.isDefined(customSettings.showRuler) ? customSettings.showRuler : viewSettings.showRuler;

            $scope.init();  
        }
        $scope.init = function() {
            $scope.localStore.init();
            $scope.initSettings();

            // Fix lỗi không nhận các thư viện Scroll, Color pick
            jQuery('.nbd-load-page').hide();
            $timeout(function(){
                window.initModernLayout();
            });
            $scope.contextAddLayers = 'normal';
            var _window = angular.element($window);
            _window.bind('resize', function(){
                /* to do: resize design */
            });
            $scope.fullScreenMode = false;
            var _document = angular.element($document);
            _document.bind('webkitfullscreenchange mozfullscreenchange fullscreenchange MSFullscreenChange', function(){
                $scope.fullScreenMode = !$scope.fullScreenMode;
                jQuery("body").toggleClass("fullScreenMode");
                $timeout(function(){
                    $scope.toggleStageFullScreenMode();
                });
            }); 

            $scope.customSettings = customSettings;
        };
        $scope.formatFont = function(font , reverse = false) {
            if(angular.isUndefined(font)) return;
            if(angular.isDefined(font.url)) reverse = false;
            if(reverse) {
                return {
                    alias: font.alias,
                    url: font.file.r,
                    id: font.id,
                    name: font.name,
                    subset: font.subset,
                    type: font.type,
                };
            } else {
                return {
                    alias: font.alias,
                    file: {
                        r: font.url,
                    },
                    id: font.id,
                    name: font.name,
                    subset: font.subset,
                    type: font.type,
                };
            }
        }
        $scope.formatSideData = function(data) {
            var sides = [];
            angular.forEach(data, function(value, key) {
                var scale = value.scale ? value.scale : 1;
                var bleed_top_bottom =  value.cut_line_margin && value.cut_line_margin.y ? value.cut_line_margin.y : 0;
                var bleed_left_right = value.cut_line_margin && value.cut_line_margin.x ? value.cut_line_margin.x : 0;
                var side = {
                    id: value.id ? value.id : 0,
                    orientation_name: value.name ? value.name : '',
                    img_src: value.side_image && value.side_image.url ? value.side_image.url : '',
                    img_overlay: value.img_overlay ? value.img_overlay.url : '',
                    version: value.version ? value.version : '',
                    ratio: scale,
                    bg_type: value.bg_type ? value.bg_type : 'image',
                    bg_color_value: value.bg_color_value ? value.bg_color_value : '',
                    include_background: value.background_included ? 1 : 0,
                    show_overlay: value.show_overlay ? 1 : 0,
                    include_overlay: value.include_overlay ? 1 : 0,
                    product_width: value.side_image_size && value.side_image_size.width ? value.side_image_size.width : 0,
                    product_height: value.side_image_size && value.side_image_size.height ? value.side_image_size.height : 0,
                    real_width: value.design_area && value.design_area.width ? value.design_area.width : 0,
                    real_height: value.design_area && value.design_area.height ? value.design_area.height : 0,
                    real_top: value.design_area && value.design_area.top ? value.design_area.top : 0,
                    real_left: value.design_area && value.design_area.left ? value.design_area.left : 0,
                    area_design_width: value.design_area && value.design_area.width ? parseFloat( value.design_area.width ) * scale : 0,
                    area_design_height: value.design_area && value.design_area.height ? parseFloat( value.design_area.height ) * scale : 0,
                    area_design_left: value.design_area && value.design_area.left ? parseFloat( value.design_area.left ) * scale : 0,
                    area_design_top: value.design_area && value.design_area.top ? parseFloat( value.design_area.top ) * scale : 0,
                    show_bleed: value.show_cut_line ? 1 : 0,
                    bleed_top_bottom: bleed_top_bottom,
                    bleed_left_right: bleed_left_right,
                    show_safe_zone: value.show_safe_zone ? 1 : 0,
                    margin_top_bottom: value.safe_zone_margin && value.safe_zone_margin.y ? value.safe_zone_margin.y - bleed_top_bottom : 0,
                    margin_left_right: value.safe_zone_margin && value.safe_zone_margin.x ? value.safe_zone_margin.x - bleed_left_right : 0,
                };
                sides.push(side);
            })
            return sides;
        }
        $scope.initSettings = function() {
            $scope.settings = {};
            $scope.currentStage = 0;
            $scope.showTextColorPicker = false;
            $scope.the_first_time_load_page = true;
            $scope.currentColor = printcart_default_settings.color;
            $scope.listAddedColor = [];
            $scope.tempStageDesign = null;
            $scope.areaDesignClipPaths = [];
            $scope.areaDesignZoomedClipPaths = [];
            $scope.areaDesignShapes = [];
            $scope.forceMinSize = true;
            $scope.forceMaxSize = true;
            /* Insert Tempate by side id*/
            $scope.currentSideId = '';
            if(productSides && angular.isDefined(productSides[0])) {
                $scope.currentSideId = productSides[0].id;
            }
            $scope.has_template = is_template ? true: false;
            $scope.listFontSizeInPt = printcart_default_settings.fontSizes;
            angular.copy(defaultSettings, $scope.settings);
            angular.extend($scope.settings, viewSettings);
            if(angular.isUndefined($scope.settings.product_data)) {
                $scope.settings.product_data = {};
            }
            $scope.settings.product_data.product = $scope.formatSideData(productSides);
            $scope.settings.product_data.option = productSettings;
            $scope.settings.product_data.option.allowed_file_types_show = angular.isDefined(productSettings) && productSettings.allowed_file_types ? productSettings.allowed_file_types.toString() : '';
            $scope.settings.nbdesigner_dimensions_unit = productSettings.dimension_unit ? productSettings.dimension_unit : 'cm';
            $scope.rateConvertCm2Px96dpi = 37.795275591;
            $scope.completedInsertTemplate = false;
            $scope.processProductSettings();
            $scope.resource = {
                defaultPalette: printcart_default_settings.defaultPalette,
                gapi: {},
                jsonDesign: {},
                config: {qty: 1},
                canAdd: true,
                usedFonts: [],
                qrText: '',
                personal: {status: false, type: ''},
                products: {data: [], filtereProducts: [], perPage: 10, currentPage:1, total: 0, onload: false, init: true, nextPage: ''},
                typography: {filter: {perPage: 20, currentPage: 1, total: 0}, data: [], init: true, onload: false},
                clipart: {filter: {perPage: 20, currentPage: 1, total: 0, currentCat: {}, changeFilter: false}, data: [], onload: false, init: true, filteredArts : [], nextPage: {}},
                myClipart: {filter: {perPage: 20, currentPage: 1, total: 0, currentCat: {}, changeFilter: false}, data: [], onload: false, init: true, filteredArts : [], nextPage: {}},
                templates: { data: [], next: '', perPage: 10, currentPage:1, total: 0, onload: false, init: true},
                photo: {filter: {perPage: 20, currentPage: 1, total: 0, totalPage: 1}, data: [], init: true, onload: false, type: '', photoSearch: '', onclick: false},
                upload: {filter: {perPage: 10, currentPage: 1, total: 0}, data: [], onload: false, init: true, ilr: false, progressBar: 0},
                drawMode: {status: false, brushWidth: 1, brushType: 'Pencil', brushColor: printcart_default_settings.color},
                font: {filter: {perPage: font_perpage, currentPage: 1, total: 0}, data: [], filteredFonts : [], init: true, onload: false, nextPage: ''},
                myFont: {filter: {perPage: font_perpage, currentPage: 1, total: 0}, data: [], filteredFonts : [], init: true, onload: false, nextPage: ''},
                tempData: {template: []},
                element: {onclick: false, onload: false, contentSearch: ''},
                shape: {filter: {perPage: 20, currentPage: 1, totalPage: 0}, data: [], init: true, onload: false},
                icon: {filter: {perPage: 20, currentPage: 1, totalPage: 0, currentCat: null}, data: [], cat: [], init: true, onload: false, first: true},
                flaticon: {filter: {perPage: 20, currentPage: 1, totalPage: 0}, data: [], init: true, onload: false, token: '', expires: ''},
                storyset: {filter: {perPage: 30, currentPage: 1, totalPage: 0}, data: [], init: true, onload: false},
                photoFrame: {filter: {perPage: 20, currentPage: 0, total: 161}, data: [], init: true, onload: false},
                frames: photoFrames.slice(0, 200),
                shareDesign: false,
            };
            if(defaultFonts) {
                // Update default fonts
                var _defaultFonts = [];
                angular.forEach(defaultFonts.data, function(font, key) {
                    var _font = $scope.formatFont(font);
                    _defaultFonts.push(_font);
                }) 
                // insert font default display
                if(angular.isDefined(defaultFonts.data[0])) {
                    fontDefaultSettings = $scope.formatFont(defaultFonts.data[0]);
                }
                $scope.resource.font.data = _defaultFonts;
                $scope.resource.font.nextPage = defaultFonts.links.next ? defaultFonts.links.next : '';
                $scope.resource.font.filter.total = _defaultFonts.length;
            }
            if(myFonts) {
                // Update my fonts
                var _myFonts = [];
                angular.forEach(myFonts.data, function(font, key) {
                    var _font = $scope.formatFont(font);
                    _myFonts.push(_font);
                }) 
                // insert font default display
                $scope.resource.myFont.data = _myFonts;
                $scope.resource.myFont.nextPage = myFonts.links.next ? myFonts.links.next : '';
                $scope.resource.myFont.filter.total = _myFonts.length;
            }
            // set task
            $scope.settings.task = task;
            $scope.settings.is_admin = is_admin ? is_admin : '';
            $scope.settings.elements = tabElementSettings;
            $scope.settings.assets_url = urlCloudFront;
            $scope.settings.dynamicStage = ( angular.isDefined( productSettings.dynamic_side ) && productSettings.dynamic_side ) ? true : false;
            // disabled dynamic side
            $scope.settings.dynamicStage = false;
            $scope.includeExport = ['objectCaching', 'itemId', 'selectable', 'editable', 'lockMovementX', 'lockMovementY','lockScalingX', 'lockScalingY', 'lockRotation',
            'rtl', 'elementUpload', 'forceLock', 'isBg', 'isBgImg','is_uppercase','available_color','available_color_list','color_link_group','isOverlay', 'isAlwaysOnTop',
            'ilr', 'oos', 'evented', 'ptFontSize', 'font', 'origin_src', 'reverse', 'spacing', 'radius', 'field_mapping', 'isQrcode', 'qrContent', 'isBarcode', 'barCodeContent',
            'v_card', 'isMask', 'maskId', 'strokeWidth', 'absolutePositioned', 'perPixelTargetFind', 'centeredScaling', 'origin_url', 'origin_width', 'origin_height',
            'cropped', 'layerName', 'origin_pdf', 'isTemMask', 'srcChanged', 'isEmptyMask', 'lockMask'];

            // $scope.getResource('typography', '#tab-typography');
            // $scope.getTemplates(); // get Templates first load.
            // if(side_id && (task == "create_template" || task == "edit_template")) {
                // $scope.getTemplatesBySide(); // get Templates first load.
                $scope.getProducts(); // get Products first load.
            // }
            

            $scope.$watchCollection('resource.font.filter', function(newVal, oldVal){
                if(newVal.search != oldVal.search){
                    $timeout(function() {
                        jQuery("#toolbar-font-familly-dropdown").stop().animate({
                            scrollTop: 0
                        }, 100);
                    });
                }
                $scope.resource.font.filteredFonts = filterFontFilter($scope.resource.font.data, $scope.resource.font.filter);
            }, true);

            $scope.$watchCollection('resource.myFont.filter', function(newVal, oldVal){
                if(newVal.search != oldVal.search){
                    $timeout(function() {
                        jQuery("#toolbar-font-familly-dropdown").stop().animate({
                            scrollTop: 0
                        }, 100);
                    });
                }
                $scope.resource.myFont.filteredFonts = filterFontFilter($scope.resource.myFont.data, $scope.resource.myFont.filter);
            }, true);

            $scope.$watchCollection('resource.clipart.filter', function(newVal, oldVal){
                if(angular.isUndefined($scope.resource.clipart.data.cat_data)) $scope.resource.clipart.data.cat_data = [];
                var _currentCat = $scope.resource.clipart.filter.currentCat.id ? $scope.resource.clipart.filter.currentCat.id : 'all';
                $scope.resource.clipart.filteredArts = [];
                if(angular.isDefined($scope.resource.clipart.data.cat_data[_currentCat])) {
                    $scope.resource.clipart.filteredArts = filterArtFilter($scope.resource.clipart.data.cat_data[_currentCat], $scope.resource.clipart.filter);
                }
                if(newVal.search != oldVal.search){
                    $timeout(function() {
                        jQuery("#tab-svg .tab-scroll").stop().animate({
                            scrollTop: 0
                        }, 100);
                        $scope.updateApp();
                    });
                }
                $scope.onEndRepeat('clipart');
            }, true);
            $scope.$watchCollection('resource.myClipart.filter', function(newVal, oldVal){
                if(angular.isUndefined($scope.resource.myClipart.data.cat_data)) $scope.resource.myClipart.data.cat_data = [];
                var _currentCat = $scope.resource.myClipart.filter.currentCat.id ? $scope.resource.myClipart.filter.currentCat.id : 'all';
                $scope.resource.myClipart.filteredArts = [];
                if(angular.isDefined($scope.resource.myClipart.data.cat_data[_currentCat])) {
                    $scope.resource.myClipart.filteredArts = filterArtFilter($scope.resource.myClipart.data.cat_data[_currentCat], $scope.resource.myClipart.filter);
                }
                if(newVal.search != oldVal.search){
                    $timeout(function() {
                        jQuery("#tab-svg .tab-scroll").stop().animate({
                            scrollTop: 0
                        }, 100);
                        $scope.updateApp();
                    });
                }
                $scope.onEndRepeat('myClipart');
            }, true);
            $scope.settings.canSwapStage = true;
            $scope.availableFilters = ['blur', 'desaturate', 'contrast', 'sepiatone', 'hue', 'luminance', 'colorize', 'posterize', 'darken', 'lighten', 'invert'];
            $scope.settings.enableImageFilter = true;
        };
        $scope.currentFont = 'font';
        $scope.changeCurrentFont = function(type) {
            $scope.currentFont = type;
        }
        $scope.currentClipart = 'clipart';
        $scope.firstLoadMyClipart = true;
        $scope.changeCurrentClipart = function(type) {
            $scope.currentClipart = type;
            $scope.renderMasonryList('clipart', '#tab-svg .clipart-wrap', '.clipart-item', '#tab-svg', type == 'clipart' ? $scope.resource.clipart.init : $scope.resource.myClipart.init);
            if(type === 'custom-clipart' && $scope.firstLoadMyClipart) {
                $scope.getResource('myClipart', '#tab-svg', true);
                $scope.firstLoadMyClipart = false;
            }
        }

        $scope.getTemplates = function(first = true) {
            if( angular.isDefined($scope.resource.templates.catData['myTemplates'])) return;
            if(!first) {
                $scope.changeCatTemp($scope.resource.templates.cat[0]);
                return;
            }
            $scope.resource.templates.onload = true;
            var container = '#tab-product-template';
            jQuery(container + ' .loading-photo').show();
            var url = apiPre + 'template-category';
            var headers = apiAuthBearer;
            headers['Content-Type'] = undefined;
            $http({
                method: "GET",
                url: url,
                headers: headers,
            }).then(function successCallback(response){
                var _data = response.data;
                if(angular.isDefined(_data.data)) {
                    var cat = [{id: 'myTemplates', name: "My templates"}].concat(_data.data);
                    $scope.resource.templates.cat = cat;
                    $scope.changeCatTemp($scope.resource.templates.cat[0]);
                    $scope.updateApp();
                } else {
                    jQuery(container + ' .loading-photo').hide();
                }
            }, function errorCallback(response) {
                jQuery(container + ' .loading-photo').hide();
                console.log('Fail to load templates!');
            });
        }

        /*Get templates by side*/
        $scope.getTemplatesBySide = function(sideId = '') {
            if($scope.resource.templates.onload) return;
            $scope.resource.templates.onload = true;
            if(!is_admin) {
                if(!$scope.currentSideId || $scope.currentSideId == sideId) return;

                if( sideId != '' && $scope.currentSideId != sideId ) {
                    $scope.currentSideId = sideId;
                }
            }

            $scope.resource.templates.filtereTemps = [];

            jQuery("#tab-product-template .tab-scroll").stop().animate({
                scrollTop: 0
            }, 100);

            if($scope.resource.templates.data.length > 0) {
                $scope.resource.templates.currentPage = 1;
                $scope.resource.templates.filtereTemps = $scope.resource.templates.data.slice(0, $scope.resource.templates.perPage);
                $scope.updateApp();
            } else {
                var container = '#tab-product-template';
                jQuery(container + ' .loading-photo').show();
                var url = apiPre + 'sides/' + $scope.currentSideId + '/templates?limit=' + $scope.resource.templates.perPage;
                if(is_admin) {
                    url = apiPre + 'templates/template-default?limit=' + $scope.resource.templates.perPage;
                }
                var headers = apiAuthBearer;
                $http({
                    method: "GET",
                    url: url,
                    headers: headers,
                }).then(function successCallback(response){
                    var _data = response.data;
                    $scope.resource.templates.onload = false;
                    $scope.resource.templates.data = _data.data;
                    $scope.resource.templates.filtereTemps = _data.data;
                    $scope.resource.templates.total = _data.data.length;
                    if(angular.isDefined(_data.links.next)) {
                        $scope.resource.templates.next = _data.links.next;
                    }
                    jQuery(container + ' .loading-photo').hide();
                }, function errorCallback(response) {
                    jQuery(container + ' .loading-photo').hide();
                    console.log('Fail to load templates!');
                });
            }
        }
        $scope.getProducts = function(){
            $scope.resource.products.filtereTemps = [];

            jQuery("#tab-product .tab-scroll").stop().animate({
                scrollTop: 0
            }, 100);

            if($scope.resource.products.data.length > 0) {
                $scope.resource.products.currentPage = 1;
                $scope.resource.products.filtereProducts = $scope.resource.products.data.slice(0, $scope.resource.products.perPage);
                $scope.updateApp();
            } else {
                $scope.resource.products.onload = true;
                var container = '#tab-product';
                jQuery(container + ' .loading-photo').show();
                var url = apiPre + 'products?limit=' + $scope.resource.products.perPage;
                var headers = apiAuthBearer;
                headers['Content-Type'] = undefined;
                $http({
                    method: "GET",
                    url: url,
                    headers: headers,
                }).then(function successCallback(response){
                    var _data = response.data;
                    if(angular.isDefined(_data.data)) {
                        $scope.resource.products.data = _data.data;
                        $scope.resource.products.filtereProducts = _data.data;
                        $scope.resource.products.total = _data.data.length;
                        $scope.resource.products.onload = false;
                        if(angular.isDefined(_data.links.next)) {
                            $scope.resource.products.next = _data.links.next;
                        }
                        $scope.updateApp();
                    }
                    jQuery(container + ' .loading-photo').hide();
                }, function errorCallback(response) {
                    jQuery(container + ' .loading-photo').hide();
                    console.log('Fail to load templates!');
                });
            }
        };
        $scope.scrollLoadMoreProduct = function() {
            var currentPage = $scope.resource.products.currentPage;

            if( $scope.resource.products.onload ) return;

            if( currentPage * $scope.resource.products.perPage >= $scope.resource.products.total ) {
                if($scope.resource.products.next) {
                    $scope.resource.products.onload = true;
                    jQuery('#tab-product').addClass('nbd-onload');
                    jQuery('#tab-product .loading-photo').show();
                    var url = $scope.resource.products.next + '&limit=' + $scope.resource.products.perPage;
                    var headers = apiAuthBearer;
                    headers['Content-Type'] = undefined;
                    $http({
                        method: "GET",
                        url: url,
                        headers: headers,
                    }).then(function successCallback(response){
                        if(response.status != 200 || angular.isUndefined(response.data.data) ) { 
                            jQuery('#tab-product .loading-photo').hide();
                            jQuery('#tab-product').removeClass('nbd-onload');
                            return;
                        }
                        $scope.resource.products.currentPage = currentPage + 1;
                        $scope.resource.products.data = $scope.resource.products.data.concat(response.data.data);
                        $scope.resource.products.total += response.data.data.length;
                        $scope.resource.products.next = response.data.links.next;
                        $scope.resource.products.filtereProducts = $scope.resource.products.data;
                        $scope.updateApp();
                        $scope.resource.products.onload = false;      
                        jQuery('#tab-product .loading-photo').hide();
                        jQuery('#tab-product').removeClass('nbd-onload');
                    });
                } 
            } else {
                $scope.resource.products.currentPage = currentPage + 1;
                var dataNext = $scope.resource.products.data.slice( currentPage * $scope.resource.products.perPage , (currentPage + 1) * $scope.resource.products.perPage);
                $scope.resource.products.filtereProducts = $scope.resource.products.filtereProducts.concat(dataNext);
                $scope.updateApp();
                $scope.resource.products.onload = false;    
                jQuery('#tab-product .loading-photo').hide();
                jQuery('#tab-product').removeClass('nbd-onload'); 
            }
        }
        $scope.changeCatTemp = function(cat) {
            if(angular.isUndefined(cat.id)) return;
            $scope.resource.templates.currentCat = cat;
            $scope.resource.templates.filtereTemps = [];
            jQuery("#tab-product-template .tab-scroll").stop().animate({
                scrollTop: 0
            }, 100);
            if(cat.id == 'myTemplates') {
                $scope.resource.templates.onload = false;
                jQuery('#tab-product-template .loading-photo').hide();
                jQuery('#tab-product-template').removeClass('nbd-onload');
            } else {
                if(angular.isUndefined($scope.resource.templates.catData[cat.id]) ) {
                    $scope.resource.templates.onload = true;
                    jQuery('#tab-product-template').addClass('nbd-onload');
                    jQuery('#tab-product-template .loading-photo').show();
                    var url = apiPre + 'template-category/' + cat.id + '/templates?limit=' + $scope.resource.templates.perPage;
                    var headers = apiAuthBearer;
                    headers['Content-Type'] = undefined;
                    $http({
                        method: "GET",
                        headers: headers,
                        url: url,
                    }).then(function successCallback(response){
                        if(response.status != 200 || angular.isUndefined(response.data.data) ) { 
                            jQuery('#tab-product-template .loading-photo').hide();
                            jQuery('#tab-product-template').removeClass('nbd-onload');
                            return;
                        }
                        $scope.resource.templates.catData[cat.id] = {
                            data: response.data.data,
                            total: response.data.data.length,
                            next: response.data.links.next,
                            currentPage: 1,
                        }
                        $scope.resource.templates.filtereTemps = response.data.data;
                        $scope.updateApp();
                        $scope.resource.templates.onload = false;
                        jQuery('#tab-product-template .loading-photo').hide();
                        jQuery('#tab-product-template').removeClass('nbd-onload');
                    });
                } else {
                    $scope.resource.templates.catData[cat.id].currentPage = 1;
                    $scope.resource.templates.filtereTemps = $scope.resource.templates.catData[cat.id].data.slice(0, $scope.resource.templates.perPage);
                    $scope.updateApp();
                    jQuery('#tab-svg .loading-photo').hide();
                    jQuery('#tab-svg').removeClass('nbd-onload');
                }
            }
        }
        $scope.changeProduct = function(product_id) {
            if(!product_id) {
                return alert('Not found product.')
            }
            var newUrl = url.origin + '?api_key=' +  api_key_bearer + '&product_id=' + product_id;
            window.location.href = newUrl;
        }
        $scope.scrollLoadMoreTemp = function() {
            var currentPage = $scope.resource.templates.currentPage;

            if( $scope.resource.templates.onload ) return;

            if( currentPage * $scope.resource.templates.perPage >= $scope.resource.templates.total ) {
                if($scope.resource.templates.next) {
                    $scope.resource.templates.onload = true;
                    jQuery('#tab-product-template').addClass('nbd-onload');
                    jQuery('#tab-product-template .loading-photo').show();
                    var url = $scope.resource.templates.next + '&limit=' + $scope.resource.templates.perPage;
                    var headers = apiAuthBearer;
                    headers['Content-Type'] = undefined;
                    $http({
                        method: "GET",
                        url: url,
                        headers: headers,
                    }).then(function successCallback(response){
                        if(response.status != 200 || angular.isUndefined(response.data.data) ) { 
                            jQuery('#tab-product-template .loading-photo').hide();
                            jQuery('#tab-product-template').removeClass('nbd-onload');
                            return;
                        }
                        $scope.resource.templates.currentPage = currentPage + 1;
                        $scope.resource.templates.data = $scope.resource.templates.data.concat(response.data.data);
                        $scope.resource.templates.total += response.data.data.length;
                        $scope.resource.templates.next = response.data.links.next;
                        $scope.resource.templates.filtereTemps = $scope.resource.templates.data;
                        $scope.updateApp();
                        $scope.resource.templates.onload = false;      
                        jQuery('#tab-product-template .loading-photo').hide();
                        jQuery('#tab-product-template').removeClass('nbd-onload');
                    });
                } 
            } else {
                $scope.resource.templates.currentPage = currentPage + 1;
                var dataNext = $scope.resource.templates.data.slice( currentPage * $scope.resource.templates.perPage , (currentPage + 1) * $scope.resource.templates.perPage);
                $scope.resource.templates.filtereTemps = $scope.resource.templates.filtereTemps.concat(dataNext);
                $scope.updateApp();
                $scope.resource.templates.onload = false;    
                jQuery('#tab-product-template .loading-photo').hide();
                jQuery('#tab-product-template').removeClass('nbd-onload'); 
            }
        }

        /* Get Data */
        $scope.getResource = function(type, container, callback){
            if(angular.isDefined($scope.resource[type].data.cat_data) && angular.isDefined($scope.resource[type].data.cat_data['all'])) return;
            if( type != 'clipart' && type != 'myClipart' ) {
                jQuery(container + ' .loading-photo').show();
            }
            if( type == 'clipart' || type == 'myClipart' ) {
                if( angular.isDefined($scope.resource[type].data.cat) && $scope.resource[type].data.cat.length > 0 ) {
                    if( callback ) $scope.afterGetResource(type);
                    return;
                }
                jQuery('#tab-svg .printcart-loading').show();
            }
            // get data Typography
            var url = s3PreUrl+'assets/datas/typo.json';
            var headers = '';
            if(type === 'clipart') {
                url = apiPre + 'clipart-storages/default?limit=20';
                headers = apiAuthBearer;
            } else if( type === 'myClipart') {
                url = apiPre + 'clipart-storages/default?limit=20';
                headers = apiAuthBearer;
            }
            $http({
                method: "GET",
                url: url,
                headers: headers,
            }).then(function successCallback(response){
                var _data = response.data;
                if( type == 'clipart' || type == 'myClipart' ) {
                    $scope.resource[type].data.cat = _data.data;
                    jQuery('#tab-svg .printcart-loading').hide();
                    if( callback ) $scope.afterGetResource(type);
                } else {
                    jQuery(container + ' .loading-photo').hide();
                    $scope.resource[type].data = _data.data;
                    $scope.resource[type].filter.total = $scope.resource[type].data.length;
                    $scope.updateApp();
                    if( callback ) $scope.afterGetResource(type);
                }
            }, function errorCallback(response) {
                console.log('Fail to load: ' + type);
            });
        };
        $scope.onClickTab = function(type, tab){
            $scope.resource[tab].onclick = !$scope.resource[tab].onclick;
            if(!$scope.resource.photo.onclick) jQuery('#tab-'+tab+' .loading-photo').hide();
            $scope.disableDrawMode();
            switch(type){
                case 'dropbox':
                case 'facebook':
                case 'instagram':
                case 'upload':
                case 'url':
                    if( type == 'upload' ){
                        if( $scope.settings.nbdesigner_cache_uploaded_image == 'yes' && $scope.resource.upload.data.length == 0){
                            $scope.resource.upload.data = $scope._localStorage.get('nbduploaded');
                        };
                    };
                    $timeout(function(){
                        if(type != 'url' && $scope.resource[tab].onclick){
                            $scope.renderMasonryList(type, '#nbd-'+type+'-wrap .mansory-wrap', '.mansory-item', '#nbd-'+type+'-wrap', $scope.resource[type].init);
                        }
                    });
                    $scope.resource.personal = {status: true, type: type};
                    break; 
                case 'Pixabay':
                case 'Unsplash':
                case 'Pexels':
                case 'Freepik':
                    $scope.resource.personal.status = false;
                    if($scope.resource[tab].onclick && $scope.resource[tab].type != type){
                        $scope.getPhoto(type);
                    }
                    break;
                case 'shape':
                case 'icon':
                case 'line':
                case 'flaticon':
                case 'storyset':
                    if($scope.resource[tab].onclick){
                        $scope.renderMasonryList(type, '#nbd-'+type+'-wrap .mansory-wrap', '.mansory-item', '#nbd-'+type+'-wrap', $scope.resource[type].init);
                    }
                    if( $scope.resource[tab].onclick && $scope.resource[tab].type != type ) $scope.getMedia(type);
                    break;
                case 'draw':
                    if($scope.resource[tab].onclick){
                        $scope.enableDrawMode();
                    }
                    $scope.resource.element.type = type;
                    break;
                case 'qrcode':
                    $scope.resource.element.type = type;
                    break;
                case 'vcard':
                    $scope.resource.element.type = type;
                    break;
                case 'photoFrame':
                    $scope.resource.element.type = type;
                    if( !$scope.resource[type].filter.currentPage ){
                        $scope.resource[type].filter.currentPage = 1;
                    }
                    break;
                default:
                    $scope.resource.element.type = type;
                    break;
            };
        };
        $scope.changeCatNew = function( type , cat){
            if(angular.isUndefined(cat.id)) return;
            var currentCat = cat.id;
            $scope.resource[type].filter.currentCat = cat;
            $scope.resource[type].filter.search = '';
            $scope.resource[type].filter.currentPage = 1;
            $scope.resource[type].filter.changeFilter = !$scope.resource[type].filter.changeFilter;
            if(angular.isUndefined($scope.resource[type].data.cat_data[currentCat]) ) {
                jQuery('#tab-svg').addClass('nbd-onload');
                jQuery('#tab-svg .loading-photo').show();
                var url = apiPre + 'clipart-storages/' + cat.id + '/cliparts-default?limit=' + $scope.resource[type].filter.perPage;
                if(type === 'myClipart') {
                    url = apiPre + 'clipart-storages/' + cat.id + '/cliparts?limit=' + $scope.resource[type].filter.perPage;
                }
                if(cat.id == 'all') {
                    url = apiPre+'cliparts/default?limit='+$scope.resource[type].filter.perPage;
                    if(type === 'myClipart') {
                        url = apiPre+'cliparts?limit='+$scope.resource.myClipart.filter.perPage;
                    }
                }
                $scope.resource[type].filteredArts = [];
                $http({
                    method: "GET",
                    url: url,
                    headers: apiAuthBearer,
                }).then(function successCallback(response){
                    if(response.status != 200) { 
                        alert(response.data.message);
                        return;
                    }
                    $scope.resource[type].filter.changeFilter = !$scope.resource[type].filter.changeFilter;
                    $scope.resource[type].filter.total = response.data.data.length;
                    $scope.resource[type].data.cat_data[cat.id] = response.data.data;
                    if(response.data.links.next) {
                        $scope.resource[type].nextPage[currentCat] = response.data.links.next+ '&limit=' + $scope.resource[type].filter.perPage;
                    } else {
                        $scope.resource[type].nextPage[currentCat] = null;
                    }
                    switch(type){
                        case 'clipart':
                        case 'myClipart':
                            jQuery("#tab-svg .tab-scroll").stop().animate({
                                scrollTop: 0
                            }, 100);
                            $scope.updateApp();
                            break;
                        case 'icon':
                            $scope.resource.element.contentSearch = '';
                            jQuery("#tab-element .tab-scroll").stop().animate({
                                scrollTop: 0
                            }, 100);
                            jQuery("#tab-element .tab-scroll").perfectScrollbar('update');
                            jQuery("#tab-element .tab-scroll .result-loaded .type-icons .mansory-wrap").css('height', 0);
                            $scope.getMedia('icon', 'search');
                            break;
                    };
                    jQuery('#tab-svg .loading-photo').hide();
                    jQuery('#tab-svg').removeClass('nbd-onload');
                });
            } else {
                $scope.resource[type].filter.changeFilter = !$scope.resource[type].filter.changeFilter;
                $scope.resource[type].filter.total = $scope.resource[type].data.cat_data[currentCat].length;
                switch(type){
                    case 'clipart':
                        jQuery("#tab-svg .tab-scroll").stop().animate({
                            scrollTop: 0
                        }, 100);
                        $scope.updateApp();
                        break;
                    case 'icon':
                        $scope.resource.element.contentSearch = '';a
                        jQuery("#tab-element .tab-scroll").stop().animate({
                            scrollTop: 0
                        }, 100);
                        jQuery("#tab-element .tab-scroll").perfectScrollbar('update');
                        jQuery("#tab-element .tab-scroll .result-loaded .type-icons .mansory-wrap").css('height', 0);
                        $scope.getMedia('icon', 'search');
                        break;
                };
                jQuery('#tab-svg .loading-photo').hide();
                jQuery('#tab-svg').removeClass('nbd-onload');
            }
            
        }
        $scope.onClipartPrev = function(catId) {
            if(!catId) return;
            var container = jQuery('.printcart-clipart-storage-' + catId + ' .tab-scroll');
            var scrollLeft = container.prop("scrollLeft");
            var clientWidth = container.prop("clientWidth");
            if( scrollLeft < clientWidth + 5 ){
                jQuery('.printcart-clipart-storage-' + catId + ' button.clipart-prev').hide();
            } else {
                jQuery('.printcart-clipart-storage-' + catId + ' button.clipart-next').show();
            }
            jQuery(container).stop().animate({
                scrollLeft: scrollLeft - clientWidth,
            }, 300);
        }
        $scope.onClipartNext = function(catId) {
            if(!catId) return;
            var container = jQuery('.printcart-clipart-storage-' + catId + ' .tab-scroll');
            var scrollLeft = container.prop("scrollLeft");
            var clientWidth = container.prop("clientWidth");
            var scrollWidth = container.prop("scrollWidth");
            if( scrollLeft + clientWidth*2 + 5 > scrollWidth ){
                jQuery('.printcart-clipart-storage-' + catId + ' button.clipart-next').hide();
                $scope.scrollLoadMoreClipart(catId);
            } else {
                jQuery('.printcart-clipart-storage-' + catId + ' button.clipart-prev').show();
            }
            container.stop().animate({
                scrollLeft: scrollLeft + clientWidth,
            }, 300);
        }
        $scope.afterGetResource = function(type){
            switch(type){
                case 'clipart':
                case 'myClipart':
                    // var url = apiPre+'cliparts/default?limit='+$scope.resource[type].filter.perPage;
                    // if(type === 'myClipart') {
                    //     url = apiPre+'cliparts?limit='+$scope.resource[type].filter.perPage;
                    // }
                    function getResources(cat) {
                        var url = apiPre + 'clipart-storages/' + cat.id + '/cliparts-default?limit=' + $scope.resource[type].filter.perPage;
                        if(type === 'myClipart') {
                            url = apiPre + 'clipart-storages/' + cat.id + '/cliparts?limit=' + $scope.resource[type].filter.perPage;
                        }
                        return $http({
                            method: "GET",
                            url: url,
                            headers: apiAuthBearer,
                        });
                    }
                    var promises = [];
                    if($scope.resource[type].data.cat.length > 0) {
                        angular.forEach($scope.resource[type].data.cat, function(cat, key) {
                            if(angular.isUndefined($scope.resource[type].data.cat_data[cat.id]) || $scope.resource[type].data.cat_data[cat.id].length == 0) {
                                promises.push(
                                    getResources(cat)
                                );
                                $timeout(function(){
                                    jQuery('.printcart-clipart-storage-' + cat.id + ' .printcart-clipart .loading-photo').show();
                                    jQuery('.printcart-clipart-storage-' + cat.id + ' button.clipart-prev').hide();
                                    jQuery('.printcart-clipart-storage-' + cat.id + ' button.clipart-next').hide();
                                    var scrollEl = $('.printcart-clipart-storage-' + cat.id + ' .printcart-clipart .tab-scroll');
                                    scrollEl.on('ps-scroll-x', function(){
                                        var scrollLeft = scrollEl.prop("scrollLeft");
                                        var clientWidth = scrollEl.prop("clientWidth");
                                        var scrollWidth = scrollEl.prop("scrollWidth");
                                        if(clientWidth != scrollWidth && ((scrollLeft + clientWidth - scrollWidth ) + 5 > 0) ){
                                            $scope.scrollLoadMoreClipart(cat.id);
                                        };
                                    });
                                });
                            }
                        })
                    }
                    if(promises.length > 0) {
                        Promise.all(promises).then(function(response) {
                            if(response.length > 0) {
                                angular.forEach(response, function(res, key) {
                                    if(angular.isDefined(res.data) ) {
                                        var _cat = $scope.resource[type].data.cat[key];
                                        $scope.resource[type].data.cat_data[_cat.id] = res.data.data;
                                        if(res.data.links.next) {
                                            $scope.resource[type].nextPage[_cat.id] = res.data.links.next+ '&limit=' + $scope.resource[type].filter.perPage;
                                        } else {
                                            $scope.resource[type].nextPage[_cat.id] = null;
                                        }
                                        var container = jQuery('.printcart-clipart-storage-' + _cat.id + ' .tab-scroll');
                                        var clientWidth = container.prop("clientWidth");
                                        var scrollWidth = container.prop("scrollWidth");
                                        if(scrollWidth >= clientWidth) {
                                            jQuery('.printcart-clipart-storage-' + _cat.id + ' button.clipart-next').show();
                                        }
                                        jQuery('.printcart-clipart-storage-' + _cat.id + ' .printcart-clipart .loading-photo').hide();
                                    }
                                })
                                $timeout(function(){
                                    $('.printcart-clipart .tab-scroll').perfectScrollbar();
                                });
                            }
                            jQuery('#tab-svg').removeClass('nbd-onload');
                        });
                    } else {
                        jQuery('#tab-svg').removeClass('nbd-onload');
                    }
                    break;
                case 'photo':
                    if( $scope.resource.photo.data.length == 0 ) jQuery('#tab-photo .loading-photo').hide();
                    $scope.resource.photo.filter.total = $scope.resource.photo.filter.totalPage * $scope.resource.photo.filter.perPage;
                    break;
            }
            // $scope.changeCat('clipart', 0);
        };
        $scope.onEndRepeat = function(type){
            switch(type){
                case 'typography':
                    $scope.renderMasonryList(type, '.nbd-sidebar .typography-items', '.typography-item', '#tab-typography', $scope.resource[type].init);
                    break;
                case 'font':
                case 'myFont':
                    jQuery('#tab-font').perfectScrollbar('update');
                    break;
                case 'clipart':
                case 'myClipart':
                    // $scope.renderMasonryList(type, '#tab-svg .clipart-wrap', '.clipart-item', '#tab-svg', $scope.resource[type].init);
                    break; 
                case 'photo':
                    $scope.renderMasonryList(type, '#tab-photo .nbdesigner-gallery', '.nbdesigner-item', '#tab-photo', $scope.resource[type].init);
                    break;
                case 'dropbox':
                case 'instagram':
                case 'facebook':
                case 'upload':
                case 'shape':
                case 'icon':
                case 'line':
                case 'flaticon':
                case 'storyset':
                case 'photoFrame':
                    $scope.renderMasonryList(type, '#nbd-'+type+'-wrap .mansory-wrap', '.mansory-item', '#nbd-'+type+'-wrap', $scope.resource[type].init);
                    break;
            }
        };
        $scope.updateScrollBar = function( jSelector ){
            $timeout(function(){
                jQuery(jSelector).perfectScrollbar('update');
            });
        };
        $scope.renderMasonryList = function(type, container, item, scrollContainer, init){  
            imagesLoaded( jQuery(container), function() {
                if( !init ) jQuery(container).masonry('destroy');
                var $grid = jQuery(container).masonry({
                    itemSelector: item
                }); 

                jQuery.each(jQuery(container + ' ' +item), function(e) {
                    var animate = Math.floor(Math.random() * 10);
                    animate = (animate + 1) * 100;
                    if( checkMobileDevice() ){
                        jQuery(this).addClass("in-view");
                    }else{
                        jQuery(this).addClass("in-view slideInDown animated animate"+animate);
                    }
                });
                jQuery(scrollContainer+' .tab-scroll').perfectScrollbar('update');
                $timeout(function(){
                    if(type != 'clipart' && type != 'myClipart') {
                        jQuery(scrollContainer + ' .loading-photo').hide();
                    }
                    jQuery(scrollContainer + ' .tab-load-more').show();
                }, 100);
                // if(type != 'clipart') $scope.resource[type].onload = false;
                $scope.resource[type].onload = false;
                $scope.resource[type].init = false;

            });
        };
        $scope.generateTypoLink = function(typo){
            return s3PreMedia+'typography/' + typo.folder + '/preview.png';
        };
        $scope.scrollLoadMoreClipart = function(catId) {
            var type = 'clipart';
            if(!catId) return;
            jQuery('.printcart-clipart-storage-' + catId + ' .printcart-clipart .loading-photo').show();
            if( angular.isUndefined($scope.resource[type].nextPage[catId]) || !$scope.resource[type].nextPage[catId] ) return;
            $http({
                method: "GET",
                url: $scope.resource[type].nextPage[catId],
                headers: apiAuthBearer,
            }).then(function successCallback(response){
                $scope.resource[type].nextPage[catId] = response.data.links.next;
                jQuery('.printcart-clipart-storage-' + catId + ' button.clipart-next').show();
                $scope.resource[type].data.cat_data[catId] = $scope.resource[type].data.cat_data[catId].concat(response.data.data);
                jQuery('.printcart-clipart-storage-' + catId + ' .printcart-clipart .loading-photo').hide();
            });
        }
        /* Infinite scroll */
        $scope.scrollLoadMore = function(container, type){
            if( $scope.resource[type].onload) return;
            jQuery(container + ' .loading-photo').show();
            if(type == 'clipart' || type == 'myClipart' ) {
                $scope.resource[type].onload = true;
                var currentCat = angular.isDefined($scope.resource[type].filter.currentCat) && angular.isDefined($scope.resource[type].filter.currentCat.id) ? $scope.resource[type].filter.currentCat.id : '';
                if( angular.isUndefined($scope.resource[type].nextPage[currentCat]) ) return;
                if( $scope.resource[type].filter.currentPage * $scope.resource[type].filter.perPage >= $scope.resource[type].data.cat_data[currentCat].length && $scope.resource[type].nextPage[currentCat] ) {
                    $http({
                        method: "GET",
                        url: $scope.resource[type].nextPage[currentCat],
                        headers: apiAuthBearer,
                    }).then(function successCallback(response){
                        $scope.resource[type].nextPage[currentCat] = response.data.links.next;
                        jQuery(container + ' .loading-photo').hide();
                        $scope.resource[type].filter.currentPage += 1;
                        if(type == 'clipart' || type == 'myClipart') {
                            $scope.resource[type].data.cat_data[currentCat] = $scope.resource[type].data.cat_data[currentCat].concat(response.data.data);
                            $scope.resource[type].filter.total = $scope.resource[type].data.cat_data[currentCat].length;
                        } else if(type == 'photo') {
                            !$scope.resource.personal.status && $scope.getPhoto($scope.resource.photo.type, 'more');
                            $scope.updateApp();
                        } else {
                            $scope.updateApp();
                        }
                    });
                } else {
                    if($scope.resource[type].filter.currentPage * $scope.resource[type].filter.perPage < $scope.resource[type].data.cat_data[currentCat].length) $scope.resource[type].filter.currentPage += 1;
                    jQuery(container + ' .loading-photo').hide();
                    $scope.updateApp();
                }
            } else if (type == 'font' || type == 'myFont') {
                $scope.resource[type].onload = true;
                if( !$scope.resource[type].nextPage ) return;
                if( $scope.resource[type].filter.currentPage * $scope.resource[type].filter.perPage >= $scope.resource[type].filteredFonts.length && $scope.resource[type].nextPage ) {
                    $http({
                        method: "GET",
                        url: $scope.resource[type].nextPage+'&sortBy=id&sort=asc&limit='+$scope.resource[type].filter.perPage,
                        headers: apiAuthBearer,
                    }).then(function successCallback(response){
                        $scope.resource[type].nextPage = response.data.links.next;
                        jQuery(container + ' .loading-photo').hide();
                        $scope.resource[type].onload = false;
                        $scope.resource[type].filter.currentPage += 1;
                        var fonts = [];
                        if(response.data.data.length > 0 ) {
                            angular.forEach(response.data.data, function(font, key) {
                                var font = $scope.formatFont(font);
                                fonts.push(font);
                            }) 
                        }
                        // $scope.resource[type].filteredFonts = $scope.resource[type].filteredFonts.concat(response.data.data);
                        $scope.resource[type].data = $scope.resource[type].data.concat(fonts);

                        $scope.resource[type].filter.total = $scope.resource[type].data.length;
                    });
                } else {
                    if($scope.resource[type].filter.currentPage * $scope.resource[type].filter.perPage < $scope.resource[type].filteredFonts.length) $scope.resource[type].filter.currentPage += 1;
                    jQuery(container + ' .loading-photo').hide();
                    $scope.updateApp();
                }
            } else {
                if(type == 'element'){
                    var elementType = $scope.resource.element.type;
                    if( ['icon', 'shape', 'line', 'flaticon', 'storyset'].indexOf(elementType) > -1 ){
                        if( $scope.resource[elementType].filter.currentPage < $scope.resource[elementType].filter.totalPage ){
                            $scope.resource[elementType].filter.currentPage += 1;
                            $scope.getMedia(elementType, 'more');
                        }else{
                            jQuery(container + ' .loading-photo').hide();
                            return;
                        }
                    };
                    if( elementType == 'photoFrame' ){
                        if( $scope.resource[elementType].filter.currentPage * $scope.resource[elementType].filter.perPage < $scope.resource[elementType].filter.total ){
                            $scope.resource[elementType].filter.currentPage += 1;
                        }else{
                            jQuery(container + ' .loading-photo').hide();
                            return;
                        }
                    }
                    if( elementType == 'frame' ){
                        jQuery(container + ' .loading-photo').hide();
                    }
                    return;
                } else {
                    if( $scope.resource[type].filter.currentPage * $scope.resource[type].filter.perPage >= $scope.resource[type].filter.total){
                        jQuery(container + ' .loading-photo').hide();
                        return;
                    }
                    jQuery(container + ' .loading-photo').show();
                    if( $scope.resource[type].filter.currentPage * $scope.resource[type].filter.perPage < $scope.resource[type].filter.total ){
                        $scope.resource[type].filter.currentPage += 1;
                    }
                }
            }
            switch(type){
                case 'typography':
                    $scope.resource[type].onload = true;
                    break;
                case 'clipart':
                case 'myClipart':
                    
                    break;
                case 'font':
                case 'myFont':
                    
                    break;  
                case 'photo':
                    $scope.resource[type].onload = true;
                    !$scope.resource.personal.status && $scope.getPhoto($scope.resource.photo.type, 'more');
                    break;
            }
            $scope.updateApp();
            
        };
        $scope.changeCat = function(type, cat){
            $scope.resource[type].filter.search = '';
            $scope.resource[type].filter.currentPage = 1;
            $scope.resource[type].filter.currentCat = cat;
            $scope.resource[type].filter.total = cat.amount ? cat.amount : cat.total;
            $scope.updateApp();
            switch(type){
                case 'clipart':
                case 'myClipart':
                    jQuery("#tab-svg .tab-scroll").stop().animate({
                        scrollTop: 0
                    }, 100);
                    break;
                case 'icon':
                    $scope.resource.element.contentSearch = '';
                    jQuery("#tab-element .tab-scroll").stop().animate({
                        scrollTop: 0
                    }, 100);
                    jQuery("#tab-element .tab-scroll").perfectScrollbar('update');
                    jQuery("#tab-element .tab-scroll .result-loaded .type-icons .mansory-wrap").css('height', 0);
                    $scope.getMedia('icon', 'search');
                    break;
            };
        };
        $scope.updateApp = function(){
            if ($scope.$root.$$phase !== "$apply" && $scope.$root.$$phase !== "$digest") $scope.$apply(); 
        };
        $scope.stageOnload = false;
        $scope.toggleStageLoading = function( timeout ){
            jQuery('.loading-workflow').toggleClass('nbd-show');
            var container = 'body';
            jQuery(container).toggleClass('nbd-onloading');
            var _timeout = timeout ? timeout : 2E4;
            if( jQuery('.loading-workflow').hasClass('nbd-show') ){
                $scope.stageOnload = true;
                $scope._promise = $timeout(function(){
                    if( $scope.stageOnload ){
                        jQuery('.loading-workflow').removeClass('nbd-show');
                        jQuery(container).removeClass('nbd-onloading');
                    }
                }, _timeout);
            }else{
                $timeout.cancel($scope._promise);
                $scope.stageOnload = false;
            }
            $scope.updateApp();
        };
        /* Upload Image */
        $scope.uploadFile = function(files, indexFile){
            indexFile = angular.isDefined(indexFile) ? indexFile : 0;
            if( files.length <= 0 || indexFile > (files.length - 1) || indexFile > (parseInt($scope.settings.nbdesigner_max_upload_files_at_once) - 1) ) return;
            var file = files[indexFile],
            // max_size = parseInt($scope.settings.nbdesigner_maxsize_upload),
            // min_size = parseInt($scope.settings.nbdesigner_minsize_upload);
            max_size = 500,
            min_size = 0;
            if( ( file.type.indexOf("image") === -1 && file.type.indexOf("pdf") === -1 ) ){
                alert( "Supported extensions: PNG, JPE, JPEG, SVG" );
                return;
            }
            if ( file.size > max_size * 1024 * 1024 ) {
                alert( "Max file size: " + max_size + " MB" );
                return;
            }else if( file.size < min_size * 1024 * 1024 ){
                alert( "Min file size: " + min_size + " MB" );
                return;
            };
            if( file.type.indexOf("svg") > -1 ){
                var reader = new FileReader();
                reader.onload = function(event){
                    if (event.target.readyState === 2) {
                        var result = reader.result;
                        $scope.addSvgFromString(result);
                        $scope.uploadFile(files, indexFile + 1);
                    }
                };
                reader.readAsText(file);
            }else{
                $scope.toggleStageLoading();
                $scope.resource.upload.progressBar = 0;
                // jQuery('.nbd-progress-bar').addClass('active');
                var stage = $scope.stages[$scope.currentStage],
                    _canvas = stage['canvas'],
                    object = _canvas.getActiveObject();
                if( !!object && !!object.get('maskId') && files.length == 1 ){
                    var maskId = object.get('maskId');
                }
                url = apiPre + 'images';
                var formData = new FormData();
                formData.append('file', file);;
                var headers = apiAuthBearer;
                headers['Content-Type'] = undefined;
                $http({
                    method: "POST",
                    url: url,
                    headers: headers,
                    transformRequest: angular.identity,
                    transformResponse: angular.identity,
                    data: formData
                }).then(function successCallback(response){
                    var data = JSON.parse(response.data);
                    if( response.status == '201' ){
                        data = data.data;
                        $scope.storeUploadFile(data.url, data.name);
                        if( maskId ){
                            $scope.addImage(data, false, true, false, false, maskId);
                        }else{
                            $scope.addImage(data, false, true );
                        }
                        jQuery("#tab-photo .tab-scroll").stop().animate({
                            scrollTop: jQuery("#tab-photo .tab-scroll").prop("scrollHeight")
                        }, 100);
                        localStorage.setItem('uploaded', $scope.resource.upload.data);
                        $scope.onEndRepeat('upload');
                        $scope.uploadFile(files, indexFile + 1);
                    }else{
                        $scope.toggleStageLoading();
                        alert(data.message);
                    }
                    jQuery('.nbd-progress-bar').removeClass('active');
                }, function( progress ){
                    // $scope.resource.upload.progressBar = progress.toFixed(0);
                });                 
            }
        };
        /* Filter */
        $scope.checkActiveFilter = function( type, filters ){
            var index;
            filters.forEach(function(filter, _index) {
                var options = JSON.parse( filter.jOptions );
                if( options.type == type ) index = _index;
            });
            if( angular.isDefined( index ) ){
                return true;
            }
            return false;
        };
        /* SVG */
        $scope.addSvgFromString = function(svg, showLoading){
            if( angular.isUndefined(showLoading) ) $scope.toggleStageLoading();
            fabric.loadSVGFromString(svg, function(ob, op) {
                $scope._addSvg(ob, op, {name: ''}, true);
            });
        };
        $scope.addSvgFromMedia = function(art, $index){
            $scope.showDesignTab();
            $scope.toggleStageLoading();
            $http({
                method: 'GET',
                url: mediaUrl + '/clipart?get_svg=' + art.url.replace("//dpeuzbvf3y4lr.cloudfront.net/", "")
            }).then(function successCallback(response){
                var svg = response.data.data;
                if( !svg ){
                    $scope.toggleStageLoading();
                    return;
                }
                $scope.addSvgFromString(svg, false);
            }, function errorCallback(response) {
                console.log('Fail to load: svg');
            });
        };
        $scope.addArt = function(art, showLoading, hideLoading){
            if( showLoading ) $scope.toggleStageLoading();
            if(art.url.match(/\.(jpeg|jpg|gif|png)$/) != null){
                $scope.addImage(art.url, false, hideLoading);
            }else{
                fabric.loadSVGFromURL(art.url, function(ob, op) {
                    if(ob){
                        $scope._addSvg(ob, op, art, hideLoading);
                    }else{
                        alert('Try again!');
                        $scope.toggleStageLoading();
                    }
                });
            }
        };
        /* Add SVG */
        $scope._addSvg = function(ob, op, art, hideLoading){
            var stage = $scope.stages[$scope.currentStage],
            _canvas = stage['canvas'],
            scale = stage.states.scaleRange[stage.states.currentScaleIndex].ratio,
            max_width = _canvas.width / scale * .9,
            max_height = _canvas.height / scale * .9,
            new_width = max_width;

            if (op.width < max_width) new_width = op.width;
            var width_ratio = new_width / op.width,
            new_height = op.height * width_ratio;
            if (new_height > max_height) {
                new_height = max_height;
                var height_ratio = new_height / op.height;
                new_width = op.width * height_ratio;
            }
            var object = fabric.util.groupSVGElements(ob, op);
            object.scaleToWidth(new_width);
            object.scaleToHeight(new_height);
            if( angular.isDefined( art.type ) && art.type == 'qrcode' ){
                object.set( { qrContent: art.qrContent, isQrcode: 1 } );
            } else if( angular.isDefined( art.type ) && art.type == 'barcode' ){
                object.set( { barCodeContent: art.barCodeContent, isBarcode: 1 } );
            }
            _canvas.add(object);
            if( hideLoading ) $scope.toggleStageLoading();
        };
        $scope.addQrCode = function(){
            var qr = qrcode(0, 'M', printcart_default_settings.color);
            qr.addData( $scope.resource.qrText );
            qr.make();
            var _qrcode = qr.createSvgTag();
            fabric.loadSVGFromString(_qrcode, function(ob, op) {
                $scope._addSvg(ob, op, {name: '', type: 'qrcode', qrContent: $scope.resource.qrText}, false);
            });
            jQuery('#barcode').html('');
            jQuery('.main-qrcode').html('').append(_qrcode);
        };
        $scope.updateQrCode = function(){
            var _stage = this.stages[this.currentStage],
                _canvas = _stage.canvas,
                obj = _canvas.getActiveObject();
            if (!obj) return;
            var qr = qrcode(4, 'L', printcart_default_settings.color),
            content = $scope.stages[$scope.currentStage].states.qrContent;
            qr.addData( content );
            qr.make();
            var _qrcode = qr.createSvgTag();
            fabric.loadSVGFromString(_qrcode, function(ob, op) {
                var object = fabric.util.groupSVGElements(ob, op);
                obj.set({
                    dirty: true,
                    qrContent: content,
                    path: object.path
                });
                $scope.renderStage();
            });
        };
        $scope.addBarCode = function(){
            jQuery('.main-qrcode').html('');
            JsBarcode("#barcode", $scope.resource.qrText, {
                font: fontDefaultSettings.alias,
                lineColor: printcart_default_settings.color
            });
            $timeout(function(){
                fabric.loadSVGFromString(jQuery('#barcode').wrap('<div/>').parent().html(), function(ob, op) {
                    $scope._addSvg(ob, op, {name: '', barCodeContent: $scope.resource.qrText, type: 'barcode'}, false);
                    jQuery('#barcode').unwrap();
                });
            });
        };
        $scope.updateBarCode = function(){
            var _stage = this.stages[this.currentStage],
                _canvas = _stage.canvas,
                obj = _canvas.getActiveObject();
            if (!obj) return;
            var content = $scope.stages[$scope.currentStage].states.barCodeContent;
            jQuery('.main-qrcode').html('');
            JsBarcode("#barcode", content, {
                font: fontDefaultSettings.alias,
                lineColor: printcart_default_settings.color
            });
            $timeout(function(){
                fabric.loadSVGFromString(jQuery('#barcode').wrap('<div/>').parent().html(), function(ob, op) {
                    var object = fabric.util.groupSVGElements(ob, op);
                    object.set({
                        originX: 'center',
                        originY: 'center'
                    });
                    obj.set({
                        dirty: true,
                        width: object.width,
                        barCodeContent: content,
                        _objects: object._objects
                    });
                    obj.setCoords();
                    $scope.renderStage();
                    jQuery('#barcode').unwrap();
                });
            });
        };
        /* Store file */
        $scope.storeUploadFile = function(data, name){
            var src = typeof data == 'object' ? data.src : data;

            var ojb = {
                url: src,
                src: src,
                des: name,
                ilr: $scope.resource.upload.ilr
            };
            if( typeof data == 'object' && angular.isDefined( data.origin_url ) ){
                ojb.origin_url      = data.origin_url;
                ojb.src             = src;
                ojb.width           = data.width;
                ojb.height          = data.height;

                if( angular.isDefined( data.origin_pdf ) ){
                    ojb.origin_pdf  = data.origin_pdf;
                }
            }

            $scope.resource.upload.data.push( ojb );

            /*Setup cache uppload Image*/
            // if( $scope.settings.nbdesigner_cache_uploaded_image == 'yes' ){
                $scope._localStorage.save('nbduploaded');
            // }
        };
        $scope.localStore = {
            db: null,
            ready: false,
            existed: true,
            numberOfRecords: 0,
            init: function(){
                var self = this;
                var indexedDB = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB || window.shimIndexedDB;
                if(indexedDB){
                    var open = indexedDB.open("NBDesigner", 1);
                    if( open == null ) return;
                    open.onsuccess = function (e) {
                        self.db = e.target.result;
                        self.ready = true;
                    };
                    open.onupgradeneeded = function(event){
                        var db =  event.target.result;
                        var objectStore = db.createObjectStore("designs", { keyPath: "id" });
                        self.existed = false;
                    };
                    open.onerror  = function(event){
                        console.log(event);
                    };
                }
            },
            add: function( pid, data, callback ){
                if( this.ready ){
                    var request = this.db.transaction(["designs"], "readwrite").objectStore("designs").add({ id: pid, data: data });
                    request.onsuccess = function(event) {
                        if(typeof callback == 'function') callback();
                    };
                }
            },
            update: function( pid, data, callback ){
                if( this.ready ){
                    var objectStore = this.db.transaction(["designs"], "readwrite").objectStore("designs");
                    var request = objectStore.get(pid);
                    request.onsuccess = function(event) {
                        var _data = event.target.result;
                        if( _data ){
                            _data.data = data;  
                        }else{
                            _data = { id: pid, data: data };
                        }
                        var requestUpdate = objectStore.put(_data);
                        requestUpdate.onsuccess = function(event) {
                            if(typeof callback == 'function') callback();
                        };
                    };
                    request.onerror = function(event) {
                        console.log(event);
                    };
                }
            },
            count: function(){
                var self = this;
                if( this.ready ){
                    var transaction = this.db.transaction(["designs"]);
                    var objectStore = transaction.objectStore("designs");
                    var countRequest  = objectStore.count();
                    countRequest.onsuccess = function() {
                        self.numberOfRecords = countRequest.result;
                    };
                }
            },
            get: function( pid, callback ){
                if( this.ready ){
                    var transaction = this.db.transaction(["designs"]);
                    var objectStore = transaction.objectStore("designs");
                    var request = objectStore.get(pid);
                    request.onsuccess = function(event) {
                        if(typeof callback == 'function'){
                            callback(event.target.result);
                        }
                    };
                    request.onerror = function(event) {
                        console.log(event);
                    };
                }
            },
            delete: function( pid, callback ){
                if( this.ready ){
                    var request = this.db.transaction(["designs"], "readwrite").objectStore("designs").delete(pid);
                    request.onsuccess = function(event) {
                       callback();
                    };
                }
            }
        };
        $scope._localStorage = {
            save: function(type, value){
                if( type == 'nbduploaded') {
                    if( $scope.resource.upload.data.length > 20 ) $scope.resource.upload.data.shift();
                    value = JSON.stringify($scope.resource.upload.data);
                }
                localStorage.setItem(type, value);
            },
            get: function(type){
                var data = localStorage.getItem(type);
                if( data ){
                    return JSON.parse(data);
                }else{
                    return [];
                }
            },
            delete: function(type){
                if( type == 'nbduploaded') {
                    $scope.resource.upload.data = [];
                    $scope.updateApp();
                }
                localStorage.setItem(type, JSON.stringify([]));
            }
        };
        /* Text */
        $scope.addText = function(content, type, additionalObj){
            content = angular.isDefined(content) ? content : $scope.settings.nbdesigner_default_text;
            type = angular.isUndefined(type) ? 'bodytext' : type;
            var textType = 'IText',
            fontSize = 16,
            fontName = fontDefaultSettings.alias;
            var state= $scope.stages[$scope.currentStage].states;
            switch(type){
                case 'heading':
                    textType = 'Textbox';
                    fontSize = 42;
                    break;
                case 'subheading':
                    textType = 'Textbox';
                    fontSize = 36;
                    break;
            };
            var textObj = {
                fontFamily: fontName,
                font: $scope.formatFont(fontDefaultSettings, true),
                radius: 50,
                objectCaching: false,
                fontSize: fontSize,
                ptFontSize: ( fontSize  / state.ratioConvertFont ).toFixed(2)
            };
            // if(!_.filter(state.usedFonts, ['alias', fontDefaultSettings.alias]).length){
            //     state.usedFonts.push($scope.formatFont(fontDefaultSettings));
            // };
            if( additionalObj ){
                angular.extend(textObj, additionalObj);
            };
            function addText(){
                $scope.stages[$scope.currentStage]['canvas'].add(new FabricWindow[textType](content, textObj));
            };
            var font = new FontFaceObserver(fontName);
            font.load(content).then(function () {
                fabric.util.clearFabricFontCache(fontName);
                var container = document.createElement('span'),
                scale = state.scaleRange[state.currentScaleIndex].ratio;
                container.innerHTML = content;
                container.style.cssText = [
                    'position:absolute',
                    'width:auto',
                    'font-size: ' + fontSize  + 'px',
                    'font-family: ' + fontName,
                    'left:-99999px'
                ].join(' !important;');
                document.body.appendChild(container);
                var textWidth = container.clientWidth + 2;
                document.body.removeChild(container);
                var canvasWidth = $scope.stages[$scope.currentStage]['canvas'].width;
                if( ( textWidth * scale ) > ( canvasWidth * 0.8 ) ){
                    textObj.width = canvasWidth * 0.8 / scale;
                    textObj.fontSize = canvasWidth * 0.8 / ( textWidth * scale ) * fontSize;
                    textObj.ptFontSize = ( textObj.fontSize  / state.ratioConvertFont ).toFixed( 2 );
                }else{
                    textObj.width = textWidth / scale;
                }
                $timeout(function(){
                    addText();
                }, 100);
            }, function () {
                console.log('Fail to load font: '+fontName);
                addText();
            });
        };
        $scope.addCurvedText = function( content ){
            var state= $scope.stages[$scope.currentStage].states;
            function addText(){
                var rtl = false;
                $scope.stages[$scope.currentStage]['canvas'].add(new fabric.CurvedText(content, {radius: 100, rtl: rtl, top: 100, left: 100, fontFamily: fontName, fontSize: 20, ptFontSize: 20  / state.ratioConvertFont}));    
            };
            var previewText = $scope.settings.subsets[fontDefaultSettings.subset] ? $scope.settings.subsets[fontDefaultSettings.subset]['preview_text'] : $scope.settings.subsets['all']['preview_text'];
            var fontName = fontDefaultSettings.alias,
            font = new FontFaceObserver(fontName);
            font.load(previewText).then(function () {
                fabric.util.clearFabricFontCache(fontName);
                addText();
            }, function () {
                console.log('Fail to load font: '+fontName);
                addText();
            });
        };
        $scope.hideRotateControl = function( item ){
            if( item != null ){
                item.set({hasRotatingPoint: false});
            }
        };
        $scope.normalizeText = function( item ){
            if( !!String.prototype.normalize ){
                if(angular.isDefined(item.text)) {
                    var normalizeText = item.text.normalize();
                    if( item.text != normalizeText ){
                        item.text = normalizeText;
                    }
                }
            }
        };
        /* Image */
        $scope.getEmptyMask = function(){
            var stage = $scope.stages[$scope.currentStage],
                _canvas = stage['canvas'],
                maskId = '';
            _canvas.forEachObject(function(obj, index) {
                if( !!obj.get('maskId') && obj.get('srcChanged') === false ){
                    if( maskId == '' ){
                        maskId = obj.get('maskId');
                    }
                };
            });
            return maskId;
        };
        $scope.addImage = function(data, showLoading, hideLoading, additionalTitle, additionalValue, maskId ){
            var stage = $scope.stages[$scope.currentStage],
                _canvas = stage['canvas'],
                scale = stage.states.scaleRange[stage.states.currentScaleIndex].ratio,
                url = typeof data == 'object' ? ( angular.isDefined( data.src ) ? data.src : data.url ) : data;
            if( showLoading ) $scope.toggleStageLoading();
            if( angular.isUndefined( maskId ) && $scope.settings.nbdesigner_auto_fill_template_masks == 'yes' ){
                var _maskId = $scope.getEmptyMask();
                if( _maskId != '' ) maskId = _maskId;
            }
            if( angular.isUndefined( maskId ) && $scope.settings.nbdesigner_limit_photo_by_masks == 'yes' ){
                if( hideLoading ) {
                    $timeout(function(){
                        $scope.toggleStageLoading();
                    });
                }
                return;
            }
            fabric.Image.fromURL(url, function(op) {
                if( angular.isDefined( maskId ) || $scope.stages[$scope.currentStage].states.elementUpload ){
                    var object;
                    if( angular.isDefined( maskId ) ){
                        object = $scope.getMaskedLayerByMaskId( maskId );
                    } else {
                        object = _canvas.getActiveObject();
                    }
                    var element = object.getElement();
                    element.setAttribute("src", url);
                    var scaleX = object.width * object.scaleX / op.width,
                    scaleY = object.width * object.scaleX / op.width;
                    if( angular.isDefined( maskId ) ) {
                        var mask = $scope.getMaskLayer( maskId ),
                        width = mask.get('width') * mask.get('scaleX'),
                        height = mask.get('height') * mask.get('scaleY'),
                        newWidth = width,
                        newHeight = height;
                        if( ( op.width / op.height ) > ( width / height ) ){
                            newWidth = op.width / op.height * newHeight;
                        }else{
                            newHeight = op.height / op.width * newWidth;
                        }
                        scaleX = newWidth / op.width;
                        scaleY = newHeight / op.height;

                        object.set({
                            isEmptyMask: false,
                            srcChanged: true
                        });
                    }
                    object.set({
                        dirty: true,
                        width: op.width,
                        height: op.height,
                        scaleX: scaleX,
                        scaleY: scaleY
                    });

                    if( typeof data == 'object' && angular.isDefined( data.origin_url ) ){
                        if( angular.isDefined( maskId ) ) {
                            scaleX = newWidth / data.width;
                            scaleY = newHeight / data.height;
                        }else{
                            var scaleX = object.width * object.scaleX / data.width,
                            scaleY = object.width * object.scaleX / data.width;
                        }
                        object.set({
                            origin_url: data.origin_url,
                            origin_width: data.width,
                            origin_height: data.height,
                            width: data.width,
                            height: data.height,
                            scaleX: scaleX,
                            scaleY: scaleY
                        });
                    }else if( !!object.origin_url ){
                        delete object.origin_url; 
                    }

                    object.setCoords();
                    if( angular.isDefined( maskId ) ) $scope.adjustMaskedLayers(object);
                    $scope.renderStage();
                    if( angular.isDefined( maskId ) ) {
                        $scope.adjustMaskedLayers(object);
                        if( $scope.checkActiveFilter && object.filters.length ){
                            object._originalElement = op._element;
                            object.applyFilters(false, function(){
                                setTimeout(() => $scope.renderStage(), 200);
                                setTimeout(() => $scope.renderStage(), 500);
                                setTimeout(() => $scope.renderStage(), 1000);
                            }, true);
                        }else{
                            $timeout(function(){
                                $scope.renderStage();
                            }, 500);
                            $timeout(function(){
                                $scope.renderStage();
                            }, 1000);
                            $timeout(function(){
                                $scope.renderStage();
                            }, 2000);
                            $timeout(function(){
                                $scope.renderStage();
                            }, 3000);
                        }
                    };
                    $scope.afterObjectModify();
                }else{
                    var _ratio = 0.9; // Tỉ lệ ảnh tải lên
                    var max_width = _canvas.width / scale * _ratio,
                    max_height = _canvas.height / scale * _ratio,
                    new_width = max_width;
                    if ( op.width < max_width ) new_width = op.width;
                    var width_ratio = new_width / op.width,
                    new_height = op.height * width_ratio;
                    if ( new_height > max_height ) {
                        new_height = max_height;
                        var height_ratio = new_height / op.height;
                        new_width = op.width * height_ratio;
                    };
                    op.set({
                        fill: '#ff0000',
                        scaleX: new_width / op.width,
                        scaleY: new_height / op.height
                    });

                    if( typeof data == 'object' && angular.isDefined( data.origin_url ) ){
                        op.set({
                            origin_url: data.origin_url,
                            origin_width: data.width,
                            origin_height: data.height,
                            width: data.width,
                            height: data.height,
                            scaleX: new_width / data.width,
                            scaleY: new_height / data.height
                        });
                    }

                    if( typeof data == 'object' && angular.isDefined( data.origin_pdf ) ){
                        op.set({ 
                            origin_pdf: data.origin_pdf,
                            lockRotation: true,
                            hasRotatingPoint: false
                        });
                    }

                    if( additionalTitle ) op[additionalTitle] = additionalValue;
                    _canvas.add(op);
                }
                if( hideLoading ) {
                    $timeout(function(){
                        $scope.toggleStageLoading();
                    });
                }
            }, {crossOrigin: 'anonymous'});
        };
        $scope.mask = 1;
        $scope.pathCommand = '';
        $scope.svgPath = '';
        $scope.getPathCommand = function(){
            var svgStr = $scope.svgPath.replace(/<!--[\s\S]*?-->/g, "").replace(/<\?xml[\s\S]*?\?>/g, "").replace(/<style[\s\S]*?style>/g, "").replace(/\n|\r/gm, " ").replace(/  /g, " ").replace(/^ /g, "").replace(/ $/g, "").replace(/(?:class|id|style|xmlns\:xlink|xml\:space|fill|enable-background)=['\"][^'\"]*['\"]/g  , ""  ).replace(/<\/?g>/g  , "").replace(/\s{2,}/g, ' ').replace(/(\/?>) </g, '$1<');
            var _regex = /d=["'](.*?)["']/gm;
            $scope.pathCommand = '';
            if( svgStr.match( /<path.*\/>/gm ) && svgStr.match( _regex ) ){
                matches = _regex.exec( svgStr );
                $scope.pathCommand = angular.isDefined( matches[1] ) ? matches[1] : '';
            }
        };
        /* Mark */
        $scope.createClippingMask = function(maskIndex, obj){
            var stage = $scope.stages[$scope.currentStage],
            _canvas = stage['canvas'],
            obj = obj ? obj : _canvas.getActiveObject();
            if( obj ){
                var width = obj.get('width'),
                height = obj.get('height'),
                top = obj.get('top'),
                left = obj.get('left'),
                scaleX = obj.get('scaleX'),
                scaleY = obj.get('scaleY'),
                realWidth = scaleX * width,
                realHeight = scaleY * height,
                realLeft = left - realWidth / 2,
                realTop = top - realHeight / 2;
                var pathCommand = maskIndex > -1 ? $scope.masks[ maskIndex ] : $scope.pathCommand;
                if( pathCommand == '' ) return;
                var path = new fabric.Path( pathCommand );
                $scope.contextAddLayers = 'addMask';
                _canvas.add(path);
                var pathObj = _canvas.item(_canvas.getObjects().length - 1);
                var newWidth = realWidth, newHeight = realHeight, newLeft = realLeft, newTop = realTop;
                if( ( realWidth / realHeight ) > ( pathObj.width / pathObj.height ) ){
                    newWidth = newHeight * pathObj.width / pathObj.height;
                    newLeft += ( realWidth - newWidth )/2;
                }else{
                    newHeight = newWidth * pathObj.height / pathObj.width;
                    newTop += ( realHeight - newHeight )/2;
                }
                var d = new Date(),
                itemId = d.getTime() + Math.floor(Math.random() * 1000);
                pathObj.set({
                    scaleX: newWidth / pathObj.width,
                    scaleY: newHeight / pathObj.height,
                    isMask: 1,
                    left: newLeft,
                    top: newTop,
                    absolutePositioned: true,
                    strokeWidth: 0,
                    lockRotation: true,
                    itemId: itemId,
                    selectable: false,
                    fill: '#ffffff',
                    opacity: 0.001
                });
                pathObj.setCoords();
                $timeout(function(){
                    obj.set({
                        clipPath: pathObj,
                        perPixelTargetFind: true,
                        centeredScaling: true,
                        maskId: itemId
                    });
                    $scope.stages[$scope.currentStage].states.isMasked = true;
                    $scope.updateMaskLayer();
                    $scope.updateLayersList();
                    $scope.renderStage();
                });
            }
        };
        $scope.removeClippingMask = function(obj, needreRender, withoutRemoveMask){
            var stage = $scope.stages[$scope.currentStage],
            _canvas = stage['canvas'];
            obj = obj ? obj : _canvas.getActiveObject();
            if( !!obj.get('maskId') ){
                var maskLayerInsex = $scope.getLayerById( obj.get('maskId') ),
                maskLayer = _canvas.item( maskLayerInsex );
                !withoutRemoveMask && _canvas.remove( maskLayer );
            }
            $scope.stages[$scope.currentStage].states.isMasked = false;
            obj.maskId = null;
            obj.clipPath = null;
            obj.perPixelTargetFind = false;
            if( $scope.settings.nbdesigner_object_center_scaling == 'no' ){
                obj.centeredScaling = false;
            }
            needreRender = angular.isDefined(needreRender) ? needreRender : true;
            $scope.updateMaskLayer();
            needreRender && $scope.renderStage();
            $scope.updateLayersList();
        };
        $scope.editMask = function(){
            var stage = $scope.stages[$scope.currentStage],
            _canvas = stage['canvas'],
            obj = _canvas.getActiveObject();
            if( obj ){
                var maskId = obj.get("maskId"),
                maskObjIndex = $scope.getLayerById( maskId ),
                maskLayer = _canvas.item( maskObjIndex );
                obj.moveTo( maskObjIndex );
                maskLayer.set({selectable: true, hasRotatingPoint: false});
                _canvas.setActiveObject(maskLayer);
                $scope.ctxMenuStyle.visibility = 'hidden';
                $scope.updateApp();
            }
        };
        $scope.replaceMaskedImage = function(){
            $timeout(function(){
                jQuery('#nav-photos').triggerHandler('click');
                $timeout(function(){
                    if( jQuery('#tab-photo .result-loaded').hasClass('loaded') ){
                        jQuery('[data-type="image-upload"]').click();
                        $timeout(function(){
                            jQuery('[data-type="image-upload"]').click();
                        }, 400);
                    }else{
                        jQuery('[data-type="image-upload"]').click();
                    }
                }, 400);
            });
        };
        $scope.detachImage = function(){
            var stage = $scope.stages[$scope.currentStage],
            _canvas = stage['canvas'],
            obj = _canvas.getActiveObject();
            if( obj ){
                var maskId = obj.get("maskId"),
                maskObjIndex = $scope.getLayerById( maskId ),
                maskLayer = _canvas.item( maskObjIndex ),
                maskedLayerInsex = $scope.getLayerById( obj.get('itemId') ),
                defaultMaskImageUrl = $scope.settings.assets_url + 'images/placeholder.png';
                fabric.Image.fromURL(defaultMaskImageUrl, function(op) {
                    $scope.contextAddLayers = 'addMask';
                    var top = maskLayer.get('top'),
                    left = maskLayer.get('left'),
                    scaleX = maskLayer.get('scaleX'),
                    scaleY = maskLayer.get('scaleY'),
                    width = maskLayer.get('width'),
                    height = maskLayer.get('height'),
                    realWidth = width * scaleX,
                    realHeight = height * scaleY,
                    newWidth = realWidth,
                    newHeight = realHeight;
                    if( ( op.width / op.height ) > ( realWidth / realHeight ) ){
                        newWidth = op.width / op.height * newHeight;
                    }else{
                        newHeight = op.height / op.width * newWidth;
                    }
                    var d = new Date(),
                    itemId = d.getTime() + Math.floor(Math.random() * 1000);
                    op.set({
                        clipPath: maskLayer,
                        perPixelTargetFind: true,
                        centeredScaling: true,
                        maskId: maskId,
                        scaleX: newWidth / op.width,
                        scaleY: newHeight / op.height,
                        top: top + realHeight / 2,
                        left: left + realWidth / 2,
                        itemId: itemId,
                        isEmptyMask: true,
                        srcChanged: false
                    });
                    $scope.deactiveAllLayer();
                    $scope.removeClippingMask( obj, false, true );
                    _canvas.add(op);
                    op.moveTo( maskedLayerInsex );
                    $timeout(function(){
                        obj.set({
                            top: obj.get('top') + 20,
                            left: obj.get('left') + 20
                        });
                        obj.moveTo( maskedLayerInsex + 1 );
                        _canvas.setActiveObject(obj);
                        $scope.updateMaskLayer();
                        $scope.renderStage();
                    });
                }, {crossOrigin: 'anonymous'});
            }
        };
        $scope.exitMaskMode = function(){
            $scope.deactiveAllLayer();
            $scope.updateMaskLayer();
            $scope.renderStage();
        };
        $scope.masks = [
            "M 12 4.248 c -3.148 -5.402 -12 -3.825 -12 2.944 c 0 4.661 5.571 9.427 12 15.808 c 6.43 -6.381 12 -11.147 12 -15.808 c 0 -6.792 -8.875 -8.306 -12 -2.944 Z",
            "M 18 1 l -6 4 l -6 -4 l -6 5 v 7 l 12 10 l 12 -10 v -7 Z",
            "M 12 0 c -2.995 2.995 -7.486 4 -11 4 c 0 8.583 5.068 16.097 11 20 c 5.932 -3.903 11 -11.417 11 -20 c -3.514 0 -8.005 -1.005 -11 -4 Z",
            "M 1 4 c 0 8.578 5.071 16.1 11 20 c 5.929 -3.9 11 -11.422 11 -20 c -2.828 -2.329 -7.153 -4 -11 -4 c -3.838 0 -8.172 1.671 -11 4 Z",
            "M 12.01 21.49L23.64 7c-.45-.34-4.93-4-11.64-4C5.28 3 .81 6.66.36 7l11.63 14.49.01.01.01-.01 Z",
            "M 12 0 l 2.139 2.629 l 3.068 -1.441 l 0.786 3.297 l 3.389 0.033 l -0.722 3.312 l 3.039 1.5 l -2.088 2.67 l 2.088 2.67 l -3.039 1.5 l 0.722 3.312 l -3.389 0.033 l -0.786 3.297 l -3.068 -1.441 l -2.139 2.629 l -2.139 -2.629 l -3.068 1.441 l -0.786 -3.297 l -3.389 -0.033 l 0.722 -3.312 l -3.039 -1.5 l 2.088 -2.67 l -2.088 -2.67 l 3.039 -1.5 l -0.722 -3.312 l 3.389 -0.033 l 0.786 -3.297 l 3.068 1.441 Z",
            "M 0.000 16.000 L 12.000 20.785 L 13.856 8.000 L 24.000 0.000 L 13.856 -8.000 L 12.000 -20.785 L 0.000 -16.000 L -12.000 -20.785 L -13.856 -8.000 L -24.000 0.000 L -13.856 8.000 L -12.000 20.785 Z",
            "M 12 0.587 l 3.668 7.568 l 8.332 1.151 l -6.064 5.828 l 1.48 8.279 l -7.416 -3.967 l -7.417 3.967 l 1.481 -8.279 l -6.064 -5.828 l 8.332 -1.151 Z",
            "M 24 16.971 l -7.029 7.029 h -9.942 l -7.029 -7.029 v -9.942 l 7.029 -7.029 h 9.942 l 7.029 7.029 Z",
            "M0 0 L24 0 L12 20.78Z",
            "M-12,0a12,12 0 1,0 24,0a12,12 0 1,0 -24,0Z",
            "M 9 0 c -5 0 -9 7 -9 14 c 0 5 3 10 9 10 c 6 0 9 -5 9 -10 c 0 -7 -4 -14 -9 -14 Z",
            "M10,10 h20 a2,2 0 0 0.1 2,2 v20 a2,2 0 0 0.1 -2,2 h-20 a2,2 0 0 0.1 -2,-2 v-20 a2,2 0 0 0.1 2,-2 Z",
            "M 0.054 23 c 0.971 -1.912 2.048 -4.538 1.993 -6.368 c -1.308 -1.562 -2.047 -3.575 -2.047 -5.625 c 0 -5.781 5.662 -10.007 12 -10.007 c 6.299 0 12 4.195 12 10.007 c 0 6.052 -6.732 11.705 -15.968 9.458 c -1.678 1.027 -5.377 2.065 -7.978 2.535 Z",
            "M21.99 4c0-1.1-.89-2-1.99-2H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h14l4 4-.01-18z",
            "M0 0 L24 0 L24 24 L0 24Z",
            "M17 3H7c-1.1 0-2 .9-2 2v16l7-3 7 3V5c0-1.1-.9-2-2-2z",
            "M17.63 5.84C17.27 5.33 16.67 5 16 5L5 5.01C3.9 5.01 3 5.9 3 7v10c0 1.1.9 1.99 2 1.99L16 19c.67 0 1.27-.33 1.63-.84L22 12l-4.37-6.16z", 
            "M5.94 18.99H15c.65 0 1.26-.31 1.63-.84l3.95-5.57c.25-.35.25-.81 0-1.16l-3.96-5.58C16.26 5.31 15.65 5 15 5H5.94c-.81 0-1.28.93-.81 1.59L9 12l-3.87 5.41c-.47.66 0 1.58.81 1.58z",
            "M20.5 11H19V7c0-1.1-.9-2-2-2h-4V3.5C13 2.12 11.88 1 10.5 1S8 2.12 8 3.5V5H4c-1.1 0-1.99.9-1.99 2v3.8H3.5c1.49 0 2.7 1.21 2.7 2.7s-1.21 2.7-2.7 2.7H2V20c0 1.1.9 2 2 2h3.8v-1.5c0-1.49 1.21-2.7 2.7-2.7s2.7 1.21 2.7 2.7V22H17c1.1 0 2-.9 2-2v-4h1.5c1.38 0 2.5-1.12 2.5-2.5S21.88 11 20.5 11z",
            "M19.35 10.04C18.67 6.59 15.64 4 12 4 9.11 4 6.6 5.64 5.35 8.04 2.34 8.36 0 10.91 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96z",
            "M13.2 7.07L10.25 11l2.25 3c.33.44.24 1.07-.2 1.4-.44.33-1.07.25-1.4-.2-1.05-1.4-2.31-3.07-3.1-4.14-.4-.53-1.2-.53-1.6 0l-4 5.33c-.49.67-.02 1.61.8 1.61h18c.82 0 1.29-.94.8-1.6l-7-9.33c-.4-.54-1.2-.54-1.6 0z",
            "M6.05,8.05c-2.73,2.73-2.73,7.15-0.02,9.88c1.47-3.4,4.09-6.24,7.36-7.93c-2.77,2.34-4.71,5.61-5.39,9.32 c2.6,1.23,5.8,0.78,7.95-1.37c2.99-2.99,3.83-11.14,4.01-13.38c0.02-0.31-0.23-0.56-0.53-0.53C17.19,4.22,9.04,5.06,6.05,8.05z",
            "M12.43 2.3c-2.38-.59-4.68-.27-6.63.64-.35.16-.41.64-.1.86C8.3 5.6 10 8.6 10 12c0 3.4-1.7 6.4-4.3 8.2-.32.22-.26.7.09.86 1.28.6 2.71.94 4.21.94 6.05 0 10.85-5.38 9.87-11.6-.61-3.92-3.59-7.16-7.44-8.1z",
            "M7 2v11h3v9l7-12h-4l3-8z"
        ];
        $scope.addImageFromUrl = function( dataImg, extenal, ilr, maskId ){
            var url = typeof dataImg == 'object' ? dataImg.url : dataImg;
            if( url == '' ) return;
            $scope.toggleStageLoading();
            $scope.showDesignTab();
            if(url.match(/\.(svg)$/) != null ){
                var art = {url: url, name: ''};
                $scope.addArt(art, false, true);
                return
            };
            if( $scope.resource.addImageContext == 'manual' ){
                var stage = $scope.stages[$scope.currentStage],
                    _canvas = stage['canvas'],
                    object = _canvas.getActiveObject();
                if( !!object && !!object.get('maskId') ){
                    maskId = object.get('maskId');
                }
            }
            $scope.resource.upload.ilr = true;
            if( angular.isDefined( maskId ) ){
                $scope.addImage(dataImg, false, true, false, false, maskId);
            }else{
                $scope.addImage(dataImg, false, true);
            }
            $scope.resource.addImageContext = '';
        };
        $scope.removeImageFilters = function(){
            var _canvas = $scope.stages[$scope.currentStage]['canvas'];
            var object = _canvas.getActiveObject();
            if( object && ( object.type == 'image' || object.type == 'custom-image' ) ){
                object.filters = [];
                object.applyFilters(false, function(){
                    setTimeout(() => $scope.renderStage());
                });
                $scope.stages[$scope.currentStage].states.filters = [];
            }
        };
        $scope.addImageFilter = function( type ){
            var _canvas = $scope.stages[$scope.currentStage]['canvas'];
            var object = _canvas.getActiveObject();
            if( object && ( object.type == 'image' || object.type == 'custom-image' ) ){
                var filter = new fabric.Image.filters.CustomFilter({
                    jOptions: '{"type":"' + type + '"}'
                });

                var index;
                object.filters.forEach(function(filter, _index) { 
                    var options = JSON.parse( filter.jOptions );
                    if( options.type == type ) index = _index;
                });
                if( angular.isDefined( index ) ){
                    /* 
                        //to modify filter
                        object.filters[index] = filter; 
                    */
                    object.filters.splice( index, 1 );
                    $scope.stages[$scope.currentStage].states.filters[type] = false;
                }else{
                    object.filters.push( filter );
                    $scope.stages[$scope.currentStage].states.filters[type] = true;
                }

                object.applyFilters(false, function(){
                    setTimeout(() => $scope.renderStage());
                });
            }
        };
        /* Get Image */
        $scope.getPhoto = function(type, context){ 
            if( $scope.resource.photo.type != type || context == 'search' ){
                $scope.resource.photo.data = [];
                $scope.resource.photo.filter.total = 0;
                $scope.resource.photo.filter.currentPage = 1;
                jQuery("#tab-photo .tab-scroll").stop().animate({
                    scrollTop: jQuery('#tab-photo .main-items').height()
                }, 100);
                jQuery('#nbdesigner-gallery').css('height', 0);
            };
            $scope.resource.photo.type = type;
            if( $scope.resource.photo.type == '' ) return;
            jQuery('#tab-photo .loading-photo').show();
            if( $scope.resource.photo.filter.totalPage == 0 || $scope.resource.photo.filter.currentPage <= $scope.resource.photo.filter.totalPage ){
                switch(type){
                    case 'Pixabay':
                        $http({
                            method: 'GET',
                            url: 'https://pixabay.com/api/?safesearch=true&key='+ $scope.settings.nbdesigner_pixabay_api_key +'&response_group=high_resolution&image_type=photo&per_page='+$scope.resource.photo.filter.perPage+'&page='+$scope.resource.photo.filter.currentPage+'&q='+encodeURIComponent($scope.resource.photo.photoSearch)
                        }).then(function successCallback(response) {
                            var data = response.data,
                            totalPage = Math.ceil(data.totalHits/$scope.resource.photo.filter.perPage);
                            $scope.resource.photo.filter.totalPage = totalPage > 10 ? 10 : totalPage;
                            _.each(data.hits, function(val, key) {
                                $scope.resource.photo.data.push({
                                    extenal: 1,
                                    url: angular.isDefined(val.fullHDURL) ? val.fullHDURL : ( angular.isDefined(val.largeImageURL) ? val.largeImageURL : val.imageURL ),
                                    preview: val.previewURL,
                                    des: '@ ' +val.user
                                });
                            });
                            $scope.afterGetResource('photo');
                        }, function errorCallback(response) {
                            console.log('Pixabay');
                            jQuery('#tab-photo .loading-photo').hide();
                        });
                        break;
                    case 'Unsplash':
                        var url = $scope.resource.photo.photoSearch != '' ? 'https://api.unsplash.com/search/photos/?client_id='+ $scope.settings.nbdesigner_unsplash_api_key +'&per_page='+$scope.resource.photo.filter.perPage+'&page='+$scope.resource.photo.filter.currentPage+'&query='+encodeURIComponent($scope.resource.photo.photoSearch) : 'https://api.unsplash.com/photos/?client_id='+ $scope.settings.nbdesigner_unsplash_api_key +'&per_page=20&page='+$scope.resource.photo.filter.currentPage+'&order_by=latest';
                        $http({
                            method: 'GET',
                            url: url
                        }).then(function successCallback(response) {
                            var data = response.data;
                            if( $scope.resource.photo.photoSearch != '' ){
                                $scope.resource.photo.filter.totalPage = data.total_pages > 10 ? 10 : data.total_pages;
                                var results = data.results;
                            }else{
                                $scope.resource.photo.filter.totalPage = 10;
                                var results = data;
                            }
                            _.each(results, function(val, key) {
                                $scope.resource.photo.data.push({
                                    extenal: 1,
                                    url: val.urls.regular,
                                    preview: val.urls.thumb,
                                    des: '@ '+val.user.name
                                });
                            });
                            $scope.afterGetResource('photo');
                        }, function errorCallback(response) {
                            console.log('Unsplash');
                            jQuery('#tab-photo .loading-photo').hide();
                        }); 
                        break;
                    case 'Pexels':
                        var url = $scope.resource.photo.photoSearch != '' ? 'https://api.pexels.com/v1/search?query=' + encodeURIComponent( $scope.resource.photo.photoSearch ) + '&per_page='+$scope.resource.photo.filter.perPage + '&page=' + $scope.resource.photo.filter.currentPage : 'https://api.pexels.com/v1/curated?' + 'per_page=' + $scope.resource.photo.filter.perPage + '&page='+$scope.resource.photo.filter.currentPage;
                        $http({
                            method: 'GET',
                            url: url,
                            headers: {
                                'Authorization': $scope.settings.nbdesigner_pexels_api_key
                            }
                        }).then(function successCallback(response) {
                            var data = response.data,
                            totalPage = angular.isDefined(data.total_results) ? Math.ceil(data.total_results/$scope.resource.photo.filter.perPage) : 1;
                            $scope.resource.photo.filter.totalPage = totalPage > 10 ? 10 : totalPage;
                            _.each(data.photos, function(val, key) {
                                $scope.resource.photo.data.push({
                                    extenal: 1,
                                    url: val.src.large,
                                    preview: val.src.tiny,
                                    des: '@ ' +val.photographer
                                });
                            });
                            $scope.afterGetResource('photo');
                        }, function errorCallback(response) {
                            console.log('Pexels');
                            jQuery('#tab-photo .loading-photo').hide();
                        }); 
                        break;
                    case 'Freepik':
                        var url = 'https://editor.freepiklabs.com/api/images/freepik?query=' + encodeURIComponent( $scope.resource.photo.photoSearch ) + '&page=' + $scope.resource.photo.filter.currentPage;
                        $http({
                            method: 'GET',
                            url: url
                        }).then(function successCallback(response) {
                            var data = response.data,
                            totalPage = data.paging.total;
                            $scope.resource.photo.filter.totalPage = totalPage > 10 ? 10 : totalPage;
                            _.each(data.resources, function(val, key) {
                                $scope.resource.photo.data.push({
                                    extenal: 1,
                                    url: val.large,
                                    preview: val.small,
                                    des: 'Freepik'
                                });
                            });
                            $scope.afterGetResource('photo');
                        }, function errorCallback(response) {
                            console.log('Freepik');
                            jQuery('#tab-photo .loading-photo').hide();
                        }); 
                        break;
                }
            };
            $scope.updateApp();
        };
        /* Crop */
        $scope.cropObj = {status: false};
        $scope.initCrop = function(){
            $scope.cropObj.status = true;
            jQuery('.nbd-popup.popup-nbd-crop').nbShowPopup();
            $scope.cropObj.src = $scope.stages[$scope.currentStage].states.origin_src;
            $scope.cropObj.origin_url = $scope.stages[$scope.currentStage].states.origin_url;
            jQuery('.nbd-popup.popup-nbd-crop .overlay-popup').addClass('nbo-disable');
            jQuery('.nbd-popup.popup-nbd-crop').find('.overlay-main').removeClass('active');
            var img = new Image();
            img.src = $scope.cropObj.src;
            img.onload = function() {
                $scope.cropObj.width = this.width;
                $scope.cropObj.height = this.height;
                if( $scope.stages[$scope.currentStage].states.origin_width ){
                    $scope.cropObj.width = $scope.stages[$scope.currentStage].states.origin_width;
                    $scope.cropObj.height = $scope.stages[$scope.currentStage].states.origin_height;
                }
                $timeout(function(){
                    $scope.cropObj.canvas = $scope.cropObj.canvas ? $scope.cropObj.canvas : new FabricWindow.Canvas('crop-handle-wrap');
                    var width = jQuery('#crop-source').width(),
                        height = jQuery('#crop-source').height();
                    $scope.cropObj.canvas.setDimensions({'width' : width, 'height' : height});
                    $scope.cropObj.canvas.clear();
                    $scope.cropObj.canvas.on('mouse:down', function(e) {
                        $scope.cropObj.canvas.item(0);
                    });
                    $scope.cropObj.canvas.on('object:modified', function( options ){
                        var obj = options.target;
                        var boundingRect = obj.getBoundingRect(true);
                        if (boundingRect.left < 0) obj.left = 0;
                        if (boundingRect.top < 0) obj.top = 0;
                        obj.setCoords();boundingRect = obj.getBoundingRect(true);
                        var left = boundingRect.left > 0 ? boundingRect.left : 0,
                            top = boundingRect.top > 0 ? boundingRect.top : 0;
                        if (boundingRect.left + boundingRect.width > $scope.cropObj.canvas.getWidth() ){
                            obj.scaleX = obj.scaleX * ( ( $scope.cropObj.canvas.getWidth() - left ) / boundingRect.width );
                        }
                        if( boundingRect.top + boundingRect.height > $scope.cropObj.canvas.getHeight() ){
                            obj.scaleY = obj.scaleY * ( ( $scope.cropObj.canvas.getHeight() - top ) / boundingRect.height );
                        };
                        obj.setCoords();
                    });
                    var rect = new fabric.Rect({
                        left: 0,
                        top: 0,
                        fill: 'rgba(255,255,255,0.15)',
                        width: 200,
                        height: 200,
                        strokeWidth: 1,
                        stroke: '#ffffff',
                        strokeDashArray: [5, 5]
                    });
                    if( angular.isDefined($scope.stages[$scope.currentStage].states.crop_left) ){
                        rect.set({
                            left: $scope.stages[$scope.currentStage].states.crop_left,
                            top: $scope.stages[$scope.currentStage].states.crop_top,
                            width: $scope.stages[$scope.currentStage].states.crop_width,
                            height: $scope.stages[$scope.currentStage].states.crop_height,
                            scaleX: $scope.stages[$scope.currentStage].states.crop_scaleX,
                            scaleY: $scope.stages[$scope.currentStage].states.crop_scaleY
                        });
                    };
                    $scope.cropObj.canvas.add(rect);
                    var item = $scope.cropObj.canvas.item(0);
                    item.setControlVisible('mtr', false);
                    $scope.cropObj.canvas.setActiveObject(item);
                    if( angular.isUndefined($scope.stages[$scope.currentStage].states.crop_left) ){
                        $scope.cropObj.canvas.viewportCenterObject(item);
                    }
                }, 100);
            };
        };
        // Chưa có Api để crop
        $scope.cropImage = function(){
            function add_image( url ){
                fabric.Image.fromURL(url, function(op) {
                    var stage = $scope.stages[$scope.currentStage],
                        _canvas = stage['canvas'];
                    var object = _canvas.getActiveObject(),
                    element = object.getElement();
                    $scope.beforeObjectModify(object);
                    element.setAttribute("src", url);
                    object.set({
                        origin_src: $scope.cropObj.src, 
                        crop_left: $scope.cropObj.bound.left,
                        crop_top: $scope.cropObj.bound.top,
                        crop_width: $scope.cropObj.bound.width,
                        crop_height: $scope.cropObj.bound.height,
                        crop_scaleX: $scope.cropObj.bound.scaleX,
                        crop_scaleY: $scope.cropObj.bound.scaleY,
                        cropped: 1
                    });
                    $scope.cropObj.bound = {};
                    _canvas.getActiveObject().set({
                        dirty: true,
                        width: op.width,
                        height: op.height,
                        scaleX: object.width * object.scaleX / op.width,
                        scaleY: object.width * object.scaleX / op.width
                    });
                    object.setCoords();

                    if( $scope.checkActiveFilter && object.filters.length ){
                        object._originalElement = op._element;
                        object.applyFilters(false, function(){
                            setTimeout(() => $scope.renderStage(), 200);
                        }, true);
                    } else {
                        $scope.renderStage();
                        $timeout(function(){
                            $scope.renderStage();
                        }, 100);
                    }

                    $scope.getCurrentLayerInfo();
                    $scope.afterObjectModify();
                    jQuery('.nbd-popup.popup-nbd-crop').find('.overlay-main').removeClass('active');
                    jQuery('.nbd-popup.popup-nbd-crop .close-popup').triggerHandler('click');
                }, {crossOrigin: 'anonymous'});
            }
            var bound = $scope.cropObj.canvas.item(0).getBoundingRect(true),
                imgScale = $scope.cropObj.width / $scope.cropObj.canvas.width;
            $scope.cropObj.bound = {
                left: $scope.cropObj.canvas.item(0).get('left'),
                top: $scope.cropObj.canvas.item(0).get('top'),
                width: $scope.cropObj.canvas.item(0).get('width'),
                height: $scope.cropObj.canvas.item(0).get('height'),
                scaleX: $scope.cropObj.canvas.item(0).get('scaleX'),
                scaleY: $scope.cropObj.canvas.item(0).get('scaleY')
            };
            var fd = new FormData();
            // fd.append('nonce', NBDESIGNCONFIG['nonce']);
            fd.append('nonce', 'f65e05b30a');
            fd.append('action', 'nbd_crop_image');
            fd.append('url', $scope.cropObj.src);
            if( $scope.cropObj.origin_url ){
                fd.set('url', $scope.cropObj.origin_url);
            }
            fd.append('startX', bound.left * imgScale);
            fd.append('startY', bound.top * imgScale);
            fd.append('width', bound.width * imgScale);
            fd.append('height', bound.height * imgScale);
            jQuery('.nbd-popup.popup-nbd-crop').find('.overlay-main').addClass('active');

            add_image('https://botaksign-dev.s3.us-east-1.amazonaws.com/uploads/yamaha-r6.jpg'); // fake data crop Image
        };
        $scope.addMask = function( shapeIndex ){
            var stage = $scope.stages[$scope.currentStage],
            _canvas = stage['canvas'],
            scale = stage.states.scaleRange[stage.states.currentScaleIndex].ratio,
            max_width = _canvas.width / scale * .3,
            max_height = _canvas.height / scale * .3,
            new_width = max_width;
            var pathCommand = shapeIndex > -1 ? $scope.masks[ shapeIndex ] : $scope.pathCommand;
            if( pathCommand == '' ) return;

            var path = new fabric.Path( pathCommand );
            var width_ratio = new_width / path.width,
            new_height = path.height * width_ratio;
            if (new_height > max_height) {
                new_height = max_height;
                var height_ratio = new_height / path.height;
                new_width = path.width * height_ratio;
            }
            path.scaleToWidth(new_width);
            path.scaleToHeight(new_height);
            path.set({
                isTemMask: true,
                fill: '#dddddd'
            });
            _canvas.add(path);
        };
        $scope.addPhotoFrame = function( frame ){
            var url = '//dpeuzbvf3y4lr.cloudfront.net/frames/svg/s' + ( frame + 1 ) + '.svg',
            defaultImageUrl = $scope.settings.assets_url + 'images/frame-bg.jpg',
            stage = $scope.stages[$scope.currentStage],
            _canvas = stage['canvas'],
            scale = stage.states.scaleRange[stage.states.currentScaleIndex].ratio,
            max_width = _canvas.width / scale * .3,
            max_height = _canvas.height / scale * .3,
            new_width = max_width;

            $scope.toggleStageLoading();

            function onFail(){
                $scope.toggleStageLoading();
            }

            fabric.loadSVGFromURL(url, function(ob, op) {
                if( ob ){
                    $scope.contextAddLayers = 'addMask';
                    var d = new Date(),
                    itemId = d.getTime() + Math.floor(Math.random() * 1000);

                    if (op.width < max_width) new_width = op.width;
                    var width_ratio = new_width / op.width,
                    new_height = op.height * width_ratio;
                    if (new_height > max_height) {
                        new_height = max_height;
                        var height_ratio = new_height / op.height;
                        new_width = op.width * height_ratio;
                    }
                    var object = fabric.util.groupSVGElements(ob, op);
                    object.scaleToWidth(new_width);
                    object.scaleToHeight(new_height);

                    object.set({
                        itemId: itemId,
                        isMask: 1,
                        absolutePositioned: true,
                        strokeWidth: 0,
                        lockRotation: true,
                        selectable: false,
                        fill: '#ffffff',
                        opacity: 0.001
                    });

                    _canvas.add(object);

                    $timeout(function(){
                        $scope.contextAddLayers = 'addMask';
                        var maskLayer = _canvas.item(_canvas.getObjects().length - 1);
                        _canvas.viewportCenterObject(maskLayer);
                        fabric.Image.fromURL(defaultImageUrl, function(op) {
                            var top = maskLayer.get('top'),
                            left = maskLayer.get('left'),
                            scaleX = maskLayer.get('scaleX'),
                            scaleY = maskLayer.get('scaleY'),
                            width = maskLayer.get('width'),
                            height = maskLayer.get('height'),
                            realWidth = width * scaleX,
                            realHeight = height * scaleY,
                            newWidth = realWidth,
                            newHeight = realHeight;
                            if( ( op.width / op.height ) > ( realWidth / realHeight ) ){
                                newWidth = op.width / op.height * newHeight;
                            }else{
                                newHeight = op.height / op.width * newWidth;
                            }
                            op.set({
                                clipPath: maskLayer,
                                perPixelTargetFind: true,
                                centeredScaling: true,
                                maskId: itemId,
                                scaleX: newWidth / op.width,
                                scaleY: newHeight / op.height,
                                top: top + realHeight / 2,
                                left: left + realWidth / 2,
                                isEmptyMask: true,
                                srcChanged: false
                            });
                            _canvas.add(op);
                            $scope.toggleStageLoading();
                        });
                    }, 100);
                }else{
                    onFail();
                }
            });
        };
        $scope.addFrame = function(frame){
            var rows = frame.areas.match(/[^"]+(?=(" ")|"$)/g),
                numCols = rows[0].split(" ").length,
                numRows = rows.length,
                colWidths = [],
                rowHeights = [];
            if( frame.columns != '' ){
                colWidths = frame.columns.replace(/fr/g, '').split(" ").map(function(col){
                    return 1 * col;
                });
            }else{
                for(var i=0; i< numCols; i++){
                    colWidths.push(1);
                }; 
            }
            if( frame.rows != '' ){
                rowHeights = frame.rows.replace(/fr/g, '').split(" ").map(function(col){
                    return 1 * col;
                });
            }else{
                rows.forEach(function(){
                    rowHeights.push(1);
                }); 
            }
            var totalWidth = colWidths.reduce((accumulator, currentValue, currentIndex, array) => {
                return accumulator + currentValue;
            });
            var totalHeight = rowHeights.reduce((accumulator, currentValue, currentIndex, array) => {
                return accumulator + currentValue;
            });
            var panels = {};
            rows.forEach(function(row, idx){
                var rowArr = row.split(" ");
                rowArr.forEach(function(r, i){
                    if( typeof panels[r] == 'undefined' ){
                        panels[r] = {
                            x: i,
                            y: idx,
                            colWidth: colWidths[i],
                            rowHeight: rowHeights[idx],
                            rows: [idx],
                            columns: [i]
                        };
                    }else{
                        if( panels[r].rows.indexOf( idx ) == -1 ){
                            panels[r].rowHeight += rowHeights[idx];
                            panels[r].rows.push(idx);
                        }
                        if( panels[r].columns.indexOf( i ) == -1 ){
                            panels[r].colWidth += colWidths[i];
                            panels[r].columns.push(i);
                        }
                    }
                });
            });
            var stage = $scope.stages[$scope.currentStage],
            _canvas = stage['canvas'],
            gap = 2,
            cellWidth = ( _canvas.width - gap * ( totalWidth - 1 ) ) / totalWidth,
            cellHeight = ( _canvas.height - gap * ( totalHeight - 1 ) ) / totalHeight;
            var url = $scope.settings.assets_url + 'images/frame-bg.jpg';
            angular.forEach(panels, function(panel, key) {
                $scope.contextAddLayers = 'addMask';
                var d = new Date(),
                itemId = d.getTime() + Math.floor(Math.random() * 1000);
                var colLeft = 0, rowTop = 0;
                for(var i = 0; i < colWidths.length; i++){
                    if( i < panel.x ){
                        colLeft += colWidths[i];
                    }
                }
                for(var i = 0; i < rowHeights.length; i++){
                    if( i < panel.y ){
                        rowTop += rowHeights[i];
                    }
                }
                var path = new fabric.Path( $scope.masks[15]);
                path.set({
                    top: rowTop * ( cellHeight + gap ),
                    left: colLeft * ( cellWidth + gap ),
                    scaleX: ( panel.colWidth * cellWidth + ( panel.colWidth - 1 ) * gap ) / path.get('width'),
                    scaleY: ( panel.rowHeight * cellHeight + ( panel.rowHeight - 1 ) * gap ) / path.get('height'),
                    isMask: 1,
                    itemId: itemId,
                    absolutePositioned: true,
                    strokeWidth: 0,
                    lockRotation: true,
                    selectable: false,
                    fill: '#ffffff',
                    opacity: 0.001
                });
                panel.itemId = itemId;
                _canvas.add(path);
            });
            angular.forEach(panels, function(panel, key) {
                fabric.Image.fromURL(url, function(op) {
                    $scope.contextAddLayers = 'addMask';
                    var mask = $scope.getMaskLayer( panel.itemId ),
                    top = mask.get('top'),
                    left = mask.get('left'),
                    scaleX = mask.get('scaleX'),
                    scaleY = mask.get('scaleY'),
                    width = mask.get('width'),
                    height = mask.get('height'),
                    realWidth = width * scaleX,
                    realHeight = height * scaleY,
                    newWidth = realWidth,
                    newHeight = realHeight;
                    if( ( op.width / op.height ) > ( realWidth / realHeight ) ){
                        newWidth = op.width / op.height * newHeight;
                    }else{
                        newHeight = op.height / op.width * newWidth;
                    }
                    var d = new Date(),
                    itemId = d.getTime() + Math.floor(Math.random() * 1000);
                    op.set({
                        clipPath: mask,
                        perPixelTargetFind: true,
                        centeredScaling: true,
                        maskId: panel.itemId,
                        scaleX: newWidth / op.width,
                        scaleY: newHeight / op.height,
                        top: top + realHeight / 2,
                        left: left + realWidth / 2,
                        itemId: itemId,
                        isEmptyMask: true,
                        srcChanged: false
                    });
                    _canvas.add(op);
                }, {crossOrigin: 'anonymous'});
            });
        };
        /* Layer */
        $scope.getMaskLayer = function(itemId){
            var _canvas = this.stages[this.currentStage].canvas;
            var layer;
            _canvas.forEachObject(function(obj, index) {
                if(obj.get('itemId') == itemId) layer = obj;
            });
            return layer;
        };
        $scope.getMaskedLayerByMaskId = function( maskId, stageId ){
            stageId = stageId ? stageId : $scope.currentStage;
            var _canvas = this.stages[stageId].canvas;
            var layer;
            _canvas.forEachObject(function(obj, index) {
                if(obj.get('maskId') == maskId) layer = obj;
            });
            return layer;
        };
        $scope.closePopupClearAllStages = function(){
            jQuery('.clear-all-stage-alert .close-popup').triggerHandler('click');
        };
        $scope.zoomStage = function(index, stage_id){
            stage_id = angular.isDefined(stage_id) ? stage_id : $scope.currentStage;
            var _stage = $scope.stages[stage_id],
               _canvas = _stage['canvas'];
            _stage.states.isShowToolBox = true;
            _stage.states.currentScaleIndex = index;
            _stage.states.corners = [];
            $scope.setStageDimension(stage_id);
            _canvas.setZoom(_stage.states.scaleRange[_stage.states.currentScaleIndex].ratio);
            jQuery('#stage-container-'+$scope.currentStage).stop().animate({
                scrollTop: 0,
                scrollLeft: 0
            }, 100);
            jQuery('#stage-container-'+$scope.currentStage).perfectScrollbar('update');
            if( appConfig.isVisual ) $scope.deactiveAllLayer();
            this.renderStage();
            if( $scope.settings.showRuler && appConfig.isModern ){
                _stage.hozRuler.update({config: _stage.config, zoomRatio: _stage.states.scaleRange[_stage.states.currentScaleIndex].ratio});
                _stage.verRuler.update({config: _stage.config, zoomRatio: _stage.states.scaleRange[_stage.states.currentScaleIndex].ratio});
            };

            // $timeout(function(){
            //     $scope.processAreaDesignShape(stage_id);
            // });
        };
        $scope.setStackLayerAlwaysOnBottom = function(maybeRender){
            var _canvas = $scope.stages[$scope.currentStage]['canvas'];
            _canvas.forEachObject(function(obj) {
                if( obj.isBgImg ){
                    obj.sendToBack();
                }
            });
            if(maybeRender) $scope.renderStage();
        };
        $scope.setStackLayerAlwaysOnTop = function(maybeRender){
            var _canvas = $scope.stages[$scope.currentStage]['canvas'];
            _canvas.forEachObject(function(obj) {
                if( obj.isAlwaysOnTop ){
                    obj.bringToFront();
                }
            });
            if(maybeRender) $scope.renderStage();
        };
        $scope.adjustMaskedLayers = function( obj, context ){
            var _canvas = this.stages[$scope.currentStage].canvas;
            function adjustMaskedLayer( item ){
                if( !!item.get('maskId') ){
                    var maskLayerIndex = $scope.getLayerById( item.get('maskId') );
                    if( typeof maskLayerIndex != "undefined" ){
                        var maskLayer = _canvas.item( maskLayerIndex ),
                        maskLeft = maskLayer.get('left'),
                        maskTop = maskLayer.get('top'),
                        maskWidth = maskLayer.get('width') * maskLayer.get('scaleX'),
                        maskHeight = maskLayer.get('height') * maskLayer.get('scaleY'),
                        scaleX = item.get('scaleX'),
                        scaleY = item.get('scaleY'),
                        imWidth = item.get('width'),
                        imHeight = item.get('height'),
                        width = item.get('width') * scaleX,
                        height = item.get('height') * scaleY,
                        left = item.get('left'),
                        top = item.get('top'),
                        realLeft = left - width / 2,
                        realTop = top - height / 2;
                        
                        function lessThan(x, y){
                            var epsilon = 0.00001;
                            return x < y && Math.abs( x - y ) > epsilon;
                        };
                        
                        if( lessThan(width, maskWidth) || lessThan(height, maskHeight) ){
                            if( lessThan(width, maskWidth) ){
                                var _scaleX = maskWidth / item.get('width');
                                item.set({
                                    left: maskLeft + maskWidth / 2,
                                    scaleX: _scaleX
                                });
                                if( imWidth < imHeight && scaleY < _scaleX ){
                                    item.set({
                                        scaleY: _scaleX
                                    });
                                }
                            }
                            if( lessThan(height, maskHeight) ){
                                var _scaleY = maskHeight / item.get('height');
                                item.set({
                                    top: maskTop + maskHeight / 2,
                                    scaleY: _scaleY
                                });
                                if( imWidth > imHeight && scaleX < _scaleY ){
                                    item.set({
                                        scaleX: _scaleY
                                    });
                                }
                            }
                        } else {
                            if( realLeft > maskLeft ){
                                item.set({
                                    left: left - ( realLeft - maskLeft )
                                });
                            }
                            if( realTop > maskTop ){
                                item.set({
                                    top: top - ( realTop - maskTop )
                                });
                            }
                            if( ( realLeft + width ) < ( maskLeft + maskWidth ) ){
                                item.set({
                                    left: left + ( maskLeft + maskWidth - realLeft - width )
                                });
                            }
                            if( ( realTop + height ) < ( maskTop + maskHeight ) ){
                                item.set({
                                    top: top + ( maskTop + maskHeight - realTop - height )
                                });
                            }
                        }
                        item.setCoords();
                    }
                } else if( !!item.get('isMask') ){
                    var maskId = item.get('itemId'),
                    maskedLayer = $scope.getMaskedLayerByMaskId( maskId );
                    if( typeof maskedLayer != "undefined" ){
                        var maskLeft = item.get('left'),
                        maskTop = item.get('top'),
                        maskWidth = item.get('width') * item.get('scaleX'),
                        maskHeight = item.get('height') * item.get('scaleY'),
                        scaleX = maskedLayer.get('scaleX'),
                        scaleY = maskedLayer.get('scaleY'),
                        width = maskedLayer.get('width') * scaleX,
                        height = maskedLayer.get('height') * scaleY,
                        newWidth = width,
                        newHeight = height;
                        if( width < maskWidth || height < maskHeight ){
                            if( ( width / height ) > ( maskWidth / maskHeight ) ){
                                newHeight = maskHeight;
                                newWidth = width / height * newHeight;
                            }else{
                                newWidth = maskWidth;
                                newHeight = height / width * newWidth;
                            }
                        }
                        maskedLayer.set({
                            left: maskLeft + maskWidth / 2,
                            top: maskTop + maskHeight / 2,
                            scaleX: newWidth / maskedLayer.get('width'),
                            scaleY: newHeight / maskedLayer.get('height')
                        });
                        maskedLayer.setCoords();
                    }
                }
            }
            if( obj.type == 'activeSelection' ){
                if( context == 'at' ){
                    // $scope.deactiveAllLayer(); // fix Un-group layer khi click bên trong group
                    obj.forEachObject(function(o) {
                        if( !!o.get('maskId') ) adjustMaskedLayer( o, obj );
                    });
                }
            } else {
                adjustMaskedLayer( obj );
            }
        };
        $scope.deactiveAllLayer = function(stage_id){
            stage_id = angular.isDefined( stage_id ) ? stage_id :  $scope.currentStage;
            $scope.stages[stage_id]['canvas'].discardActiveObject();
            angular.merge($scope.stages[$scope.currentStage].states.uploadZone, {visibility: 'hidden'});
            $scope.updateCorners();
            $scope.renderStage();
            $scope.updateApp();
        };
        $scope.groupLayers = function(){
            var _canvas = $scope.stages[$scope.currentStage]['canvas'],
            activeObject = _canvas.getActiveObject();
            if (activeObject.type === 'activeSelection') {
                $scope.contextAddLayers = 'template';
                activeObject.toGroup();
                $scope.renderStage();
                $scope.getCurrentLayerInfo();
            }
        };
        $scope.unGroupLayers = function(){
            var _canvas = $scope.stages[$scope.currentStage]['canvas'],
            activeObject = _canvas.getActiveObject();
            if (activeObject.type === 'group') {
                $scope.onUnloadGroup = {
                    status: true,
                    remain: activeObject._objects.length,
                    length: activeObject._objects.length
                };
                if( angular.isDefined(activeObject.itemId) ){
                    $scope.onUnloadGroup.prevIndex = $scope.getLayerById(activeObject.itemId);
                }
                $scope.contextAddLayers = 'template';
                activeObject.toActiveSelection();
                $scope.renderStage();
                $scope.getCurrentLayerInfo();
            }
        };
        $scope.canAddMoreLayer = function(){
            $check = true;
            if( $scope.settings.nbdesigner_prevent_add_more_layer == 'yes' ) $check = false;
            return $check;
        };
        $scope.getLayerById = function(itemId){
            var _canvas = this.stages[this.currentStage].canvas;
            var _index;
            _canvas.forEachObject(function(obj, index) {
                if(obj.get('itemId') == itemId) _index = index;
            });
            return _index;
        }; 
        $scope.moveLayer = function( command, alt ){
            var _canvas = this.stages[this.currentStage].canvas,
                items = _canvas.getActiveObjects(),
                selection = _canvas.getActiveObject(),
                step = alt ? 1 : 10;
            if( items.length == 0 ) return;
            angular.merge($scope.stages[$scope.currentStage].states.boundingObject, {visibility: 'hidden'});
            items.forEach(function( item ){
                $scope.beforeObjectModify(item);
                switch(command) {
                    case 'up':
                        if( !item.get("lockMovementY") ) item.set('top', item.get('top') - step);
                        break;
                    case 'down':
                        if( !item.get("lockMovementY") ) item.set('top', item.get('top') + step);
                        break;    
                    case 'left':
                        if( !item.get("lockMovementX") ) item.set('left', item.get('left') - step);
                        break;
                    case 'right':
                        if( !item.get("lockMovementX") ) item.set('left', item.get('left') + step);
                        break;
                };
                item.setCoords();
            });
            if( selection.type === 'activeSelection' ){
                selection.addWithUpdate();
            };
            this.updateApp();
            this.renderStage();
            $scope.afterObjectModify();
        };
        $scope.tempCanvas = null;
        $scope.storeLayers = function(){
            var _canvas = this.stages[$scope.currentStage]['canvas'];
            var item = _canvas.getActiveObjects();
            if(item){
                var bound = _canvas.getActiveObject().getBoundingRect();
                if( jQuery('#temp-canvas-wrap').length == 0 ){
                    var tempCanvasWrap = document.createElement('div');
                    tempCanvasWrap.setAttribute('id', 'temp-canvas-wrap');
                    var canvasEl = document.createElement('canvas');
                    canvasEl.setAttribute('id', 'temp-canvas');
                    tempCanvasWrap.appendChild(canvasEl);
                    document.body.appendChild(tempCanvasWrap);
                    $scope.tempCanvas = new fabric.Canvas("temp-canvas");
                }
                $scope.tempCanvas.setDimensions({'width' : bound.width, 'height' : bound.height});
                $scope.tempCanvas.clear();
                $scope.tempCanvas.renderAll();
                var designData = {
                    used_font: [],
                    design: null,
                    preview: null,
                    tempLayers: []
                };
                var layers = []; var currentIndex = 0;
                _canvas.getActiveObjects().forEach(function( obj ){
                    if( ['i-text', 'text', 'textbox', 'curvedText'].indexOf( obj.type ) > -1  ){
                        var font = $scope.getFontInfo(obj.fontFamily);
                        designData.used_font.push(font);
                    }
                    layers.push( JSON.stringify(obj) );
                });
                function importLayerToTempCanvas( currentIndex ){
                    var object = JSON.parse(layers[currentIndex]);
                    function continueLoadLayer(){
                        var _item = $scope.tempCanvas.item( $scope.tempCanvas.getObjects().length - 1 );
                        designData.tempLayers.push(_item);
                        currentIndex++;
                        if( currentIndex <= (layers.length - 1) ){
                            importLayerToTempCanvas( currentIndex );
                        }else{
                            var selection = new fabric.ActiveSelection(designData.tempLayers, {
                              canvas: $scope.tempCanvas
                            });
                            $scope.tempCanvas.setActiveObject(selection);
                            selection.addWithUpdate();
                            $scope.tempCanvas.viewportCenterObjectH(selection);
                            $scope.tempCanvas.viewportCenterObjectV(selection);
                            $scope.tempCanvas.discardActiveObject().renderAll();
                            $timeout(function(){
                                designData.preview = $scope.tempCanvas.toDataURL();
                                designData.design = $scope.tempCanvas.toJSON($scope.includeExport);
                                var designObj = {
                                    used_font: designData.used_font,
                                    json: designData.design,
                                    width: bound.width,
                                    height: bound.height
                                };
                                var _dataObj = {
                                    type: 'save_user_design',
                                    design: new Blob([JSON.stringify(designObj)], {type: "application/json"}),
                                    preview: $scope.makeblob( designData.preview )
                                };
                                $scope.toggleStageLoading();
                                NBDDataFactory.get('nbd_get_resource', _dataObj, function(_data){
                                    _data = JSON.parse(_data);
                                    if($scope.resource.myDesigns.length == 0){
                                        $scope.needReloadUserDesigns = true;
                                    }else{
                                        $scope.resource.myDesigns.splice(0, 0, _data.data);
                                    }
                                    $scope.toggleStageLoading();
                                });
                            });
                        }
                    };
                    var klass = fabric.util.getKlass(object.type);
                    if( object.type == 'image' || object.type == 'custom-image' ){
                        fabric.Image.fromObject(object, function(_image){
                            $scope.tempCanvas.add(_image);
                            continueLoadLayer();
                        });
                    }else{
                        klass.fromObject(object, function(object){
                            $scope.tempCanvas.add(object);
                            continueLoadLayer();
                        });
                    }
                };
                importLayerToTempCanvas( currentIndex );
            }
        };
        $scope.scaleLayer = function(command){
            var _stage = this.stages[this.currentStage],
                _canvas = _stage.canvas,
                obj = _canvas.getActiveObject();
            if (!obj) return;
            $scope.beforeObjectModify(obj);
            if( _stage.lockMovementY || _stage.lockMovementX ) return;
            var scaleX = obj.scaleX,
                scaleY = obj.scaleY,
                left = obj.left,
                top = obj.top,
                originX = obj.originX,
                originY = obj.originY,
                width = obj.width * scaleX,
                height = obj.height * scaleY,
                factor = command === "+" ? 1.1 : 0.9;
            var tempScaleX = scaleX * factor,
                tempScaleY = scaleY * factor,
                tempWidth = width * factor,
                tempHeight = height * factor,
                tempLeft = left + width / 2 - tempWidth / 2,
                tempTop = top + height / 2 - tempHeight / 2;
            if( originX == 'center' ){
                tempLeft = left;
            }
            if( originY == 'center' ){
                tempTop = top;
            } 
            obj.scaleX = tempScaleX;
            obj.scaleY = tempScaleY;
            obj.left = tempLeft;
            obj.top = tempTop;
            obj.setCoords();
            $scope.adjustMaskedLayers( obj );
            $scope.renderStage();
            $scope.afterObjectModify();
        };
        $scope.changeLayerName = function( layerIndex, layerName ){
            var _stage = $scope.stages[$scope.currentStage],
            _canvas = _stage['canvas'];
            if( _canvas.item( layerIndex ) ){
                _canvas.item( layerIndex ).set({layerName: layerName});
            }
        };
        $scope.mapLayerWith = function( key ){
            var _stage = this.stages[this.currentStage],
                _canvas = _stage.canvas,
                obj = _canvas.getActiveObject();
            if (!obj) return;
            if( angular.isDefined( obj.field_mapping ) && obj.field_mapping == key ){
                delete obj.field_mapping;
                delete $scope.stages[$scope.currentStage].states.field_mapping;
            }else{
                obj.set( { field_mapping: key } );
                $scope.stages[$scope.currentStage].states.field_mapping = key;
            }
            jQuery('.second-contexts').addClass('deactive');
        };
        $scope.sortLayer = function(srcIndex, dstIndex){
            var _canvas = this.stages[this.currentStage].canvas,
            item = _canvas.item(srcIndex);
            item.moveTo(dstIndex);
            $scope.setStackLayerAlwaysOnBottom();
            $scope.renderStage();
            $scope.updateLayersList();
            $scope.afterObjectModify();
            $scope.updateApp();
        };
        $scope.updateMaskLayer = function( selectedItem, stageId ){
            stageId = stageId ? stageId : $scope.currentStage;
            var _canvas = this.stages[stageId].canvas,
                maskId = [];
            _canvas.forEachObject(function(obj, index) {
                if(!!obj.get('isMask')){
                    var id = obj.get('itemId'),
                    check = true;
                    if( angular.isDefined( selectedItem ) && selectedItem.get('itemId') == id ){
                        check = false;
                    }
                    check && maskId.push( id );
                }
            });
            function getMaskedLayer( maskId ){
                var layer;
                _canvas.forEachObject(function(obj, index) {
                    if(!!obj.get('maskId')){
                        if( obj.get('maskId') == maskId ){
                            layer = obj;
                        }
                    }
                });
                return layer;
            }
            _.each(maskId, function(id, index){
                var maskLayerIndex = $scope.getLayerById( id ),
                maskLayer = _canvas.item( maskLayerIndex );
                var maskedLayer = getMaskedLayer( id );
                if( maskedLayer ){
                    var maskedLayerIndex = $scope.getLayerById( maskedLayer.get('itemId') );
                    if( maskLayerIndex < maskedLayerIndex ){
                        maskLayer.moveTo( maskedLayerIndex - 1 );
                    }else{
                        maskLayer.moveTo( maskedLayerIndex );
                    }
                    maskLayer.set({selectable: false});
                }else{
                    
                }
            });
        };
        $scope.originPDFs = [];
        $scope.updateLayersList = function(){
            $scope.updateMaskLayer();
            var _stage = $scope.stages[$scope.currentStage],
            _canvas = _stage['canvas'];
            $scope.originPDFs[$scope.currentStage] = [];
            _stage.layers = [];
            _canvas.forEachObject(function(obj, index) {
                var layerInfo = {index: index, visible: obj.get('visible'), selectable: obj.get('selectable'), forceLock: obj.get('forceLock'), itemId: obj.get('itemId')};
                if( !obj.isAlwaysOnTop ){
                    if( !obj.get('isMask') ){
                        switch(obj.type) {
                            case 'i-text':
                            case 'text':
                            case 'textbox':
                            case 'curvedText':
                                layerInfo.type = 'text';
                                layerInfo.icon_class = 'text-fields';
                                layerInfo.text = obj.get('text');
                                layerInfo.editable = obj.get('editable');
                                if( angular.isDefined( obj.field_mapping ) ){
                                    var field = _.filter($scope.settings.template_fields, { key: obj.field_mapping })[0];
                                    if( angular.isDefined( field ) ){
                                        field.value = layerInfo.text;
                                    }
                                }
                                if( obj.lostChar == 1 ) layerInfo.lostChar = true;
                                break;
                            case 'image':
                            case 'custom-image':
                                var maskId = obj.get('maskId');
                                if( !maskId ){
                                    layerInfo.type = 'image';
                                    layerInfo.src = obj.getSvgSrc();
                                }else{
                                    layerInfo.type = 'image-layer';
                                    layerInfo.src = obj.getSvgSrc();
                                    layerInfo.maskId = maskId;
                                }
                                break;
                            case 'rect':
                            case 'triangle':
                            case 'line':
                            case 'polygon':
                            case 'circle':
                            case 'ellipse':
                            case 'polyline':
                                var type = obj.type == 'rect' ? 'rectangle' : obj.type;
                                type = obj.type == 'polyline' ? 'line' : obj.type;
                                layerInfo.icon_class = 'layer-'+type;
                                layerInfo.type = type;
                                break;
                            case 'path-group':
                            case 'path':
                                layerInfo.icon_class = 'vector';
                                layerInfo.type = 'path';
                                break;
                            case 'group':
                                layerInfo.icon_class = 'layer-group';
                                layerInfo.type = 'group';
                                break;
                            default:
                                layerInfo.type = obj.type;
                                break;
                        }
                        layerInfo.layerName = typeof obj.layerName != 'undefined' ? obj.layerName : ( angular.isDefined( $scope.settings.nbdlangs[layerInfo.type] ) ? $scope.settings.nbdlangs[layerInfo.type] : '' );
                        _stage.layers.push(layerInfo);
                    }
                }

                if( angular.isDefined( obj.origin_pdf ) ){
                    $scope.originPDFs[$scope.currentStage].push({
                        index: index,
                        origin_pdf: obj.origin_pdf,
                        top: obj.oCoords.tl.y / _stage.config.cheight * _stage.config.pHeight,
                        left: obj.oCoords.tl.x / _stage.config.cwidth * _stage.config.pWidth,
                        width: obj.width * obj.scaleX / _stage.config.cwidth * _stage.config.pWidth,
                        height: obj.height * obj.scaleY / _stage.config.cheight * _stage.config.pHeight
                    });
                }
            });
            $timeout(function(){
                jQuery('#tab-layer .tab-scroll').perfectScrollbar('update');
            });
        };
        $scope.setLayerAttribute = function(type, value, item_index, layer_index){
            var _canvas = $scope.stages[$scope.currentStage]['canvas'];
            if( !appConfig.ready ) return;
            var item = angular.isDefined(item_index) ? _canvas.item(item_index) : _canvas.getActiveObject();
            if(!item) return;
            if( type == 'selectable' && angular.isDefined(item.forceLock) && item.forceLock ) return;
            $scope.beforeObjectModify(item);
            var itemType = item.get('type');
            if( (itemType == 'i-text' || itemType == 'textbox') && type == 'forceLock'){
                value == true ? item.set({editable: false}) : item.set({editable: true});
            };
            if( type == 'forceLock'){
                value == true ? item.set({selectable: false}) : item.set({selectable: true});
            };
            var ob = {}; ob[type] = value;
            if( type == 'angle' ){
                item.rotate( value );
            }else{
                item.set(ob);
            };
            switch(type){
                case 'visible':
                case 'selectable':
                    $scope.deactiveAllLayer();
                    break;
                case 'lockScalingX':
                    var controlVisible = itemType == 'textbox' ? [] : ['tl', 'tr', 'bl', 'br'];
                    controlVisible.forEach(function(key){
                        item.setControlVisible(key, !value);
                    });
                    break;
                case 'lockScalingY':
                    var controlVisible = itemType == 'textbox' ? [] : ['tl', 'tr', 'bl', 'br'];
                    controlVisible.forEach(function(key){
                        item.setControlVisible(key, !value);
                    });
                    break;
                case 'lockRotation':
                    item.setControlVisible('mtr', !value);  
                    break;
            }
            $scope.renderStage();
            if(angular.isDefined(item_index)){
                $scope.stages[$scope.currentStage].layers[layer_index][type] = value;
            }else{
                $scope.stages[$scope.currentStage].states[type] = value;
            }
            if( type != 'text' ){
                $scope.updateLayersList();
            }
            if( ['i-text', 'text', 'textbox', 'curvedText'].indexOf(itemType) > -1 ){
                $scope.normalizeText( item );
                if( $scope.settings.nbdesigner_enable_text_check_lang == 'yes' ) $scope.checkCharacter( item );
            }
            $scope.afterObjectModify();
            $scope.updateApp();
        }
        $scope.canDeleteLayer = function(){
            $check = true;
            if( $scope.settings.nbdesigner_prevent_delete_template_layer == 'yes' && !$scope.isTemplateMode ) $check = false;
            return $check;
        }
        $scope.deleteLayers = function(itemIndex){
            if( !$scope.canDeleteLayer() ) return;
            var _canvas = this.stages[$scope.currentStage]['canvas'];
            var item = angular.isDefined(itemIndex) ? _canvas.item(itemIndex) : _canvas.getActiveObjects();
            if(item){
                if( angular.isDefined(itemIndex) ){
                    /*$scope.setHistory({
                        element: item,
                        parameters: JSON.stringify(item.toJSON()),
                        interaction: 'remove'
                    });*/
                    if( !!item.get('maskId') ){
                        var maskLayer = $scope.getMaskLayer( item.get('maskId') );
                        _canvas.remove(maskLayer); 
                    }
                    _canvas.remove(item); 
                }else{
                    _canvas.getActiveObjects().forEach(function(o){
                        /*$scope.setHistory({
                            element: o,
                            parameters: JSON.stringify(o.toJSON()),
                            interaction: 'remove'
                        }); */
                        if( !!o.get('maskId') ){
                            maskLayer = $scope.getMaskLayer( o.get('maskId') );
                            _canvas.remove(maskLayer); 
                        }
                        _canvas.remove(o); 
                    });
                }
                $scope.setHistory($scope.currentStage, true);
                _canvas.discardActiveObject().requestRenderAll();
            };
            $scope.updateLayersList();
            return;
        };
        $scope.activeLayer = function(itemIndex, layerIndex){
            var _stage = $scope.stages[$scope.currentStage],
            _canvas = _stage['canvas'];
            if( !$scope.isTemplateMode && angular.isDefined( _canvas.item(itemIndex).forceLock ) && _canvas.item(itemIndex).forceLock ) return;
            _canvas.setActiveObject(_canvas.item(itemIndex));
            if( angular.isDefined(layerIndex) ) _stage.layers[layerIndex].active = true;
            $scope.renderStage();
        };
        $scope.generateVcard = function( callback ){
            var strVcard = '';
            function getFieldValue( fieldKey ){
                var value = '';
                _.each($scope.settings.vcard_fields, function(field, index){
                    if( field.key == fieldKey ) value =  field.value;
                });
                return value;
            }
            strVcard += 'BEGIN:VCARD\nVERSION:3.0\n';
            strVcard += 'N:' + getFieldValue( 'last_name' ) + ';' + getFieldValue( 'first_name' ) + '\n' + 'FN:' + getFieldValue( 'first_name' ) + ' ' + getFieldValue( 'last_name' );
            strVcard += '\nADR;TYPE=home:;;'+ getFieldValue( 'address' ) + ';' + getFieldValue( 'city' ) + ';;' + getFieldValue( 'postcode' ) + ';' + getFieldValue( 'country' );
            strVcard += '\nTEL;TYPE=home:' + getFieldValue( 'phone' );
            strVcard += '\nTEL;TYPE=work:' + getFieldValue( 'mobile' );
            strVcard += '\nEMAIL;TYPE=internet,work:' + getFieldValue( 'email' );
            strVcard += '\nURL;TYPE=work:' + getFieldValue( 'website' );
            strVcard += '\nEND:VCARD';
            var qr = qrcode('0', 'M', defaultSettings.nbdesigner_default_color);
            qr.addData( strVcard );
            qr.make();
            var _qrcode = qr.createSvgTag();
            fabric.loadSVGFromString(_qrcode, function(ob, op) {
                var object = fabric.util.groupSVGElements(ob, op);
                if( typeof callback == 'function' ){
                    callback( object );
                }else{
                    var stage = $scope.stages[$scope.currentStage],
                    _canvas = stage['canvas'],
                    scale = stage.states.scaleRange[stage.states.currentScaleIndex].ratio,
                    max_width = _canvas.width / scale * .9,
                    max_height = _canvas.height / scale * .9,
                    new_width = max_width;
                    if (op.width < max_width) new_width = op.width;
                    var width_ratio = new_width / op.width,
                    new_height = op.height * width_ratio;
                    if (new_height > max_height) {
                        new_height = max_height;
                        var height_ratio = new_height / op.height;
                        new_width = op.width * height_ratio;
                    }
                    object.scaleToWidth(new_width);
                    object.scaleToHeight(new_height);
                    object.v_card = 1;
                    _canvas.add(object);
                }
            });
        };
        $scope.setPositionToolbox = function () {
            if( appConfig.isModern ) return;
            $timeout(function(){
                var _canvas = $scope.stages[$scope.currentStage]['canvas'],
                    object = _canvas.getActiveObject(),
                    objects = _canvas.getActiveObjects();

                var $vista = jQuery('.nbd-vista'),
                    $stageActive = jQuery('.nbd-vista .stage.nbd-active'),
                    $stageMainActive = jQuery('.nbd-vista .stage.nbd-active .stage-main'),
                    $layout = jQuery('.nbd-vista .nbd-layout'),
                    $toolMain = jQuery('.nbd-vista .v-toolbox .nbd-nav-tab[data-tab="tab-main-box"]');

                var bound =  object.getBoundingRect(),
                    stage = $scope.stages[$scope.currentStage];

                var ratioScale = stage.states.scaleRange[stage.states.currentScaleIndex].ratio,
                    paddingL = parseInt($stageActive.css('padding-left').slice(0, -2)),
                    paddingT = parseInt($stageActive.css('padding-top').slice(0, -2)),
                    paddingB = parseInt($stageActive.css('padding-bottom').slice(0, -2)),
                    paddingR = parseInt($stageActive.css('padding-right').slice(0, -2)),
                    pLeft = 0,
                    pTop = 0,
                    transform = 'translateX(-50%)',
                    _canvasWidth = _canvas.width,
                    _canvasHeight = _canvas.height,
                    mTop = stage.config.top * ratioScale,
                    mBottom = (stage.config.cheight - stage.config.top - stage.config.height) * ratioScale,
                    mRight = (stage.config.cwidth - stage.config.left - stage.config.width) * ratioScale,
                    mLeft = stage.config.left * ratioScale,
                    boundTop = bound.top + bound.height,
                    boundLeft = bound.left + bound.width,
                    _boundLeft = bound.left + bound.width / 2,
                    scrollXHeight = 5,
                    scrollYWidth = 5,
                    scrollTop = $stageActive.scrollTop(),
                    scrollLeft = $stageActive.scrollLeft();
                $toolMain.each(function (index, value) {
                    jQuery(this).triggerHandler('click');
                });

                if( $stageMainActive.height() > ( $stageActive.height() - scrollXHeight ) ){
                    if( ( $stageMainActive.height() - mBottom ) > ($stageActive.outerHeight() + scrollTop - paddingT) ){
                        if( (boundTop + mTop) > ($stageActive.outerHeight() + scrollTop) ){
                            pTop = $stageActive.outerHeight();
                        }else{
                            pTop = boundTop + mTop - scrollTop + paddingT;
                        }
                    }else{
                        if( boundTop > _canvas.height ){
                            pTop = $stageMainActive.height() - mBottom - scrollTop + paddingT; 
                        }else{
                            pTop = boundTop + mTop - scrollTop + paddingT; 
                        }
                    }
                } else{
                    if ( (bound.top + bound.height) > _canvas.height ) {
                        pTop = _canvas.height + paddingT + mTop;
                    }else{
                        pTop = boundTop + paddingT + mTop;
                    }
                }
                pTop += 7;
                stage.states.toolboxTriangle = 'center';
                if( $stageMainActive.width() > ( $stageActive.width() - scrollYWidth ) ){
                    if( (_boundLeft + mLeft - scrollLeft + paddingL) < 0 ){
                        pLeft = 0;
                        transform = 'translateX(0)';
                    }else if( (_boundLeft + mLeft - scrollLeft + paddingL - $stageActive.outerWidth() ) > 0 ){
                        pLeft = $stageActive.outerWidth();
                        transform = 'translateX(-100%)';
                    }else{
                        pLeft = _boundLeft + mLeft - scrollLeft + paddingL;
                    }
                }else{
                    if( _boundLeft < 0 ){
                        pLeft = ( $stageActive.outerWidth() - $stageMainActive.width() ) / 2 + mLeft;
                        transform = 'translateX(0)';
                    }else if( _boundLeft > _canvas.width ){
                        pLeft = ( $stageActive.outerWidth() - $stageMainActive.width() ) / 2 + mLeft + _canvas.width;
                        transform = 'translateX(-100%)';
                    }else{
                        pLeft = ( $stageActive.outerWidth() - $stageMainActive.width() ) / 2 + mLeft + _boundLeft;
                    }
                }
                pLeft -= 7;
                if( pLeft + 160 > $stageActive.outerWidth() ){
                    pLeft = $stageActive.outerWidth();
                    transform = 'translateX(-100%)';
                };
                if( pLeft < 160 ){
                    transform = 'translateX(0)';
                    pLeft = 0;
                };
                stage.states.toolboxStyle = {
                    top: pTop,
                    left: pLeft,
                    transform: transform
                };
            });
        };
        $scope.selectAllLayers = function(){
            var _canvas = this.stages[this.currentStage]['canvas'];
            $scope.deactiveAllLayer();
            var objs = [];
            _canvas.forEachObject(function(obj, index) {
                if( obj.get('selectable') ) objs.push(obj);
            });
            var selection = new fabric.ActiveSelection(objs, {
                canvas: _canvas
            });
            selection.addWithUpdate();
            _canvas.setActiveObject(selection);
            $scope.renderStage();
        };
        $scope.getCurrentLayerInfo = function(){
            var _canvas = $scope.stages[$scope.currentStage]['canvas'],
            object = _canvas.getActiveObject(),
            objects = _canvas.getActiveObjects();

            ['isActiveLayer', 'enableRotate', 'enableOpacity', 'enableChangePathColor', 'enableShadow'].forEach(function(key){
                $scope.stages[$scope.currentStage].states[key] = true;
            });
            ['isGroup', 'isNativeGroup', 'isLayer', 'isText', 'isImage', 'isPath', 'isShape', 'isEditing', 'isMask', 'isMasked', 'lockMask', 'isEmptyMask', 'isTemMask', 'elementUpload', 'isGroupText', 'srcChanged'].forEach(function(key){
                $scope.stages[$scope.currentStage].states[key] = false;
            });
            if( objects.length > 1 ){
                $scope.stages[$scope.currentStage].states.isGroup = true;
            }else{
                $scope.stages[$scope.currentStage].states.isLayer = true;
                if( object ){
                    if(!object.get('itemId')) {
                        var d = new Date(),
                        itemId = d.getTime() + Math.floor(Math.random() * 1000);
                        object.set({"itemId" : itemId});
                    }
                    ['isMask', 'isTemMask', 'srcChanged', 'isEmptyMask', 'lockMask'].forEach(function(key){
                        if( object.get(key) ){
                            $scope.stages[$scope.currentStage].states[key] = true;
                        }
                    });
                    if( !!object.get('maskId') ){
                        $scope.stages[$scope.currentStage].states.isMasked = true; 
                    }
                    $scope.stages[$scope.currentStage].states.ilr  = angular.isDefined(object.get('ilr')) ? object.get('ilr') : false;
                    $scope.stages[$scope.currentStage].states.forceLock  = angular.isDefined(object.get('forceLock')) ? object.get('forceLock') : false;
                    $scope.stages[$scope.currentStage].states.opacity = fabric.util.toFixed(object.get('opacity') * 100);
                    ['type', 'itemId', 'lockMovementX', 'lockMovementY', 'lockScalingX', 'lockScalingY', 'lockRotation', 'lockUniScaling', 'selectable', 'visible', 'angle', 'excludeFromExport', 'field_mapping', 'isQrcode', 'qrContent', 'isBarcode', 'barCodeContent', 'v_card'].forEach(function(key){
                        var val = object.get(key);
                        if( key == 'angle' && val < 0 ){
                            val += 360;
                        }
                        $scope.stages[$scope.currentStage].states[key] = val;
                    });
                    switch(object.type) {
                        case 'i-text':
                        case 'text':
                        case 'textbox':
                        case 'curvedText':
                            angular.copy($scope.defaultStageStates.text, $scope.stages[$scope.currentStage].states.text);
                            $scope.addColor(tinycolor(object.get('fill')).toHexString());
                            $scope.stages[$scope.currentStage].states.isText = true;
                            $scope.stages[$scope.currentStage].states.isEditing = object.isEditing ? object.isEditing : false;
                            $scope.stages[$scope.currentStage].states.fixedWidth = angular.isDefined(object.fixedWidth) ? object.fixedWidth : false;
                            $scope.stages[$scope.currentStage].states.text = {
                                font: $scope.getFontInfo(object.get('fontFamily')),
                                is_uppercase: $scope.isUpperCase(object)
                            };
                            ['fontFamily', 'ptFontSize' ,'font', 'fontSize', 'editable', 'textAlign', 'fontWeight', 'textDecoration', 'fontStyle', 'spacing', 'lineHeight', 'fill', 'charSpacing', 'textBackgroundColor', 'stroke', 'strokeWidth', 'text'].forEach(function(key){
                                $scope.stages[$scope.currentStage].states.text[key] = object.get(key);
                            });
                            if( angular.isUndefined($scope.stages[$scope.currentStage].states.text.ptFontSize) ){
                                $scope.stages[$scope.currentStage].states.text.ptFontSize = ( $scope.stages[$scope.currentStage].states.text.fontSize / $scope.stages[$scope.currentStage].states.ratioConvertFont ).toFixed(2);
                            }
                            if( $scope.stages[$scope.currentStage].states.text.textBackgroundColor == '' ) $scope.stages[$scope.currentStage].states.text.textBackgroundColor = '#ffffff';
                            if( !$scope.stages[$scope.currentStage].states.text.stroke ) $scope.stages[$scope.currentStage].states.text.stroke = '#ffffff';
                            if( object.type == 'curvedText' ){
                                ['reverse', 'spacing', 'radius'].forEach(function(key){
                                    $scope.stages[$scope.currentStage].states.text[key] = object.get(key);
                                });
                                $scope.stages[$scope.currentStage].states.text.rtl = angular.isDefined( object.rtl ) ? object.rtl : false;
                                if( $scope.stages[$scope.currentStage].states.text.rtl ){
                                    $scope.stages[$scope.currentStage].states.text.text = $scope.stages[$scope.currentStage].states.text.text.split('').reverse().join('');
                                };
                                $timeout(function(){
                                    jQuery('.item-curved').addClass('active');
                                    if( $scope.settings.is_mobile ) jQuery('.main-toolbar').addClass('overflow-hidden');
                                }, 300);
                            }else{
                                if( $scope.settings.is_mobile ) jQuery('.main-toolbar').removeClass('overflow-hidden');
                            };
                            $scope.stages[$scope.currentStage].states.enableRotate = $scope.settings.nbdesigner_text_rotate == '1' ? true : false;
                            $scope.stages[$scope.currentStage].states.enableOpacity = $scope.settings.nbdesigner_text_opacity == '1' ? true : false;
                            $scope.stages[$scope.currentStage].states.enableShadow = ( $scope.settings.nbdesigner_text_shadow == '1' && $scope.settings.nbdesigner_enable_cloud2print_api == 'yes' ) ? true : false;
                            break;
                        case 'image':
                        case 'custom-image':
                            $scope.stages[$scope.currentStage].states.elementUpload  = angular.isDefined(object.get('elementUpload')) ? object.get('elementUpload') : false;
                            $scope.stages[$scope.currentStage].states.ilr  = angular.isDefined(object.get('ilr')) ? object.get('ilr') : false;
                            $scope.stages[$scope.currentStage].states.isImage = true;
                            $scope.stages[$scope.currentStage].states.src = object.getSvgSrc();
                            $scope.stages[$scope.currentStage].states.origin_src = angular.isDefined( object.origin_src ) ? object.origin_src :  object.getSvgSrc();
                            if( angular.isDefined( object.origin_url ) ){
                                $scope.stages[$scope.currentStage].states.origin_url = object.origin_url;
                                $scope.stages[$scope.currentStage].states.origin_width = object.origin_width;
                                $scope.stages[$scope.currentStage].states.origin_height = object.origin_height;
                            }else{
                                delete $scope.stages[$scope.currentStage].states.origin_url;
                                delete $scope.stages[$scope.currentStage].states.origin_width;
                                delete $scope.stages[$scope.currentStage].states.origin_height;
                            }
                            ['crop_left', 'crop_top', 'crop_width', 'crop_height', 'crop_scaleX', 'crop_scaleY'].forEach(function(key){
                                if( angular.isDefined(object[key]) ){
                                    $scope.stages[$scope.currentStage].states[key] = object[key];
                                }
                            });
                            $scope.stages[$scope.currentStage].states.filters = [];
                            if( $scope.settings.enableImageFilter ){
                                $scope.availableFilters.forEach(function(filter){
                                    $scope.stages[$scope.currentStage].states.filters[filter] = $scope.checkActiveFilter( filter, object.filters );
                                });
                            }
                            break;
                        case 'rect':
                        case 'triangle':
                        case 'polygon':
                        case 'circle':
                        case 'ellipse':
                        case 'line':
                        case 'polyline':
                            $scope.stages[$scope.currentStage].states.isShape = true;
                            if( $scope.settings.nbdesigner_clipart_change_path_color == '1' ){
                                $scope.stages[$scope.currentStage].states.geoObject = {
                                    fill: object.get('fill'),
                                    stroke: object.get('stroke') ? object.get('stroke') : '#ffffff',
                                    strokeWidth: object.get('strokeWidth') ? object.get('strokeWidth') : 0,
                                    strokeDashArray: object.get('strokeDashArray') ? object.get('strokeDashArray') : ['', ''],
                                    strokeUniform: object.get('strokeUniform')
                                };
                            }
                            $scope.stages[$scope.currentStage].states.enableRotate = $scope.settings.nbdesigner_clipart_rotate == '1' ? true : false;
                            $scope.stages[$scope.currentStage].states.enableOpacity = $scope.settings.nbdesigner_clipart_opacity == '1' ? true : false;
                            break;
                        case 'path-group':
                        case 'path':
                        case 'group':
                            $scope.stages[$scope.currentStage].states.isPath = true;
                            if( $scope.settings.nbdesigner_clipart_change_path_color == '1' ){
                                $scope.stages[$scope.currentStage].states.svg.groupPath = $scope.getPathOfSvg(object);
                            }else{
                                $scope.stages[$scope.currentStage].states.svg.groupPath = [];
                            }
                            if( object.type == 'group' ) $scope.stages[$scope.currentStage].states.isNativeGroup = true;
                            $scope.stages[$scope.currentStage].states.enableRotate = $scope.settings.nbdesigner_clipart_rotate == '1' ? true : false;
                            $scope.stages[$scope.currentStage].states.enableOpacity = $scope.settings.nbdesigner_clipart_opacity == '1' ? true : false;
                            break; 
                        default:
                            break;
                    }

                    if( $scope.stages[$scope.currentStage].states.enableShadow ){
                        if( object.shadow ){
                            var colorArr = fabric.Color.sourceFromRgb( object.shadow.color ),
                            color = fabric.Color.fromRgb( object.shadow.color );
                            $scope.stages[$scope.currentStage].states.shadow = {
                                color: '#' + color.toHex(),
                                offsetX: object.shadow.offsetX,
                                offsetY: object.shadow.offsetY,
                                blur: object.shadow.blur,
                                opacity: colorArr[3]
                            }
                        } else {
                            $scope.stages[$scope.currentStage].states.shadow = angular.copy( $scope.defaultStageStates.shadow );
                        }
                    }
                }
            }
            $scope.updateApp();
        };
        $scope.clearStage = function(){
            if( !$scope.canDeleteLayer() ) return;
            var stage = $scope.stages[$scope.currentStage],
            _canvas = stage['canvas'];
            _canvas.clear();
            jQuery('.clear-stage-alert .close-popup').triggerHandler('click');
            if( stage.config.bgType == 'color' ){}
            if( stage.config.area_design_type == "2" ){
                $scope.contextAddLayers = 'template';
                var width = _canvas.width,
                height = _canvas.height,
                path = new fabric.Path("M0 0 H"+width+" V"+height+" H0z M "+width/2+" 0 A "+width/2+" "+height/2+", 0, 1, 0, "+width/2+" "+height+" A "+width/2+" "+height/2+", 0, 1, 0, "+width/2+" 0z");
                path.set({strokeWidth: 0, isAlwaysOnTop: true, fill: '#ffffff', selectable: false, evented: false});
                _canvas.add(path);
            }
            $scope.updateLayersList();
            _canvas.requestRenderAll();
            $scope.setHistory($scope.currentStage, true);
            $scope.stageDesignChanged();
        };
        $scope.undo = function(){
            var _stage = this.stages[this.currentStage],
                _canvas = _stage['canvas']; 
            if( _stage.undos.length > 1 ){
                var last = _stage.undos.pop(),
                    nexttoLast = _stage.undos[ _stage.undos.length - 1 ];
                $scope._loadStageFromJson($scope.currentStage, nexttoLast);
                $scope.setHistory($scope.currentStage, false, last, true);
                $scope.deactiveAllLayer();
                this.renderStage();
            }
            $scope.updateApp();
        };
        $scope.redo = function(){
            var _stage = this.stages[this.currentStage],
                _canvas = _stage['canvas'];
            if( _stage.redos.length > 0 ){
                var last = _stage.redos.pop();
                $scope._loadStageFromJson($scope.currentStage, last);
                $scope.setHistory($scope.currentStage, last, false, true);
                $scope.deactiveAllLayer();
                this.renderStage();
            };
            $scope.updateApp();
        }; 
        $scope._loadStageFromJson = function(stage_id, json, callback, withoutLoading){
            $scope.onloadTemplate = true;
            $scope.contextAddLayers = 'template';
            if( !withoutLoading ) $scope.toggleStageLoading();
            stage_id = angular.isDefined( stage_id ) ? stage_id : $scope.currentStage;
            var layerIndex = 0, 
                stage = $scope.stages[stage_id],
                _canvas = stage['canvas'],
                objects = json.objects;
            _canvas.clear();
            if( json.background ){
                _canvas.backgroundColor = json.background;
            }else{
                _canvas.backgroundColor = null;
            }
            function loadLayer(layerIndex){
                function continueLoadLayer(){
                    layerIndex++;
                    if( objects.length != 0 && layerIndex < objects.length ){
                        loadLayer(layerIndex);
                    }else{
                        $scope.renderStage($scope.currentStage);
                        var layers = _canvas.getObjects();
                        $scope.renderTextAfterLoadFont(layers, function(){
                            $scope.deactiveAllLayer();
                            $scope.renderStage($scope.currentStage);
                            $timeout(function(){
                                $scope.deactiveAllLayer();
                                $scope.renderStage($scope.currentStage);
                                $scope.onloadTemplate = false;
                                $scope.contextAddLayers = 'normal';
                                $scope.updateMaskedLayers( stage_id );
                                if( !withoutLoading ) $scope.toggleStageLoading();
                                if( typeof callback == 'function' ){
                                    callback();
                                }
                            }, 100);
                        });
                    }
                }
                if( objects.length > 0 ){
                    var item = objects[layerIndex],
                    type = item.type;
                    if( type == 'image' || type == 'custom-image' ){
                        fabric.Image.fromObject(item, function(_image){
                            _canvas.add(_image);
                            continueLoadLayer();
                        });
                    }else{
                        var klass = fabric.util.getKlass(type);
                        klass.fromObject(item, function(item){
                            _canvas.add(item);
                            continueLoadLayer();
                        });
                    }
                }else{
                    $scope.contextAddLayers = 'normal';
                    $scope.onloadTemplate = false;
                    if( !withoutLoading ) $scope.toggleStageLoading();
                    if( typeof callback == 'function' ){
                        callback();
                    }
                }
            }
            loadLayer(layerIndex);
        };
         $scope.loadStageFromJson = function(stage_id, json){
            $scope._loadStageFromJson( stage_id, json, function(){
                $scope.clearClipboardDesign();
            });
        };
        $scope.clearClipboardDesign = function(){
            $scope.tempStageDesign = null;
        };
        $scope.updateBoundingRect = function(item){
            var stage = $scope.stages[$scope.currentStage];
            if(item){
                angular.merge(stage.states.boundingObject, {
                    visibility: 'visible',
                    top: item.oCoords.tl.y - 1,
                    left: item.oCoords.tl.x - 1,
                    width: Math.sqrt(Math.pow(item.oCoords.tl.x - item.oCoords.tr.x, 2) + Math.pow(item.oCoords.tl.y - item.oCoords.tr.y, 2 )) + 2,
                    height: Math.sqrt(Math.pow(item.oCoords.tl.x - item.oCoords.bl.x, 2) + Math.pow(item.oCoords.tl.y - item.oCoords.bl.y, 2 )) + 2,
                    transform: "rotate("+item.angle+"deg)"
                });
                stage.states.boundingRealSize = {
                    size: (item.width * item.scaleX / stage.config.cwidth * stage.config.pWidth).toFixed(2) +'x'+ (item.height * item.scaleY / stage.config.cheight * stage.config.pHeight).toFixed(2) + '' + $scope.settings.nbdesigner_dimensions_unit,
                    transform: (item.angle > 270 || item.angle < 90 ) ? "rotate(0deg)" : "rotate(180deg)"
                };
                $scope.updateApp();
            }else{
                angular.merge(stage.states.boundingObject, {visibility: 'hidden'});
                angular.merge(stage.states.coordinates, {visibility: 'hidden'});
            }
        };
        $scope.updateCorners = function(){
            if( checkMobileDevice() ) return;
            var stage = $scope.stages[$scope.currentStage];
            stage.states.corners = [];

            function getCornerCursor( corner ){
                if( corner === 'mtr' ){
                    return 'crosshair';
                }else{
                    var cursorOffset = {
                        mt: 0,
                        tr: 1,
                        mr: 2,
                        br: 3,
                        mb: 4,
                        bl: 5,
                        ml: 6,
                        tl: 7
                    },
                    cursorMap = [
                        'n-resize',
                        'ne-resize',
                        'e-resize',
                        'se-resize',
                        's-resize',
                        'sw-resize',
                        'w-resize',
                        'nw-resize'
                    ],
                    n = Math.round((item.angle % 360) / 45);
                    if (n < 0) {
                        n += 8;
                    }
                    n += cursorOffset[corner];
                    n %= 8;
                    return cursorMap[n];
                }
            }
            var item = stage.canvas.getActiveObject();
            if(item){
                var controls = item.get('_controlsVisibility');
                var items = stage.canvas.getActiveObjects();
                if( controls || items.length ){
                    var canvasWidth = stage.config.width * stage.states.scaleRange[stage.states.currentScaleIndex].ratio,
                    canvasHeight = stage.config.height * stage.states.scaleRange[stage.states.currentScaleIndex].ratio;
                    ['tl', 'tr', 'br', 'bl', 'ml', 'mt', 'mr', 'mb', 'mtr'].forEach(function(control){
                        if( ( controls && controls[control] ) || items.length ){
                            var _style = {
                                left: item.oCoords[control].x - fabric.Object.prototype.cornerSize / 2,
                                top: item.oCoords[control].y - fabric.Object.prototype.cornerSize / 2,
                                width: fabric.Object.prototype.cornerSize,
                                height: fabric.Object.prototype.cornerSize,
                                cursor: getCornerCursor( control )
                            };
                            if( item.oCoords[control].x < 0 || item.oCoords[control].x > canvasWidth || item.oCoords[control].y < 0 || item.oCoords[control].y > canvasHeight ){
                                stage.states.corners.push({
                                    type: control,
                                    style: _style
                                })
                            }
                        }
                    });
                    if( stage.states.corners.length ){
                        stage.states.corners.push({
                            type: '',
                            style: {
                                top: item.oCoords.tl.y - 1,
                                left: item.oCoords.tl.x - 1,
                                width: Math.sqrt(Math.pow(item.oCoords.tl.x - item.oCoords.tr.x, 2) + Math.pow(item.oCoords.tl.y - item.oCoords.tr.y, 2 )) + 2,
                                height: Math.sqrt(Math.pow(item.oCoords.tl.x - item.oCoords.bl.x, 2) + Math.pow(item.oCoords.tl.y - item.oCoords.bl.y, 2 )) + 2,
                                transform: "rotate("+item.angle+"deg)"
                            }
                        })
                    }
                }
            }

            $scope.updateApp();
        };
        $scope.onUnloadGroup = {
            status: false,
            remain: 0,
            length: 0
        };
        $scope.renderStage = function( id ){
            var stage_id = angular.isDefined( id ) ? id :  $scope.currentStage;
            $scope.stages[stage_id]['canvas'].calcOffset();
            $scope.stages[stage_id]['canvas'].renderAll();
        };
        $scope.setStageDimension = function(id){
            id = angular.isDefined(id) ? id : $scope.currentStage;
            var _stage = $scope.stages[id];
            var currentWidth = _stage.config.width * _stage.states.scaleRange[_stage.states.currentScaleIndex].ratio,
                currentHeight = _stage.config.height * _stage.states.scaleRange[_stage.states.currentScaleIndex].ratio;
            $scope.stages[id]['canvas'].setDimensions({'width' : currentWidth, 'height' : currentHeight});
        };
        $scope.beforeObjectModify = function( item ){
            /*$scope.setHistory({
                element: item
,               parameters: JSON.stringify(item.toJSON()),
                interaction: 'modify'
            });*/
        };
        $scope.afterObjectModify = function(){
            $scope.setHistory( $scope.currentStage, true );
            $scope.stageDesignChanged();
        };
        $scope.stickerCutline = {
            pathCmd: '',
            svg: '',
            patternSvg: '',
            active: false
        };
        $scope.stageDesignChanged = function(){

        };
        $scope.showDesignTab = function(){
            if( checkMobileDevice() ){
                jQuery('#design-tab').triggerHandler('click');
            };
        };
        $scope.disablePreventClickMode = function(){
            jQuery('.tabs-content').removeClass('nbd-prevent-click');
        };
        $scope.setHistory = function(stage_id, undo, redo, hasJson){
            stage_id = angular.isDefined( stage_id ) ? stage_id : $scope.currentStage;
            var _stage = this.stages[stage_id];
            if( angular.isUndefined( _stage ) ) return;
            var _canvas = _stage['canvas'];
            if ( undo ) {
                if(angular.isUndefined(_stage.undos)) _stage.undos = [];
                if( typeof _canvas.toJSON == 'function' ){
                    if( angular.isUndefined( hasJson ) ){
                        var json = _canvas.toJSON($scope.includeExport);
                        if(angular.isUndefined(_stage.undos)) _stage.undos = [];
                    }else{
                        var json = undo;
                    }
                    _stage.undos.push(json);
                    if(_stage.undos.length > 30) _stage.undos.shift();
                    _stage.states.isUndoable = true;

                    if( $scope.resource.shareDesign ){
                        if( $scope.settings.ui_mode == 1 ) {
                            nbd_window.jQuery(nbd_window.document).triggerHandler( 'nbd_pass_design_json', {stage_id: stage_id, design: json, config: { width: _canvas.width, height: _canvas.height, zoom: _stage.states.scaleRange[_stage.states.currentScaleIndex].ratio }, fonts: _stage.states.usedFonts } );
                        }else{
                            jQuery( document ).triggerHandler( 'nbd_pass_design_json', {stage_id: stage_id, design: json, config: { width: _canvas.width, height: _canvas.height, zoom: _stage.states.scaleRange[_stage.states.currentScaleIndex].ratio }, fonts: _stage.states.usedFonts } );
                        }
                    }
                }
            } else {
                if(angular.isUndefined(_stage.redos)) _stage.redos = [];
                _stage.states.isRedoable = true;
                _stage.redos.push(redo);
            }
            $scope.updateApp();
            $scope.updateStatusHistory();
        };
        $scope.updateStatusHistory = function(){
            var _stage = this.stages[this.currentStage];
            _stage.states.isUndoable = (_stage.undos.length > 1) ? true : false; 
            _stage.states.isRedoable = (_stage.redos.length > 0) ? true : false;
            $scope.updateApp();
        };
        $scope.onClickStage = function( $event ){
            /*
             * Deactive all layer if click outer canvas 
             * Hide context menu
             * Store stages
             */
            if(angular.element($event.target).hasClass('stage')){
                $scope.deactiveAllLayer();
            }
            $scope.ctxMenuStyle.visibility = 'hidden';
            $scope.updateApp();
        };
        $scope.ctxMenuStyle = {
            'top': '17%',
            'left': '33%',
            'visibility': 'hidden'
        };
        /* Utility functions */
        $scope.getFontInfo = function(alias){
            var font = _.filter($scope.resource.myFont.data, { alias: alias })[0];
            if(angular.isUndefined(font)) {
                font = _.filter($scope.resource.font.data, { alias: alias })[0];
            }
            var _font = angular.copy(font, _font);

            if(_font){    
                _font.file = {r: font.file.r};
                _font.file.i = angular.isDefined(font.file.i) ? font.file.i : 0;
                _font.file.b = angular.isDefined(font.file.b) ? font.file.b : 0;
                _font.file.bi = angular.isDefined(font.file.bi) ? font.file.bi : 0;
            }else{
                _font = {name: 'Roboto', alias: 'Roboto', file: {r: 1, b: 1, i: 1, bi: 1}, cat: ["99"], type:"google",subset:"latin"};
            }
            return _font;
        };
        $scope.getPathOfSvg = function(object){
            var groupPath = [];
            _.each(object._objects, function(path, index){
                if( path.get('fill') != '' ){
                    var color = tinycolor(path.get('fill')).toHexString();
                    $scope.addColor(color);
                    var findex;
                    if(  ( findex = _.findIndex(groupPath, ['color', color]) ) > -1 ){
                        groupPath[findex]['index'].push(index);
                    }else{
                        groupPath.push({color: color, index: [index]});
                    }
                }
            });
            if(groupPath.length == 0){
                if( object.get('fill') ){
                    $scope.addColor(tinycolor(object.get('fill')).toHexString());
                    groupPath.push({color: tinycolor(object.get('fill')).toHexString(), index: [-2]});
                }
            }
            if(groupPath.length == 0){
                $scope.addColor(tinycolor(object.get('stroke')).toHexString());
                groupPath.push({color: tinycolor(object.get('stroke')).toHexString(), index: [-1]});
            }
            return groupPath;
        };
        $scope.isUpperCase = function( object ){
            var _isUpperCase = angular.isDefined(object.is_uppercase) ? object.is_uppercase : false;
            return _isUpperCase;
        };
        /* Insert */
        $scope.insertTypography = function(typo){
            if( !$scope.canAddMoreLayer() ) return;
            var stage = $scope.stages[$scope.currentStage],
            scale = stage.states.scaleRange[stage.states.currentScaleIndex].ratio,
            _canvas = stage['canvas'];
            $scope.toggleStageLoading();
            $scope.showDesignTab();
            axios.get(s3PreUrl+'assets/typography/' + typo.folder + '/design.json').then(
                function (response) {
                    var data = response.data;
                    var objects = data.frame_0.objects;
                    var stageLayers = [];
                    var layerIndex = 0;
                    function loadLayer() {
                        function loadFont(font, callback) {
                            if(!_.filter($scope.resource.font.data, ['alias', font.alias]).length){
                                // if( angular.isDefined(font.file) && angular.isDefined(font.file.r) )$scope.resource.font.data.push(font);

                                if( angular.isDefined(font.url) )$scope.resource.font.data.push({ r: font.url });
                            };
                            if(!_.filter(stage.states.usedFonts, ['alias', font.alias]).length){
                                stage.states.usedFonts.push($scope.formatFont(font));
                            };
                            $scope.insertTemplateFont(font.alias, function(){
                                if( typeof callback == 'function' ) callback();
                                if(!_.filter($scope.resource.usedFonts, ['alias', font.alias]).length){
                                    $scope.resource.usedFonts.push($scope.formatFont(font));
                                };
                            });
                        }
                        function fitTemplateWithStage() {
                            var selection = new fabric.ActiveSelection(stageLayers, {
                              canvas: _canvas
                            });
                            _canvas.setActiveObject(selection);
                            selection.addWithUpdate();
                            if( ( selection.width * scale ) > ( _canvas.width * 0.8 ) ){
                                var canvasWidth = _canvas.width;
                                selection.scaleX = selection.scaleX * canvasWidth * 0.8 / ( selection.width * scale );
                                selection.scaleY = selection.scaleY * canvasWidth * 0.8 / ( selection.width * scale );
                                selection.width = selection.width * canvasWidth * 0.8 / ( selection.width * scale );
                                selection.addWithUpdate();
                                if( ( selection.height * scale ) > ( _canvas.height * 0.8 ) ){
                                    var canvasHeight = _canvas.height;
                                    selection.scaleX = selection.scaleX * canvasHeight * 0.8 / ( selection.height * scale );
                                    selection.scaleY = selection.scaleY * canvasHeight * 0.8 / ( selection.height * scale );
                                    selection.height = selection.height * canvasHeight * 0.8 / ( selection.height * scale );
                                    selection.addWithUpdate();
                                }
                            }
                            _canvas.viewportCenterObjectH(selection);
                            _canvas.viewportCenterObjectV(selection);
                            $scope.renderStage();
                            $timeout(function(){
                                $scope.deactiveAllLayer();
                                _canvas.setActiveObject(selection);
                                selection.addWithUpdate();
                                _canvas.viewportCenterObjectH(selection);
                                _canvas.viewportCenterObjectV(selection);
                                if( stage.config.area_design_type == "2" ) $scope.setStackLayerAlwaysOnTop();
                                $scope.renderStage();
                                $scope.toggleStageLoading();
                                $scope.setHistory($scope.currentStage, true);
                            }, 500);
                        }
                        function continueLoadLayer(){
                            layerIndex++;
                            if( layerIndex < objects.length ){
                                loadLayer(layerIndex);
                            }else{
                                fitTemplateWithStage();
                            }
                        }
                        function addLayer(_item, callback){
                            $scope.contextAddLayers = 'template';
                                _canvas.add(_item);
                            var __item = _canvas.item(_canvas.getObjects().length - 1);
                            if(typeof callback === 'function') callback(__item);
                            stageLayers.push(__item);
                            continueLoadLayer();
                        }
                        var item = objects[layerIndex];
                        var type = item.type;
                        var klass = fabric.util.getKlass(type);
                        var is_text = false;
                        if( ['i-text', 'text', 'textbox', 'curvedText'].indexOf( type ) > -1  ){
                            // update font
                            
                            if(!_.filter($scope.resource.font.data, ['alias', item.font.alias]).length){
                                $scope.resource.usedFonts.push($scope.formatFont(item.font));
                            };   
                            var font_id = item.font.name.replace(/\s/gi, '').toLowerCase();
                            if( !jQuery('#' + font_id).length ){
                                jQuery('head').append('<link id="' + font_id + '" href="https://fonts.googleapis.com/css?family='+ item.font.name.replace(/\s/gi, '+') +':400,400i,700,700i" rel="stylesheet" type="text/css">');
                            }
                            if(!_.filter(stage.states.usedFonts, ['alias', item.fontFamily]).length){
                                var layerFont = $scope.getFontInfo(item.fontFamily);
                                stage.states.usedFonts.push($scope.formatFont(item.font));
                            };
                            is_text = true;
                        };
                        klass.fromObject(item, function(item){
                            if(is_text){
                                var fontFamily = item.fontFamily,
                                fontWeight = angular.isDefined(item.fontWeight) ? item.fontWeight : '',
                                fontStyle = angular.isDefined(item.fontStyle) ? item.fontStyle : '',
                                _font = $scope.getFontInfo(fontFamily);
                                item.set({objectCaching: false});

                                var font = new FontFaceObserver(fontFamily, {weight: fontWeight, style: fontStyle});
                                font.load($scope.settings.subsets[_font.subset]['preview_text']).then(function () {
                                    fabric.util.clearFabricFontCache();
                                    addLayer(item, function(__item){
                                        __item.initDimensions();
                                        __item.setCoords();
                                    });
                                }, function () {
                                    console.log('Error load font: '+fontFamily);
                                    addLayer(item);
                                });
                            }else{
                                addLayer(item);
                            }
                        });
                    }
                    loadLayer(layerIndex);
                }
            );
        };
        $scope.insertTemplateFont = function(font_name, callback){
            var _font = $scope.getFontInfo(font_name);
            var fontName = font_name;
            var font_id = fontName.replace(/\s/gi, '').toLowerCase();
            if( !jQuery('#' + font_id).length ){
                if(_font.type == 'google'){
                    jQuery('head').append('<link id="' + font_id + '" href="https://fonts.googleapis.com/css?family='+ fontName.replace(/\s/gi, '+') +':400,400i,700,700i" rel="stylesheet" type="text/css">');
                }else{
                    if( _font.file.r == '1' ){
                        var font_url = _font.url;
                        if(! (font_url.indexOf("http") > -1)) font_url = $scope.settings.folder_font + font_url; 
                        var css = "";
                        css = "<style type='text/css' id='" + font_id + "' >";
                        css += "@font-face {font-family: '" + fontName + "';";
                        css += "src: ";
                        css += "url('" + font_url + "') format('truetype')";
                        css += "}";
                        css += "</style>";
                        jQuery("head").append(css);
                    }else{
                        var css = "<style type='text/css' id='" + font_id + "' >";
                        _.each(_font.file, function (file, index) {
                            if( file != 0 ){
                                var font_url = file;
                                if(! (file.indexOf("http") > -1)) font_url = $scope.settings.folder_font + file;
                                css += "@font-face {font-family: '" + fontName + "';";
                                css += "src: ";
                                css += "url('" + font_url + "') format('truetype');";
                                switch(index){
                                    case "r":
                                        css += "font-weight: normal;font-style: normal;"
                                        break;
                                    case "b":
                                        css += "font-weight: bold;font-style: normal;"
                                        break;
                                    case "i":
                                        css += "font-weight: normal;font-style: italic;"
                                        break;
                                    case "bi":
                                        css += "font-weight: bold;font-style: italic;"
                                        break;
                                };
                                css += "}";
                            }
                        });
                        css += "</style>";
                        jQuery("head").append(css);
                    }
                }
            };
            var font = new FontFaceObserver(fontName);
            var previewText = $scope.settings.subsets[_font.subset] ? $scope.settings.subsets[_font.subset]['preview_text'] : $scope.settings.subsets['all']['preview_text'];
            font.load(previewText).then(function () {
                if( angular.isDefined(callback) ) callback(fontName);
            }, function () {
                console.log('Fail to load: '+fontName);
                if( angular.isDefined(callback) ) callback(fontName);
            });
        };
        $scope.renderTextAfterLoadFont = function(layers, callback ){
            if( layers.length == 0 ) {
                callback();
                return;
            };
            _.each(layers, function(item, index){
                if( ['text', 'i-text', 'curvedText', 'textbox'].indexOf(item.type) > -1 ){
                    var fontFamily = item.get('fontFamily'),
                    fontWeight = item.get('fontWeight'),
                    fontStyle = item.get('fontStyle'),
                    _font = $scope.getFontInfo(fontFamily);
                    var opt = {};
                    if( fontWeight != '' ) opt.weight = fontWeight;
                    if( fontStyle != '' ) opt.style = fontStyle;
                    item.set({objectCaching: false});
                    fabric.util.clearFabricFontCache();
                    var font = new FontFaceObserver(fontFamily, {weight: fontWeight, style: fontStyle});
                    var previewText = $scope.settings.subsets[_font.subset] ? $scope.settings.subsets[_font.subset]['preview_text'] : $scope.settings.subsets['all']['preview_text'];
                    font.load(previewText).then(function () {
                        fabric.util.clearFabricFontCache();
                        item.initDimensions();
                        item.setCoords();
                    }, function () {
                        /* todo */
                    });
                };
                if( index == (layers.length -1) && typeof callback == 'function' ){
                    callback();
                }
            });
        };
        $scope.loadTemplateLayer = function(json, callback, stage_id){
            stage_id =  angular.isDefined(stage_id) ? stage_id : $scope.currentStage;
            var stage = $scope.stages[stage_id],
            _canvas = stage['canvas'];
            var klass = fabric.util.getKlass(json.type);
            klass.fromObject(json, function(item){
                $scope.contextAddLayers = 'template';
                _canvas.add(item);
                var _item = _canvas.item( _canvas.getObjects().length - 1 );
                $scope.resource.tempData.template.push(_item);
                if( typeof callback == 'function' ) callback();
            });
        };
        /* Set text*/
        $scope.setTextAttribute = function(type, value, extra_option){
            var _stage = $scope.stages[$scope.currentStage],
                _states = _stage.states,
                _canvas = _stage['canvas'];
            if( !appConfig.ready ) return;
            var item = _canvas.getActiveObject();
            var items = _canvas.getActiveObjects();
            if( !item || !items ) return;
            $scope.beforeObjectModify(item);
            var ob = {};ob[type] = value;
            item.set(ob);
            if( type == 'fontSize' ){
                var minSize = arrayMin($scope.listFontSizeInPt),
                    maxSize = arrayMax($scope.listFontSizeInPt);
                if( $scope.forceMinSize && minSize > value ) value = minSize;
                if( $scope.forceMaxSize && maxSize < value ) value = maxSize;
                item.set({'ptFontSize': value, 'fontSize': value * _states.ratioConvertFont});
                _states.text.ptFontSize = value;
                $scope.updateTextPxFontSize( item );
            }
            switch(type){
                case 'is_uppercase':
                    value ? item.set({'text': item.get('text').toUpperCase()}) : item.set({'text': item.get('text').toLowerCase()});
                    break;
                case 'fontFamily':
                    if(!_.filter(_states.usedFonts, ['alias', value]).length){
                        _states.usedFonts.push($scope.getFontInfo(value));
                    }
                    // format font khi post design
                    item.set({ font: $scope.formatFont($scope.getFontInfo(value), true) });
                    _states.text.font = $scope.getFontInfo(value);
                    if( !_states.text.font.file.b ) {
                        item.set({fontWeight: 'normal'});
                        _states.text.fontWeight = 'normal';
                    };
                    if( !_states.text.font.file.i ) {
                        item.set({fontStyle: 'normal'});
                        _states.text.fontStyle = 'normal';
                    };
                    if( !_states.text.font.file.bi && item.get('fontWeight') == 'bold' && item.get('fontStyle') == 'italic' ) {
                        item.set({fontWeight: 'normal', fontStyle: 'normal'});
                        _states.text.fontWeight = 'normal';
                        _states.text.fontStyle = 'normal';
                    };
                    break;
            }
            _states.text[type] = value;
            if(type == 'rtl'){
                item.set({text: item.text.split('').reverse().join('')}) ;
            };
            if( type.indexOf("font") > -1 ){
                var font = new FontFaceObserver(_states.text.fontFamily, {weight: _states.text.fontWeight, style: _states.text.fontStyle});
                font.load(item.get('text')).then(function () {
                    fabric.util.clearFabricFontCache(_states.text.fontFamily);
                    $timeout(function(){
                        item.initDimensions();
                        item.setCoords();
                        $scope.afterObjectModify();
                        $scope.renderStage(); 
                    });
                }, function () {
                    item.setCoords();
                    $scope.renderStage();
                });
                if( $scope.settings.nbdesigner_enable_text_check_lang == 'yes' ){
                    $scope.checkCharacter( item );
                }
            }else{
                item.setCoords();
                $scope.afterObjectModify();
                $scope.renderStage();
            }
            $scope.normalizeText( item );
            $scope.updateLayersList();
        };
        $scope.setShadow = function(){
            var _canvas = $scope.stages[$scope.currentStage]['canvas'];
            if( !appConfig.ready ) return;
            var item = _canvas.getActiveObject();
            if( !item ) return;
            $scope.beforeObjectModify(item);
            var colorArr = fabric.Color.sourceFromHex( $scope.stages[$scope.currentStage].states.shadow.color ),
            color = `rgba(${colorArr[0]},${colorArr[1]},${colorArr[2]},${$scope.stages[$scope.currentStage].states.shadow.opacity})`;
            item.set({
                shadow: {
                    color: color,
                    offsetX: $scope.stages[$scope.currentStage].states.shadow.offsetX,
                    offsetY: $scope.stages[$scope.currentStage].states.shadow.offsetY,
                    blur: $scope.stages[$scope.currentStage].states.shadow.blur
                }
            });
            $scope.renderStage();
            $scope.afterObjectModify();
            $scope.updateApp();
        };
        $scope.removeShadow = function(){
            var _canvas = $scope.stages[$scope.currentStage]['canvas'];
            if( !appConfig.ready ) return;
            var item = _canvas.getActiveObject();
            if( !item ) return;
            $scope.beforeObjectModify(item);
            delete item.shadow;
            $scope.renderStage();
            $scope.afterObjectModify();
            $scope.updateApp();
        };
        $scope.updateTextPxFontSize = function (item) {
            var textTypes = ['i-text', 'text', 'textbox'],
                itemType = item.get('type');
            if (textTypes.indexOf(itemType) > -1) {
                if ($scope.settings.nbdesigner_enable_text_free_transform == 'no') {
                    var lastScaleX = item.scaleX,
                    ptFontSize = item.ptFontSize,
                    newFontSize = ptFontSize * $scope.stages[$scope.currentStage].states.ratioConvertFont;
                    item.set({
                        dirty: true,
                        scaleX: 1,
                        scaleY: 1,
                        fontSize: newFontSize,
                        width: item.width * lastScaleX
                    });
                }
            }
        };
        $scope.currentJsFont = null;
        $scope.checkCharacter = function( object ){
            var font = _.filter($scope.resource.font.data, { alias: object.get('fontFamily') })[0];
            var arr = [], 
                check = true,
                text = object.text.replace(/\r?\n|\r/gm, ''),
                fontWeight = object.get('fontWeight'),
                fontStyle = object.get('fontStyle'),
                itemId = object.get('itemId'),
                font_url = '';
            if( fontWeight == 'bold' ){
                if( fontStyle == 'italic' ){
                    font_url = font.file.bi;
                } else {
                    font_url = font.file.b;
                }
            } else {
                if( fontStyle == 'italic' ){
                    font_url = font.file.i;
                } else {
                    font_url = font.file.r;
                }
            }
            if( font_url == 1 ) return;
            if( font.type != 'google' ){
                font_url = $scope.settings.folder_font + font_url;
            }else{
                font_url = font_url.replace('http:', 'https:');
            }
            opentype.load( font_url, function (err, font) {
                if( err ){
                    console.log(err);
                }else{
                    $scope.currentJsFont = font;
                    var glyphs = font.glyphs.glyphs;
                    _.each(glyphs, function(glyph, index){
                        arr['g-' + glyph.unicode] = 1;
                    });
                    for(var i = 0; i < text.length; i++){
                        var uc_index = 'g-' + text.charCodeAt(i);
                        if( angular.isUndefined( arr[uc_index] ) ){
                            check = false;
                        }
                    }
                    var _index = _.findIndex($scope.stages[$scope.currentStage].states.lostCharLayers, function(layerId) { return layerId == itemId; });
                    if( !check ){
                        object.set({lostChar: 1});
                        if( _index == -1 ) $scope.stages[$scope.currentStage].states.lostCharLayers.push( itemId );
                    } else {
                        delete object.lostChar;
                        if( _index > -1 ) $scope.stages[$scope.currentStage].states.lostCharLayers.splice(_index, 1);
                    }
                    $scope.updateLayersList();
                }
            });
        };
        /* Update */
        $scope.updateUploadZone = function(item){
            var type = item.get('type'),
            elementUpload = item.get('elementUpload');
            if( (type == 'image' || type == 'custom-image' ) && elementUpload  ){
                angular.merge($scope.stages[$scope.currentStage].states.uploadZone, {
                    visibility: 'visible',
                    top: item.oCoords.tl.y - 1,
                    left: item.oCoords.tl.x - 1,
                    width: Math.sqrt(Math.pow(item.oCoords.tl.x - item.oCoords.tr.x, 2) + Math.pow(item.oCoords.tl.y - item.oCoords.tr.y, 2 )) + 2,
                    height: Math.sqrt(Math.pow(item.oCoords.tl.x - item.oCoords.bl.x, 2) + Math.pow(item.oCoords.tl.y - item.oCoords.bl.y, 2 )) + 2,
                    transform: "rotate("+item.angle+"deg)"
                });
            }else{
                angular.merge($scope.stages[$scope.currentStage].states.uploadZone, {visibility: 'hidden'}); 
            }
        };
        $scope.updateWarning = function(item){
            if(viewSettings.showWarning.oos){
                var stage = $scope.stages[$scope.currentStage];
                var _canvas = stage['canvas'],
                bound = item.getBoundingRect();
                if( bound.left < 0 || bound.top < 0 || (bound.left + bound.width) > (_canvas.width)|| (bound.top + bound.height) > (_canvas.height)  ){
                    stage.states.oos = true;
                }else{
                    stage.states.oos = false;
                }
                $scope.updateApp();
            }
        };
        $scope.updateAssociateLayer = function(item){
            if(item){
                var d = new Date(),
                t = d.getTime();
                if( $scope.stages[$scope.currentStage].states.coordinates.lastCheck < ( t - 20 ) ){
                    item.setCoords();
                    $scope.stages[$scope.currentStage].states.coordinates.lastCheck = t;
                    $scope.updateCoordenatesLabel(item);
                    $scope.updateBoundingRect(item);
                    $scope.updateSnapLines();
                    $scope.updateUploadZone(item);
                    $scope.updateApp();
                }
            }
        };
        $scope.updateCoordenatesLabel = function(item){
            if(item){
                var top = item.oCoords.tl.y,
                    left = item.oCoords.tl.x;
                if( (item.angle > 315 && item.angle < 360) || (item.angle > 45 && item.angle < 90) 
                        || (item.angle > 135 && item.angle < 180) || (item.angle > 225 && item.angle < 270) ){
                    if( item.oCoords.tr.x < left ){
                        top = item.oCoords.tr.y;
                        left = item.oCoords.tr.x;
                    }
                    if( item.oCoords.br.x < left ){
                        top = item.oCoords.br.y;
                        left = item.oCoords.br.x;
                    }   
                    if( item.oCoords.bl.x < left ){
                        top = item.oCoords.bl.y;
                        left = item.oCoords.bl.x;
                    }
                }else{
                    if( item.oCoords.tr.y < top ){
                        top = item.oCoords.tr.y;
                        left = item.oCoords.tr.x;
                    }
                    if( item.oCoords.br.y < top ){
                        top = item.oCoords.br.y;
                        left = item.oCoords.br.x;
                    }   
                    if( item.oCoords.bl.y < top ){
                        top = item.oCoords.bl.y;
                        left = item.oCoords.bl.x;
                    }
                }
                angular.merge($scope.stages[$scope.currentStage].states.coordinates, {
                    style: {
                        visibility: 'visible',
                        top: top,
                        left: left
                    },
                    top: parseInt(top),
                    left: parseInt(left)
                });
            }
        };
        $scope.updateSnapLines = function(){
            var _canvas = this.stages[$scope.currentStage]['canvas'],
                item = _canvas.getActiveObject(),
                position = {
                    ht: {top: -9999},
                    hb: {top: -9999},
                    hc: {top: -9999},
                    vl: {left: -9999},
                    vr: {left: -9999},
                    vc: {left: -9999},
                    hcc: {top: -9999},
                    vcc: {left: -9999},
                    vel: {left: -9999},
                    ver: {left: -9999},
                    het: {top: -9999},
                    heb: {top: -9999}
                };
            if( item ){
                var bound = item.getBoundingRect();
                _canvas.forEachObject(function(obj) {
                    if( obj === item ) return;
                    var _bound = obj.getBoundingRect();
                    if(Math.abs(bound.left - _bound.left) < 1)  position.vl.left = _bound.left;
                    if(Math.abs(bound.left + bound.width - _bound.left) < 1) position.vr.left = _bound.left;
                    if(Math.abs(bound.left - _bound.left - _bound.width) < 1)  position.vl.left = _bound.left + _bound.width;
                    if(Math.abs(bound.top - _bound.top) < 1)  position.ht.top = _bound.top;
                    if(Math.abs(bound.top + bound.height - _bound.top) < 1) position.ht.top = _bound.top;
                    if(Math.abs(bound.top - _bound.top - _bound.height) < 1)  position.hb.top = _bound.top + _bound.height;
                    if(Math.abs(bound.left + bound.width - _bound.left - _bound.width) < 1)  position.vr.left = _bound.left + _bound.width;
                    if(Math.abs(bound.top + bound.height - _bound.top - _bound.height) < 1)  position.hb.top = _bound.top + _bound.height;
                    if(Math.abs(bound.left + bound.width / 2 - _bound.left - _bound.width / 2) < 1) position.vc.left = _bound.left + _bound.width / 2;
                    if(Math.abs(bound.top + bound.height / 2 - _bound.top - _bound.height / 2) < 1) position.hc.top = _bound.top + _bound.height / 2;  
                });
                if(Math.abs(bound.left + bound.width / 2 - _canvas.width / 2) < 1)  position.vcc.left = _canvas.width / 2;
                if(Math.abs(bound.top + bound.height / 2 - _canvas.height / 2) < 1)  position.hcc.top = _canvas.height / 2;
                
                if(Math.abs(bound.left) < 1)  position.vel.left = 0;
                if(Math.abs(bound.top) < 1)  position.het.top = 0;
                if(Math.abs(bound.left + bound.width - _canvas.width) < 1)  position.ver.left = _canvas.width;
                if(Math.abs(bound.top + bound.height - _canvas.height) < 1)  position.heb.top = _canvas.height;
                
                angular.merge($scope.stages[$scope.currentStage].states.snaplines, position);
            }
        };
        $scope.updateAngleLabel = function( item ){
            if(item){
                angular.merge($scope.stages[$scope.currentStage].states.rotate, {
                    style: {
                        transform: "rotate("+item.angle+"deg)",
                        top: item.oCoords.mtr.y,
                        left: item.oCoords.mtr.x,
                        visibility: 'visible'
                    },
                    angle: fabric.util.toFixed(item.angle, 0)
                });
            }else{
                angular.merge($scope.stages[$scope.currentStage].states.rotate, {style: {visibility: 'hidden'}});
            }
        };
        /* Color */
        $scope.stageBgColorPicker = {
            status: false,
            currentColor: '#fff'
        };
        $scope.wraperClickHandle = function($event){
            var $textPicker = jQuery('#nbd-text-color-picker');
            var $bgPicker = jQuery('#nbd-bg-color-picker');
            var $globalPicker = jQuery('#nbd-global-color-picker');
            var $stageBgPicker = jQuery('#nbd-stage-bg-color-picker');
            if (!jQuery($event.target).hasClass('color-palette-add') && $scope.showTextColorPicker 
                    && $textPicker.has($event.target).length == 0 && !$textPicker.is($event.target)){
                $scope.showTextColorPicker = false;
            };
            if( !jQuery($event.target).hasClass('color-palette-add') && $scope.showBgColorPicker && $bgPicker.has($event.target).length == 0 && !$bgPicker.is($event.target) ){
                $scope.showBgColorPicker = false;
            }
            if( !jQuery($event.target).hasClass('color-palette-add') && $scope.stageBgColorPicker.status && $stageBgPicker.has($event.target).length == 0 && !$stageBgPicker.is($event.target) ){
                $scope.stageBgColorPicker.status = false;
            }
            if( !jQuery($event.target).hasClass('color-palette-add') && $scope.globalPicker.active && $globalPicker.has($event.target).length == 0 && !$globalPicker.is($event.target) ){
                $scope.globalPicker.active = false;
            };
        };
        $scope.showTextColorPalette = function(){
            $scope.showTextColorPicker = !$scope.showTextColorPicker;
        };
        $scope.selectGlobalPicker = function(color){
            $scope.globalPicker.color = color;
            var attr_arr = $scope.globalPicker.attr.split(".");
            if( attr_arr.length == 2 && attr_arr[0] == 'text' ){
                $scope.setTextAttribute(attr_arr[1], $scope.globalPicker.color);
                $timeout(function(){
                    jQuery('.menu-item.item-stroke').addClass('active');
                });
            }else if( attr_arr.length == 2 && attr_arr[0] == 'geoObject' ){
                $scope.setGeometricalObjectAttr( attr_arr[1], color );
            }else if( attr_arr.length == 2 && attr_arr[0] == 'shadow' ){
                $scope.stages[$scope.currentStage].states.shadow.color = $scope.globalPicker.color;
                $timeout(function(){
                    jQuery('.menu-item.item-shadow').addClass('active');
                });
            }
            jQuery('#nbd-global-color-palette').removeClass('show');
        };
        $scope.$on('nbd:picker', function(event, attr, color){
            $scope.globalPicker.attr = attr;
            $scope.globalPicker.color = color;
        });
        /* create Canvas */

        $scope.$on('canvas:created', function(event, id, last){
            /* init canvas parameters */
            $scope.initStageSetting( id );
            var _canvas = $scope.stages[id].canvas;
            if(!checkMobileDevice()){
                jQuery('#stage-container-'+id).perfectScrollbar();
                jQuery('#stage-container-'+id).on('drop', function(event){
                    $scope.onDrop(event, id);
                });
            };
            /* Listen canvas events */
            _canvas.on('mouse:down', function(options) {
                $scope.onMouseDown(id, options);
            });
            _canvas.on("mouse:over", function(options){
                $scope.onMouseOverStage(id, options);
            });
            _canvas.on("mouse:out", function(options){
                $scope.onMouseOutStage(id, options);
            });
            _canvas.on("mouse:move", function(options){
                $scope.onMouseMoveStage(id, options);
            });
            _canvas.on("mouse:up", function(options){
                $scope.onMouseUpStage(id, options);
            });
            _canvas.on("path:created", function(options){
                $scope.onPathCreated(id, options);
            });
            _canvas.on("object:added", function(options){
                $scope.onObjectAdded(id, options);
            });
            _canvas.on("object:removed", function(options){
                $scope.onObjectRemoved(id, options);
            });
            _canvas.on("selection:created", function(options){
                $scope.onSelectionCreated(id, options);
            });
            _canvas.on("object:scaling", function(options){
                $scope.onObjectScaling(id, options);
            });
            _canvas.on("object:scaled", function (options) {
                $scope.onObjectScaled(id, options);
            });
            _canvas.on("object:moving", function(options){
                $scope.onObjectMoving(id, options);
            });
            _canvas.on("object:moved", function (options) {
                $scope.onObjectMoved(id, options);
            });
            _canvas.on("object:rotating", function(options){
                $scope.onObjectRotating(id, options);
            });
            _canvas.on("object:modified", function(options){
                $scope.onObjectModified(id, options);
            });
            _canvas.on("before:render", function(options){
                $scope.onBeforeRender(id, options);
            });
            _canvas.on("after:render", function(options){
                $scope.onAfterRender(id, options);
            });
            _canvas.on("selection:cleared", function(options){
                $scope.onSelectionCleared(id, options);
            });
            _canvas.on("text:editing:entered", function(options){
                $scope.onEditingEntered(id, options);
            });   
            _canvas.on("text:editing:exited", function(options){
                $scope.onEditingExited(id, options);
            });
            _canvas.on("text:changed", function(options){
                $scope.onTextChanged(id, options);
            });
            _canvas.on("selection:updated", function(options){
                $scope.onSelectionUpdated(id, options);
            });
            _canvas.on("text:selection:changed", function(options){
                $scope.onSelectionChanged(id, options);
            });
            _canvas.on("mouse:dblclick", function(options){
                $scope.onDblclick(options);
            });
            _canvas.on("drop", function(options){
                $scope.onDropOnCanvas(options);
            });
            _canvas.on("dragenter", function(options){
                $scope.onDragenterOnCanvas(options);
            });
            _canvas.on("dragleave", function(options){
                $scope.onDragleaveOnCanvas(options);
            });
            /* Load template after render canvas */
            if( last == '1' ){
                appConfig.ready = true;
                if( $scope.preventLoadDesign ){
                    $scope.preventLoadDesign = false;
                    return;
                }
                $scope.loadTemplateAfterRenderCanvas();
            }
            if( $scope.duplicateStageIndex == id ){
                $scope.duplicateStageIndex = -1;
                $scope.contextAddLayers = 'template';
                $scope.onloadTemplate = true;
                $scope.stages[id].canvas.loadFromJSON($scope.resource.jsonDesign[id], function() {
                    $scope.onloadTemplate = false;
                    $scope.contextAddLayers = 'normal';
                });
            }
        });
        
        $scope.loadTemplateAfterRenderCanvas = function(){
            $scope.initStagesCanvas();
            if( $scope.forceInitStage ){
                $scope.initStagesSettingWithoutTemplate();
                $scope.forceInitStage = false;
                return;
            }
            if( ( task == 'edit_template' || task == 'edit' ) && $scope.the_first_time_load_page ) {
                var id = template_id;
                if(task == 'edit') {
                    id = design_id;
                }
                $scope.insertTemplate(false, {id: id}, 'api' , dataDesignLayers);
                $scope.the_first_time_load_page = false;
            }
            $scope.initStagesSettingWithoutTemplate();
        };
        $scope.initStagesCanvas = function(){
            _.each($scope.stages, function(stage, index){
                var _canvas = stage.canvas;
                if( angular.isDefined( $scope.settings.nbes_enable_settings ) ){
                    var forceBg = false, color = '';
                    if( $scope.settings.nbes_enable_settings.combination == 1 ){
                        if( angular.isDefined( $scope.settings.nbes_settings.combination_colors ) && angular.isDefined( $scope.settings.nbes_settings.combination_colors.bg_codes ) && $scope.settings.nbes_settings.combination_colors.bg_codes.length > 0 ){
                            forceBg = true;
                            color = $scope.settings.nbes_settings.combination_colors.bg_codes[ $scope.currentCombinationColor ];
                            $scope.settings.hideColorPalette = true;
                        }
                    } else if( $scope.settings.nbes_enable_settings.background == 1 ){
                        if( angular.isDefined( $scope.settings.nbes_settings.background_colors ) && angular.isDefined( $scope.settings.nbes_settings.background_colors.codes ) && $scope.settings.nbes_settings.background_colors.codes.length > 0 ){
                            forceBg = true;
                            color = $scope.settings.nbes_settings.background_colors.codes[ $scope.currentBackgroundColor ];
                        }
                    }
                    if( forceBg ){
                        _canvas.backgroundColor = color;
                    }
                }
                if( stage.config.area_design_type == "2" ){
                    $scope.contextAddLayers = 'template';
                    var width = _canvas.width,
                    height = _canvas.height,
                    path = new fabric.Path("M0 0 H"+width+" V"+height+" H0z M "+width/2+" 0 A "+width/2+" "+height/2+", 0, 1, 0, "+width/2+" "+height+" A "+width/2+" "+height/2+", 0, 1, 0, "+width/2+" 0z");
                    path.set({strokeWidth: 0, isAlwaysOnTop: true, fill: '#ffffff', selectable: false, evented: false});
                    _canvas.add(path);
                }
            });
        };
        $scope.initStagesSettingWithoutTemplate = function(){
            _.each($scope.stages, function(stage, index){
                var _canvas = stage.canvas;
                _canvas.requestRenderAll();
            });
            $scope.afterInsertTemplate();
        };
        $scope.firstTimeLoadedTemplate = true;
        $scope.firstTimeShowTemplateFiledsPopup = true;
        $scope.preventChangeCurrentDesign = false;
        $scope.awaitSubmitForm= false;
        $scope.afterInsertTemplate = function(){
            if( $scope.settings.ui_mode == 1 || $scope.settings.ui_mode == 2 ){
                var showTourGuide = localStorage.getItem('showTourGuide');
                if( checkMobileDevice() ){
                    showTourGuide = true;
                }
                if( !showTourGuide ){
                    $scope.startTourGuide();
                }else{
                    $scope.showTemplateFieldsPopup();
                }
            }
            _.each($scope.stages, function(stage, index){
                $scope.updateMaskedLayers(index);
                $timeout(function(){
                    $scope.setHistory(index, true);
                });
            });
            $scope.firstTimeLoadedTemplate      = false;
            $scope.completedInsertTemplate      = true;
            $scope.preventChangeCurrentDesign   = false;

            if ( angular.isDefined( $scope.settings.nbes_enable_settings ) && angular.isDefined( $scope.settings.nbes_settings ) 
                  && $scope.settings.nbes_enable_settings.combination == 1 && angular.isDefined( $scope.settings.nbes_settings.combination_colors ) ) {
                $scope.selectCombinationColor( $scope.currentCombinationColor );
            }

            if( $scope.awaitSubmitForm ){
                $scope.saveData();
            }
        };
        /* Action on canvas*/
        $scope.stageEvent = {
            dropped: false,
            target: null,
            lastDistance: null,
            lastScaleX: null,
            lastScaleY: null
        };
        $scope.onDrop = function(event){
            event.preventDefault();
            var src = event.originalEvent.dataTransfer.getData("src"),
            extenal = event.originalEvent.dataTransfer.getData("extenal"),
            type = event.originalEvent.dataTransfer.getData("type"),
            origin_url = event.originalEvent.dataTransfer.getData("origin_url"),
            width = event.originalEvent.dataTransfer.getData("origin_width"),
            height = event.originalEvent.dataTransfer.getData("origin_height");
            switch(type){
                case 'image':
                    function addImage( maskId ){
                        if(extenal == 'true'){
                            if( angular.isDefined( maskId ) ){
                                $scope.addImageFromUrl(src, true, false, maskId);
                            }else{
                                $scope.addImageFromUrl(src, true);
                            }
                        }else{
                            var data  = src;
                            if( angular.isDefined( origin_url ) && origin_url != '' ){
                                var data = {
                                    url: src,
                                    src: src,
                                    origin_url: origin_url,
                                    width: parseInt( width ),
                                    height: parseInt( height )
                                };
                            }
                            if( angular.isDefined( maskId ) ){
                                $scope.addImageFromUrl(data, false, false, maskId);
                            }else{
                                $scope.addImageFromUrl(data, false);
                            }
                        };
                    }
                    var interval = $interval(function(){
                        if( $scope.stageEvent.dropped ){
                            $interval.cancel( interval );
                            if( !!$scope.stageEvent.target && !!$scope.stageEvent.target.get('itemId') && !!$scope.stageEvent.target.get('maskId') ){
                                addImage( $scope.stageEvent.target.get('maskId') );
                            }else{
                                addImage();
                            }
                            $scope.stageEvent.dropped = false;
                            $scope.stageEvent.target = null;
                        }
                    }, 50);
                    break;
                case 'svg':
                    if( extenal == 'true' ){
                        $scope.addSvgFromMedia({url: src});
                        break;
                    }
                    $scope.addImageFromUrl(src, false);
                    break;
                case 'typo':
                    $scope.insertTypography({folder: src});
                    break;
            };
        };
        $scope.onMouseDown = function(id, options){
            $scope.stages[$scope.currentStage].states.isShowToolBox = true;
            if( checkMobileDevice() ){
                jQuery('.nbd-main-menu .menu-item').removeClass('active');
            }
            $scope.updateApp();
        };
        $scope.initStageSetting = function( id ){
            $scope.setStageDimension(id);
            $scope.renderStage(id);
            $scope.updateApp();
        };
        $scope.onMouseOverStage = function(id, options){
            if(options.target){
                var item = options.target;
                $scope.updateBoundingRect(item);
                $scope.updateApp();
            }
        };
        $scope.onMouseOutStage = function(id, options){
            if(options.target){
                angular.merge($scope.stages[$scope.currentStage].states.boundingObject, {visibility: 'hidden'}); 
            }
            $scope.updateApp();
        };
        $scope.onMouseMoveStage = function(id, options){
            if( $scope.settings.showRuler && appConfig.isModern ){
                var _stage = $scope.stages[$scope.currentStage];
                if( _stage.hozRuler ){
                    var pointer = _stage.canvas.getPointer(options.e);
                    var x = (pointer.x + _stage.config.top) * _stage.states.scaleRange[_stage.states.currentScaleIndex].ratio,
                    y = (pointer.y + _stage.config.top) * _stage.states.scaleRange[_stage.states.currentScaleIndex].ratio;
                    _stage.hozRuler.updateCursorIndicator({x: x, y: y});
                    _stage.verRuler.updateCursorIndicator({x: x, y: y});
                }
            }
            if( options.target && options.e.touches && options.e.touches.length == 2 ){
                var item = options.target;
                if( item && item.type != 'activeSelection' ){
                    var scaleX = item.get('scaleX'),
                    scaleY = item.get('scaleY'),
                    pageX1 = options.e.touches[0].pageX,
                    pageY1 = options.e.touches[0].pageY,
                    pageX2 = options.e.touches[1].pageX,
                    pageY2 = options.e.touches[1].pageY,
                    distance = Math.sqrt( ( pageX1 - pageX2 ) * ( pageX1 - pageX2 ) + ( pageY1 - pageY2 ) * ( pageY1 - pageY2 ) );
                    distance = distance == 0 ? 1 : distance;
                    if( !$scope.stageEvent.lastDistance ){
                        $scope.stageEvent.lastDistance = distance;
                        $scope.stageEvent.lastScaleX = scaleX;
                        $scope.stageEvent.lastScaleY = scaleY;
                    }
                    var ratio = distance / $scope.stageEvent.lastDistance;
                    ratio = ratio > 3 ? 3 : ratio;
                    item.set({scaleX: $scope.stageEvent.lastScaleX * ratio, scaleY: $scope.stageEvent.lastScaleY * ratio});
                    item.setCoords();
                    $scope.adjustMaskedLayers( item, 'at' );
                    $scope.renderStage();
                }
            }
        };
        $scope.onMouseUpStage = function(id, options){
            var _stage = $scope.stages[$scope.currentStage];
            /*
             * Hide bounding rect, coordinates label, snap lines, rotate label
             */
            angular.merge(_stage.states.boundingObject, {visibility: 'hidden'});
            angular.merge(_stage.states.coordinates, {style: {visibility: 'hidden'}});
            var position = {
                ht: {top: -9999},
                hb: {top: -9999},
                hc: {top: -9999},
                vl: {left: -9999},
                vr: {left: -9999},
                vc: {left: -9999},
                hcc: {top: -9999},
                vcc: {left: -9999},
                vel: {left: -9999},
                ver: {left: -9999},
                het: {top: -9999},
                heb: {top: -9999}
            };
            angular.merge(_stage.states.snaplines, position);
            angular.merge(_stage.states.rotate, {style: {visibility: 'hidden'}});
            /* get layer parameters before modify */
            var _canvas = _stage.canvas,
                objects =  _canvas.getActiveObjects();
            _stage.tempParameters = null;
            if( objects.length == 1 ){
                _stage.tempParameters = JSON.stringify(objects[0].toJSON());
            }
            /* Delete layer if out of stage fully */
            if( options.target ){
                if(!options.target.isOnScreen()) $scope.deleteLayers();
            }
            
            $scope.stageEvent.lastDistance = null;
            $scope.stageEvent.lastScaleX = null;
            $scope.stageEvent.lastScaleY = null;

            if( $scope.settings.nbdesigner_always_show_layer_action == 'yes' ){
                $scope.updateCorners();
            }

            $scope.updateApp(); 
        };
        $scope.onPathCreated = function(id, options){};
        $scope.onObjectAdded = function(id, options){
            var _stage = $scope.stages[$scope.currentStage],
            _canvas = _stage['canvas'],
            item = options.target,
            d = new Date(),
            itemId = d.getTime() + Math.floor(Math.random() * 1000);
            if( $scope.contextAddLayers == 'normal' || $scope.contextAddLayers == 'copy' ){
                if( !$scope.canAddMoreLayer() ){
                    _canvas.remove( item );
                    return
                };
            }
            if( $scope.contextAddLayers == 'normal' || $scope.contextAddLayers == 'copy' || $scope.contextAddLayers == 'template' ){
                if( angular.isUndefined( item.get('itemId') ) ){
                    item.set({"itemId" : itemId});
                }
            };
            if( $scope.contextAddLayers == 'normal' && !$scope.resource.drawMode.status ){
                _stage.states.isShowToolBox = true;
                _canvas.viewportCenterObject(item);
            }
            var type = item.get('type');
            if( $scope.resource.upload.ilr ){
                item.set({ilr: true});
                $scope.resource.upload.ilr = false;
            }
            if(type == 'i-text' || type == 'textbox' || type == 'text' || type == 'curvedText') item.initDimensions();
            item.setCoords();
            if( (['normal', 'copy', 'undo', 'redo'].indexOf($scope.contextAddLayers) > -1) && _stage.config.area_design_type == "2" )  $scope.setStackLayerAlwaysOnTop();
            var top = item.get('top'),
                left = item.get('left');
            if( $scope.contextAddLayers == 'normal' && !$scope.resource.drawMode.status ){
                item.set({top: top - 50});
                item.animate('top', top, {
                    duration: 400,
                    onChange: function(){
                        $scope.renderStage();
                    },
                    onComplete: function(){
                        if( item.isBgImg ){
                            $scope.setStackLayerAlwaysOnBottom();
                        }else{
                            _canvas.setActiveObject(item);
                        }
                        $scope.setHistory($scope.currentStage, true);
                        $scope.stages[$scope.currentStage].tempParameters = JSON.stringify(item.toJSON());
                        if(type == 'i-text' || type == 'textbox'){
                            item.selectAll();
                            item.enterEditing();
                        }
                        $scope.renderStage();
                        // $scope.afterAddNewObject();
                    },
                    easing: FabricWindow.util.ease['easeInQuad']
                });
                $scope.stages[$scope.currentStage].states.isActiveLayer = true;
            }else if( $scope.contextAddLayers == 'copy' ){
                item.set({top: top - 20, left: left - 20});
                item.animate({'top': top, 'left': left}, {
                    duration: 400,
                    onChange: function(){
                        $scope.renderStage();
                    },
                    onComplete: function(){
                        $scope.setHistory($scope.currentStage, true);
                        $scope.stages[$scope.currentStage].tempParameters = JSON.stringify(item.toJSON());
                        $scope.renderStage();
                    },
                    easing: FabricWindow.util.ease['easeInQuad']
                });
            }else{
                $scope.renderStage();
            };
            if( !$scope.onloadTemplate ){
                if($scope.onUnloadGroup.status){
                    if( angular.isDefined($scope.onUnloadGroup.prevIndex) ){
                        item.moveTo( parseInt( $scope.onUnloadGroup.prevIndex ) + $scope.onUnloadGroup.length - $scope.onUnloadGroup.remain );
                    }
                    if( type == 'i-text' || type == 'textbox' || type == 'text' || type == 'curvedText' ){
                        item.set({editable: true});
                    }
                    if( $scope.onUnloadGroup.remain > 1 ){
                        $scope.onUnloadGroup.remain -= 1;
                    }else{
                        $scope.onUnloadGroup = {
                            status: false,
                            remain: 0
                        };
                        $scope.contextAddLayers = 'normal';
                        $scope.setHistory($scope.currentStage, true);
                    }
                }else{
                    $scope.contextAddLayers = 'normal';
                }
            }
            if( $scope.contextAddLayers == 'normal' && !$scope.resource.drawMode.status ){
                $scope.showDesignTab();
            }
            $scope.forceForeground( item );
            $scope.updateLayersList();
            $scope.stageDesignChanged();
        };
        $scope.onObjectRemoved = function(id, options){
            $scope.stageDesignChanged();
        };
        $scope.onSelectionCreated = function(id, options){
            $scope.getCurrentLayerInfo();
            $scope.updateUploadZone(options.target);
            $scope.updateWarning(options.target);
            var item = options.target;
            $scope.updateMaskLayer( item );
            if( ($scope.stages[$scope.currentStage].states.isShape || $scope.stages[$scope.currentStage].states.isPath) && $scope.settings.nbdesigner_clipart_rotate == '0' ){
                $scope.hideRotateControl( item );
            }
            if( $scope.stages[$scope.currentStage].states.isMask ){
                $scope.hideRotateControl( item );
            }
        };
        $scope.onSelectionUpdated = function(id, options){
            $scope.getCurrentLayerInfo();
            $scope.updateUploadZone(options.target);
            $scope.updateWarning(options.target);
            if( $scope.stages[$scope.currentStage].states.isGroup ){
                $scope.stages[$scope.currentStage].states.ilr = false;
            }
            var item = options.target;
            if( ($scope.stages[$scope.currentStage].states.isShape || $scope.stages[$scope.currentStage].states.isPath) && $scope.settings.nbdesigner_clipart_rotate == '0' ){
                if( !!item.get('itemId') ) $scope.hideRotateControl( item );
            }
            if( $scope.stages[$scope.currentStage].states.isMask ){
                if( !!item.get('itemId') ) $scope.hideRotateControl( item );
            }else{
                if( !!item.get('itemId')  ) $scope.updateMaskLayer( item );
            }
        };
        $scope.onSelectionChanged = function(id, options){
            $scope.getCurrentLayerInfo();
            var item = options.target;
            $scope.updateUploadZone(item);
            $scope.updateWarning(item);
            if( $scope.stages[$scope.currentStage].states.isGroup ){
                $scope.stages[$scope.currentStage].states.ilr = false;
            }else if( ($scope.stages[$scope.currentStage].states.isShape || $scope.stages[$scope.currentStage].states.isPath) && $scope.settings.nbdesigner_clipart_rotate == '0' ){
                $scope.hideRotateControl( item );
            }
            if( $scope.stages[$scope.currentStage].states.isMask ){
                $scope.hideRotateControl( item );
            }
            $scope.updateMaskLayer( item );
        };
        $scope.onObjectScaling = function(id, options){
            var item = options.target; 
            $scope.adjustMaskedLayers( item );
            $scope.updateAssociateLayer(item);
            $scope.stages[$scope.currentStage].states.isShowToolBox = false;
            $scope.stages[$scope.currentStage].states.corners = [];
        };
        $scope.onObjectScaled = function (id, options) {
            var item = options.target;
            $scope.stages[$scope.currentStage].states.isShowToolBox = true;
            $scope.setPositionToolbox();
            $scope.adjustMaskedLayers( item, 'at' );
        };
        $scope.onObjectMoving = function(id, options){
            var item = options.target;
            if($scope.settings.snapMode.status){

            }
            $scope.adjustMaskedLayers( item );
            $scope.updateAssociateLayer(item); 
            $scope.stages[$scope.currentStage].states.isShowToolBox = false;
            $scope.stages[$scope.currentStage].states.corners = [];
        };
        $scope.onObjectMoved = function (id, options) {
            var item = options.target;
            $scope.stages[$scope.currentStage].states.isShowToolBox = true;
            $scope.setPositionToolbox();
            $scope.adjustMaskedLayers( item, 'at' );
        };
        $scope.onObjectRotating = function(id, options){
            var item = options.target;
            $scope.updateAssociateLayer(item);
            $scope.updateAngleLabel(item);
            $scope.stages[$scope.currentStage].states.corners = [];
        };
        $scope.onObjectModified = function(id, options){
            var item = options.target;
            var newAngle = item.angle;
            newAngle = (Math.abs(item.angle - 0) <= 1 || Math.abs(item.angle - 360) <= 1 ) ? 0 : ( Math.abs(item.angle - 180) <= 1 ? 180 : newAngle );
            item.set({angle: newAngle, dirty: true});
            $scope.setHistory($scope.currentStage, true);
            if( $scope.stages[$scope.currentStage].states.isText && $scope.stages[$scope.currentStage].states.type != 'curvedText' && $scope.settings.nbdesigner_enable_text_free_transform == 'no'){
                var newFontSize = item.fontSize * item.scaleX;
                var lastScaleX = item.scaleX;
                var newPtFontSize = newFontSize / $scope.stages[$scope.currentStage].states.ratioConvertFont;
                var minSize = arrayMin($scope.listFontSizeInPt),
                    maxSize = arrayMax($scope.listFontSizeInPt);
                if( $scope.forceMinSize && minSize > newPtFontSize ){
                    newPtFontSize = minSize;
                    newFontSize   = newPtFontSize * $scope.stages[$scope.currentStage].states.ratioConvertFont;
                }
                if( $scope.forceMaxSize && maxSize < newPtFontSize ){
                    newPtFontSize = maxSize;
                    newFontSize   = newPtFontSize * $scope.stages[$scope.currentStage].states.ratioConvertFont;
                }
                newPtFontSize = newPtFontSize.toFixed(2);
                item.set({
                    dirty: true,
                    scaleX: 1,
                    scaleY: 1,
                    fontSize: newFontSize,
                    ptFontSize: newPtFontSize,
                    width: item.width * lastScaleX
                });
                $scope.stages[$scope.currentStage].states.text.fontSize = newFontSize;
                $scope.stages[$scope.currentStage].states.text.ptFontSize = newPtFontSize;
            }

            $scope.updateWarning(item);
            $scope.stageDesignChanged();

            var _stage = $scope.stages[$scope.currentStage],
            _canvas = _stage['canvas'];
            $scope.originPDFs[$scope.currentStage] = [];
            _canvas.forEachObject(function(obj, index) {
                if( angular.isDefined( obj.origin_pdf ) ){
                    $scope.originPDFs[$scope.currentStage].push({
                        index: index,
                        origin_pdf: obj.origin_pdf,
                        top: obj.oCoords.tl.y / _stage.config.cheight * _stage.config.pHeight,
                        left: obj.oCoords.tl.x / _stage.config.cwidth * _stage.config.pWidth,
                        width: obj.width * obj.scaleX / _stage.config.cwidth * _stage.config.pWidth,
                        height: obj.height * obj.scaleY / _stage.config.cheight * _stage.config.pHeight
                    });
                }
            });
        };
        $scope.onBeforeRender = function(id, options){};
        $scope.onAfterRender = function(id, options){
            var stage = $scope.stages[id];
            if( !stage ) return;
            var _canvas = stage['canvas'];
            function checkLayerById( id ){
                var check = false;
                _canvas.forEachObject(function(obj) {
                    if(obj.get('itemId') == id) check = true;
                });
                return check;
            }
            $scope.stages[$scope.currentStage].states.lostCharLayers = $scope.stages[$scope.currentStage].states.lostCharLayers.filter(function(layerId){
                return checkLayerById( layerId );
            });
        };
        $scope.onSelectionCleared = function(id, options){
            $scope.showTabFont();
            $scope.stages[$scope.currentStage].states.isActiveLayer = false;
            $scope.stages[$scope.currentStage].states.itemId = null;
            $scope.stages[$scope.currentStage].states.isEditing = false;
            angular.merge($scope.stages[$scope.currentStage].states.uploadZone, {visibility: 'hidden'});
            $scope.stages[$scope.currentStage].states.elementUpload = false;
            $scope.stages[$scope.currentStage].states.oos = false;
            $scope.stages[$scope.currentStage].states.ilr = false;
            $scope.updateMaskLayer();
        };
        $scope.onEditingEntered = function(id, options){
            $scope.stages[$scope.currentStage].states.isEditing = true;     
            $scope.updateApp();
        };
        $scope.onEditingExited = function(id, options){
            $scope.stages[$scope.currentStage].states.isEditing = false;
            var item = options.target;
            if( item ){
                $scope.updateLayersList();
            }
            $scope.updateApp();
        };
        $scope.onTextChanged = function(id, options){
            var item = options.target;
            if( item ){
                $scope.normalizeText( item );
                if( angular.isDefined( item.field_mapping ) ){
                    _.each($scope.stages, function(stage, index){
                        var _canvas = stage.canvas;
                        _canvas.forEachObject(function(obj) { 
                            if( angular.isDefined( obj.field_mapping ) && item.field_mapping == obj.field_mapping ){
                                obj.text = item.text;
                            }
                        });
                    });
                }
                if( $scope.settings.nbdesigner_enable_text_check_lang == 'yes' ){
                    $scope.checkCharacter( item );
                }
                $scope.updateLayersList();
            }
            angular.merge($scope.stages[$scope.currentStage].states.boundingObject, {visibility: 'hidden'});   
            $scope.updateApp();
        };
        $scope.onDblclick = function(options){
            var item = options.target;
            if( item ){
                if( item.type === 'activeSelection' ){
                    $scope.deactiveAllLayer();
                } else if( !!item.get('maskId') && !$scope.stages[$scope.currentStage].states.lockMask ){
                    $scope.editMask();
                    var _stage = $scope.stages[$scope.currentStage];
                    _stage.states.corners = [];
                }
            }
        };
        $scope.onDropOnCanvas = function( op ){
            $scope.stageEvent.dropped = true;
            if( op.target ){
                $scope.stageEvent.target = op.target;
            }
        };
        $scope.onDragenterOnCanvas = function( op ){};
        $scope.onDragleaveOnCanvas = function( op ){};
        /* END Action on canvas*/

        /* Calculate */
        $scope.addRulerGuideLine = function( $event, direction ){
            var stage = $scope.stages[$scope.currentStage],
            el = jQuery($event.currentTarget),
            stageEl = el.parent('.stage'),
            stagePos = stageEl.offset(),
            top = $event.pageY - stagePos.top,
            left = $event.pageX - stagePos.left;
            stage.rulerLines[direction].push({top: top, left: left});
        };
        $scope.calcStyleGuideline = function(line, cf, ratio, direction){
            var style = {};
            var viewPort = $scope.calcViewport();
            if( direction == 'hor' ){
                style.top = (line.top > 40 ? ( 40 + (line.top - 40) * ratio - 3) : (line.top - 3) ) + 'px';
                style.width = ((cf.cwidth * ratio > viewPort.width ? cf.cwidth * ratio : viewPort.width) + 100) + 'px';
            }else{
                var additionalPadding = (cf.cwidth * ratio - viewPort.width) / 2;
                if(additionalPadding < 0){
                    if( line.left <= 50 ){
                        style.left = line.left;
                    }else{
                        style.left = viewPort.width / 2 - ( viewPort.width / 2 - (line.left-50) ) * ratio + 50;
                    }
                }else{
                    style.left = viewPort.width / 2 - ( viewPort.width / 2 - (line.left - 50) ) * ratio + 50 + additionalPadding;
                }
                style.left = ( style.left - 3 )+ 'px';
                style.height = ((cf.cheight * ratio > viewPort.height ? cf.cheight * ratio : viewPort.height) + 90) + 'px';
            }
            return style;
        };
        $scope.calcRulerPaddingLeft = function(cwidth){
            var viewPort = $scope.calcViewport();
            var additionalPadding = (viewPort.width - cwidth) / 2;
            additionalPadding = additionalPadding > 0 ? (additionalPadding + 50) : 50;
            return additionalPadding + 'px';
        };
        $scope.calcRulerPaddingTop = function(){
            return '40px';
        };
        $scope.theFirstCalcViewport = true;
        $scope.viewPort = {};
        $scope.calcViewport = function(){
            var _offsetWidth = checkMobileDevice() ? 20 : 100,
                _offsetHeight = checkMobileDevice() ? 70 : 100,
                _width = jQuery('.nbd-stages').width() - _offsetWidth,
                _height = jQuery('.nbd-stages').height() - _offsetHeight;

            if( navigator.userAgent.indexOf("Safari") != -1 && navigator.userAgent.indexOf("CriOS") == -1 ){
                _offsetHeight = checkMobileDevice() ? 60 : 100;
                var ratio = window.devicePixelRatio || 1;
                if( checkMobileDevice() ){
                    var screen = {
                        width : window.screen.width * ratio,
                        height : window.screen.height * ratio
                    };
                    if( ( screen.width == 1125 && screen.height === 2436 ) || ( screen.width == 1242 && screen.height === 2688 ) || ( screen.width == 828 && screen.height === 1792 ) ){
                        _offsetHeight = 180;
                    }
                }
            };

            if( navigator.userAgent.indexOf("CriOS") != -1 ){
                var ratio = window.devicePixelRatio || 1;
                if( checkMobileDevice() ){
                    var screen = {
                        width : window.screen.width * ratio,
                        height : window.screen.height * ratio
                    };
                    if( ( screen.width == 1125 && screen.height === 2436 ) || ( screen.width == 1242 && screen.height === 2688 ) || ( screen.width == 828 && screen.height === 1792 ) ){
                        _offsetHeight = 180;
                    }
                }
            }

            _height = jQuery('.nbd-stages').height() - _offsetHeight;
            if( $scope.theFirstCalcViewport ){
                $scope.viewPort = {width: _width, height: _height};
            }
            $scope.theFirstCalcViewport = false;
            return {width: _width, height: _height};
        };
        $scope.calcStyle = function(value){
            return value + 'px';
        };
        $scope.getDPI = function() {
            var div = document.createElement( "div");
            div.style.height = "1in";
            div.style.width = "1in";
            div.style.top = "-200%";
            div.style.left = "-200%";
            div.style.position = "absolute";
            div.style.visibility = "hidden";
            div.style.opacity = "0";
            document.body.appendChild(div);
            var dpi =  div.offsetHeight;
            document.body.removeChild( div );
            return dpi;
        };
        $scope.processProductSettings = function(){
            var unitRatio = 1;
            switch( $scope.settings.nbdesigner_dimensions_unit ){
                case 'in':
                    unitRatio = 2.54;
                    break;
                case 'mm':
                    unitRatio = 0.1;
                    break;
                case 'ft':
                    unitRatio = 30.48;
                    break;
                case 'px':
                    unitRatio = 2.54 / parseFloat( $scope.settings.product_data.option.dpi );
                    break;
                default:
                    unitRatio = 1;
                    break;
            }
            $scope.rateConvert2Px = $scope.rateConvertCm2Px96dpi * unitRatio * parseFloat($scope.settings.product_data.option.dpi) / 96;
            var viewPort = $scope.calcViewport();
            var scaleRange = [0.1, 0.25, 0.3, 0.5, 0.75, 1, 1.25, 1.5, 1.75, 2, 3, 4, 5], 
                maxSize = checkMobileDevice() ? 1E3 : 2E3;
            $scope.stages = [];
            _.each($scope.settings.product_data.product, function(side, index){
                var _width = side.product_width * $scope.rateConvert2Px,
                    _height = side.product_height * $scope.rateConvert2Px,
                    designViewPort = $scope.fitRectangle(viewPort.width, viewPort.height, _width, _height, true),
                    fillScale = _width / designViewPort.width,
                    minScale = 200 / Math.max(designViewPort.width, designViewPort.height),
                    maxScale = maxSize / Math.max(designViewPort.width, designViewPort.height),
                    screenViewPort = $scope.fitRectangle(screen.width, screen.height, _width, _height, true),
                    fullScreenScale = screenViewPort.width / designViewPort.width;
                var _scaleRange = scaleRange.filter(function(item){
                    return item >= minScale && item <= maxScale;
                });
                $scope.stages[index] = {
                    config: {
                        _width: _width,
                        _height: _height,
                        name: side.name,
                        width: designViewPort.width * side.real_width / side.product_width,
                        height: designViewPort.width * side.real_height / side.product_width,
                        top: designViewPort.width * side.real_top / side.product_width,
                        left: designViewPort.width * side.real_left / side.product_width,
                        cwidth: designViewPort.width,
                        cheight: designViewPort.height,
                        bleed_lr: designViewPort.width * side.bleed_left_right / side.product_width,
                        bleed_tb: designViewPort.width * side.bleed_top_bottom / side.product_width,
                        margin_lr: designViewPort.width * side.margin_left_right / side.product_width,
                        margin_tb: designViewPort.width * side.margin_top_bottom / side.product_width,
                        pWidth: side.product_width,
                        pHeight: side.product_height,
                        bgType: side.bg_type,
                        bgColor: side.bg_color_value,
                        bgImage: side.img_src,
                        showBleed: side.show_bleed,
                        showOverlay: side.show_overlay,
                        showSafeZone: side.show_safe_zone,
                        area_design_type: side.area_design_type,
                        show_overlay: side.show_overlay,
                        // img_overlay: side.img_overlay,
                        // img_overlay: side.img_overlay.url
                    },
                    states: {},
                    undos: [],
                    redos: [],
                    layers: [],
                    canvas: {},
                    rulers: [],
                    rulerLines: {vers: [], hors: []}
                };
                if( angular.isDefined( side.bleed_radius ) && side.bleed_radius != 0 ){
                    $scope.stages[index].config.bleed_radius = designViewPort.width * side.bleed_radius / side.product_width;
                    $scope.stages[index].config.safezone_radius = designViewPort.width * side.safezone_radius / side.product_width;
                }
                var _state = $scope.stages[index].states;
                angular.copy($scope.defaultStageStates, _state);
                var factor = 6.4516;
                switch( $scope.settings.nbdesigner_dimensions_unit ){
                    case 'in':
                        factor = 1;
                        break;
                    case 'mm':
                        factor = 645.16;
                        break;
                    case 'ft':
                        factor = 1 / 144;
                        break;
                    case 'px':
                        factor = parseFloat( $scope.settings.product_data.option.dpi ) * parseFloat( $scope.settings.product_data.option.dpi );
                        break;
                    default:
                        factor = 6.4516;
                        break;
                }
                _state.ratioConvertFont = designViewPort.width / (side.product_width / unitRatio * 2.54 * 72) * factor;
                _scaleRange.forEach(function(value){
                    value != 1 && _state.scaleRange.push({ratio: value, value: (value * 100).toFixed() + '%', label: (value * 100).toFixed() + '%'});
                });
                _state.scaleRange.push({ratio: 1, value: '100%', label: 'Fit'});
                _state.scaleRange.push({ratio: fullScreenScale, value: (fullScreenScale * 100).toFixed() + '%', label: (fullScreenScale * 100).toFixed() + '%'});
                if( fillScale >= minScale && fillScale <= maxScale  ) _state.scaleRange.push({ratio: fillScale, value: (fillScale * 100).toFixed() + '%', label: 'Fill'});
                
                var printFactor = 2.54;
                switch( $scope.settings.nbdesigner_dimensions_unit ){
                    case 'in':
                        printFactor = 1;
                        break;
                    case 'mm':
                        printFactor = 25.4;
                        break;
                    case 'ft':
                        printFactor = 1 / 12;
                        break;
                    case 'px':
                        printFactor = parseFloat( $scope.settings.product_data.option.dpi );
                        break;
                    default:
                        printFactor = 2.54;
                        break;
                }

                var dpi = $scope.getDPI(),
                printSizeWidth = side.product_width / printFactor * dpi,
                printSizeHeight = side.product_height / printFactor * dpi;
                
                var printScale = 0;
                if( printSizeWidth < maxSize && printSizeHeight < maxSize && printSizeWidth > minScale && printSizeHeight > minScale ){
                    printScale = printSizeWidth / designViewPort.width;
                    _state.scaleRange.push({ratio: printScale, value: (printScale * 100).toFixed() + '%', label: 'Print Size'});
                }
                _state.scaleRange = _.sortBy(_state.scaleRange, [function(o) { return o.ratio; }]);
                _state.currentScaleIndex = _.findIndex(_state.scaleRange, function(o) { return o.ratio == 1; });
                _state.fitScaleIndex = _.findIndex(_state.scaleRange, function(o) { return o.ratio == 1; });
                _state.fillScaleIndex = _.findIndex(_state.scaleRange, function(o) { return o.ratio == fillScale; });
                _state.fullScreenScaleIndex = _.findIndex(_state.scaleRange, function(o) { return o.ratio == fullScreenScale; });
                _state.printScaleIndex = _.findIndex(_state.scaleRange, function(o) { return o.ratio == printScale; });

                $timeout(function(){
                    if( angular.isDefined( $scope.areaDesignShapes[index] ) && $scope.areaDesignShapes[index] ){
                        $scope.changeAreaDesignShape( index, $scope.areaDesignShapes[index] );
                    }
                });
            });
            if( $scope.settings.task == 'typography' || $scope.settings.task == 'create_template' ){
                $scope.stages = [{
                        config: {},
                        states: {
                            scaleRange: [{ratio: 1, value: '100%', label: 'Fit'}, {ratio: 2, value: '200%', label: '200%'}, {ratio: 3, value: '300%', label: '300%'}],
                            currentScaleIndex: 0,
                            fitScaleIndex: 0,
                            fillScaleIndex: 0
                        },
                        undos: [],
                        redos: [],
                        layers: [],
                        canvas: {}
                    }
                ]; 
                $scope.stages[0].states.ratioConvertFont = 1;
                if( $scope.settings.task == 'create_template' ) 
                    $scope.stages[0].states.scaleRange = [{ratio: 1, value: '100%', label: 'Fit'}, {ratio: 2, value: '200%', label: '200%'}, {ratio: 3, value: '300%', label: '300%'}, {ratio: 4, value: '400%', label: '400%'}, {ratio: 5, value: '500%', label: '500%'}]
                angular.copy($scope.defaultConfig, $scope.stages[0].config);
                angular.merge($scope.stages[0].states, $scope.defaultStageStates);
            };
            ($scope.settings.showRuler && appConfig.isModern) && $scope.initRuler();
        };
        $scope.changeAreaDesignShape = function( stageIndex, svg ){
            jQuery('#stage-container-' + stageIndex + ' .stage-area-design-shape').html('').append( svg );
            $scope.areaDesignShapes[stageIndex] = svg;
            $timeout(function(){
                $scope.processAreaDesignShape(stageIndex);
            });
        };
        $scope.processAreaDesignShape = function(index){
            var stage = $scope.stages[index];
            if( angular.isUndefined( stage ) ) return;
            if( angular.isUndefined( $scope.areaDesignShapes[index] ) && $scope.areaDesignShapes[index] ) return;

            var svgWdth = stage.config.width * stage.states.scaleRange[stage.states.currentScaleIndex].ratio;
            var svgHght = stage.config.height * stage.states.scaleRange[stage.states.currentScaleIndex].ratio;

            function makeSVGElement(tag, attrs) {
                var el= document.createElementNS('http://www.w3.org/2000/svg', tag);
                for (var k in attrs)
                    el.setAttribute(k, attrs[k]);
                return el;
            }

            function standardizePathDStrFormat(str) {
                return str
                  .replace(/\n|\r/gm    , " "   )
                  .replace(/,/g         , " "   )
                  .replace(/-/g         , " -"  )
                  .replace(/([A-Za-z])/g, " $1 ")
                  .replace(/  /g        , " "   )
                  .replace(/ ([Ee]) /g  , "$1"  )
                  .replace(/^ /g        , ""    )
                  .replace(/ $/g        , ""    );
            }

            function getArrayOfPathDComponents(str) {
                str = standardizePathDStrFormat(str);
                return str.split(" ");
            }

            function getTransformedPathDStr(oldPathDStr, pathTranslX, pathTranslY, scale) {
                var BOTH_X_AND_Y = 1;
                var JUST_X = 2;
                var JUST_Y = 3;
                var NONE = 4;
                var ELLIPTICAL_ARC = 5;
                var ABSOLUTE = 6;
                var RELATIVE = 7;

                var oldPathDArr = getArrayOfPathDComponents(oldPathDStr);
                var newPathDArr = [];

                var commandParams, absOrRel, oldPathDComp, newPathDComp;

                var idx = 0;

                while (idx < oldPathDArr.length) {
                    var oldPathDComp = oldPathDArr[idx];
                    if (/^[A-Za-z]$/.test(oldPathDComp)) {
                        newPathDArr[idx] = oldPathDArr[idx];
                        switch (oldPathDComp.toUpperCase()) {
                            case "A":
                                commandParams = ELLIPTICAL_ARC;
                                break;
                            case "H":
                                commandParams = JUST_X;
                                break;
                            case "V":
                                commandParams = JUST_Y;
                                break;
                            case "Z":
                                commandParams = NONE;
                                break;
                            default:
                                commandParams = BOTH_X_AND_Y;
                        }
                        absOrRel = ((oldPathDComp === oldPathDComp.toUpperCase()) ? ABSOLUTE : RELATIVE);
                        idx += 1;
                    } else {
                        var translX, translY;
                        if (absOrRel === ABSOLUTE) {
                            translX = pathTranslX;
                            translY = pathTranslY;
                        } else if (absOrRel === RELATIVE) {
                            translX = 0;
                            translY = 0;
                        }
                        switch (commandParams) {
                            case BOTH_X_AND_Y:
                                newPathDArr[idx] = Number(oldPathDArr[idx]) * scale.X + translX;
                                newPathDArr[idx + 1] = Number(oldPathDArr[idx + 1]) * scale.Y + translY;
                                idx += 2;
                                break;
                            case JUST_X:
                                newPathDArr[idx] = Number(oldPathDArr[idx]) * scale.X + translX;
                                idx += 1;
                                break;
                            case JUST_Y:
                                newPathDArr[idx] = Number(oldPathDArr[idx]) * scale.Y + translY;
                                idx += 1;
                                break;
                            case ELLIPTICAL_ARC:
                                newPathDArr[idx] = Number(oldPathDArr[idx]) * scale.X + translX;
                                newPathDArr[idx + 1] = Number(oldPathDArr[idx + 1]) * scale.Y + translY;
                                newPathDArr[idx + 2] = Number(oldPathDArr[idx + 2]);
                                newPathDArr[idx + 3] = Number(oldPathDArr[idx + 3]);
                                newPathDArr[idx + 4] = Number(oldPathDArr[idx + 4]);
                                newPathDArr[idx + 5] = Number(oldPathDArr[idx + 5]) * scale.X + translX;
                                newPathDArr[idx + 6] = Number(oldPathDArr[idx + 6]) * scale.Y + translY;
                                idx += 7;
                                break;
                            case NONE:
                                throw new Error('numeric value should not follow the SVG Z/z command');
                                break;
                        }
                    }
                }
                return newPathDArr.join(" ");
            }

            function getTranslationAndScaling( origPathBoundingBox, svgWdth, svgHght ) {

                var origPathWdth = origPathBoundingBox.width;
                var origPathHght = origPathBoundingBox.height;
                var origPathX = origPathBoundingBox.x;
                var origPathY = origPathBoundingBox.y;

                if( origPathWdth == 0 ) return { pathTranslX: 0, pathTranslY: 0, scale: {X: 1, Y: 1} };

                var scaleBasedOnWdth = svgWdth / origPathWdth;
                var scaleBasedOnHght = svgHght / origPathHght;

                var scale = Math.min(scaleBasedOnWdth, scaleBasedOnHght);

                var scaledPathX = origPathX * scaleBasedOnWdth;
                var scaledPathY = origPathY * scaleBasedOnHght;
                var scaledPathWdth = origPathWdth * scaleBasedOnWdth;
                var scaledPathHght = origPathHght * scaleBasedOnHght;

                var scaledPathCentreX = scaledPathX + (scaledPathWdth / 2);
                var scaledPathCentreY = scaledPathY + (scaledPathHght / 2);
                var svgRootCentreX = 0 + (svgWdth / 2);
                var svgRootCentreY = 0 + (svgHght / 2);

                var pathTranslX = svgRootCentreX - scaledPathCentreX;
                var pathTranslY = svgRootCentreY - scaledPathCentreY;

                return { pathTranslX: pathTranslX, pathTranslY: pathTranslY, scale: {X: scaleBasedOnWdth, Y: scaleBasedOnHght} };
            }

            $timeout(function(){
                if( jQuery('#stage-container-' + index + ' .stage-area-design-shape svg').length == 0 ) return;

                var _viewBox = $scope.areaDesignShapes[index].match(/viewBox="(.*?)"/)[1],
                viewBox = _viewBox.split(/\s+|,/);

                var defs = makeSVGElement('defs', {}),
                clipPath = makeSVGElement('clipPath', {id: 'area-design-shape-' + index}),
                svg = document.querySelector('#stage-container-' + index + ' .stage-area-design-shape svg'),
                path = document.querySelector('#stage-container-' + index + ' .stage-area-design-shape svg > path');
                var origPathBoundingBox = path.getBBox(),
                d = path.getAttribute('d');
                oldDefs = svg.getElementsByTagName('defs')[0];
                if( oldDefs ){
                    svg.removeChild( oldDefs );
                }
                svg.insertBefore( defs, svg.firstChild );
                defs.appendChild( clipPath );

                var stageScale = stage.states.scaleRange[stage.states.currentScaleIndex].ratio;
                var obj = getTranslationAndScaling( origPathBoundingBox, svgWdth, svgHght ),
                zoomedObj = getTranslationAndScaling( origPathBoundingBox, svgWdth / stageScale, svgHght / stageScale ),
                pathTranslX = obj.pathTranslX,
                pathTranslY = obj.pathTranslY,
                scale       = obj.scale,
                zoomedPathTranslX = zoomedObj.pathTranslX,
                zoomedPathTranslY = zoomedObj.pathTranslY,
                zoomedScale       = zoomedObj.scale,
                newPathDStr = getTransformedPathDStr(d, pathTranslX, pathTranslY, scale),
                newZoomedPathDStr = getTransformedPathDStr(d, zoomedPathTranslX, zoomedPathTranslY, zoomedScale),
                newPath     = makeSVGElement('path', {d: newPathDStr});
                clipPath.appendChild( newPath );
                $scope.areaDesignClipPaths[index] = newPathDStr;
                $scope.areaDesignZoomedClipPaths[index] = newZoomedPathDStr;
                jQuery('#stage-container-' + index + ' .stage-area-design-shape svg').removeAttr('viewBox')[0].setAttribute("viewBox", viewBox[0] + " " + viewBox[1] + " " + svgWdth + " " + svgHght);

                var bleedWidth = stage.states.scaleRange[stage.states.currentScaleIndex].ratio * (stage.config.width - 2 * stage.config.bleed_lr),
                bleedHeight = stage.states.scaleRange[stage.states.currentScaleIndex].ratio * (stage.config.height - 2 * stage.config.bleed_tb),
                safeZoneWidth = stage.states.scaleRange[stage.states.currentScaleIndex].ratio * (stage.config.width - 2 * stage.config.bleed_lr - 2 * stage.config.margin_lr),
                safeZoneHeight = stage.states.scaleRange[stage.states.currentScaleIndex].ratio * (stage.config.height - 2 * stage.config.bleed_tb - 2 * stage.config.margin_tb),
                bleedScaleX = viewBox[2] / bleedWidth,
                bleedScaleY = viewBox[3] / bleedHeight,
                safeZoneScaleX = viewBox[2] / safeZoneWidth,
                safeZoneScaleY = viewBox[3] / safeZoneHeight;
                jQuery('#stage-container-' + index + ' .bleed-line').html('').append( $scope.areaDesignShapes[index] );
                jQuery('#stage-container-' + index + ' .safe-line').html('').append( $scope.areaDesignShapes[index] );

                var bleedObj = getTranslationAndScaling( origPathBoundingBox, bleedWidth, bleedHeight ),
                safeZoneObj = getTranslationAndScaling( origPathBoundingBox, safeZoneWidth, safeZoneHeight ),
                bleedPathTranslX = bleedObj.pathTranslX,
                bleedPathTranslY = bleedObj.pathTranslY,
                bleedScale       = bleedObj.scale,
                safeZonePathTranslX = safeZoneObj.pathTranslX,
                safeZonePathTranslY = safeZoneObj.pathTranslY,
                safeZoneScale       = safeZoneObj.scale,
                newBleedPathDStr = getTransformedPathDStr(d, bleedPathTranslX, bleedPathTranslY, bleedScale),
                newSafeZonePathDStr = getTransformedPathDStr(d, safeZonePathTranslX, safeZonePathTranslY, safeZoneScale);
                //jQuery('#stage-container-' + index + ' .bleed-line svg path').attr({d: newBleedPathDStr, transform: 'scale(' + bleedScaleX + ', ' + bleedScaleY + ')'});
                jQuery('#stage-container-' + index + ' .bleed-line svg').removeAttr('viewBox')[0].setAttribute("viewBox", viewBox[0] + " " + viewBox[1] + " " + bleedWidth + " " + bleedHeight);
                jQuery('#stage-container-' + index + ' .bleed-line svg path').attr({d: newBleedPathDStr});
                //jQuery('#stage-container-' + index + ' .safe-line svg path').attr({d: newSafeZonePathDStr, transform: 'scale(' + safeZoneScaleX + ', ' + safeZoneScaleY + ')'});
                jQuery('#stage-container-' + index + ' .safe-line svg').removeAttr('viewBox')[0].setAttribute("viewBox", viewBox[0] + " " + viewBox[1] + " " + safeZoneWidth + " " + safeZoneHeight);
                jQuery('#stage-container-' + index + ' .safe-line svg path').attr({d: newSafeZonePathDStr});

                $scope.updateApp();
            });
        };
        $scope.tourGuide = {
            firstTime: true,
            currentStep: -1,
            steps: []
        };
        $scope.tourGuideShowing = false;
        $scope.startTourGuide = function(){
            if( $scope.settings.is_mobile ){
                return;
            }
            if( $scope.tourGuide.currentStep == -1 ){
                var steps = [];
                jQuery.each(jQuery('[data-tour]'), function(){
                    var el = jQuery(this),
                    dataTour = el.attr('data-tour'),
                    priority = el.attr('data-tour-priority');
                    steps.push({
                        priority: priority,
                        template: 'tour_guide.' + dataTour,
                        element: el
                    });
                });
                $scope.tourGuide.steps = _.sortBy(steps, [function(s) { return s.priority; }]);
            };
            $scope.tourGuideShowing = true;
            localStorage.setItem('showTourGuide', 1);
            $scope.tourGuide.currentStep = -1;
            $timeout(function(){
                $scope.nextTour();
            },  300);
        };
        $scope.processTourComponents = function( close ){
            var targetEl = $scope.tourGuide.steps[$scope.tourGuide.currentStep].element;
            if( close ){
                jQuery('.tour-guide').removeClass('active');
                $scope.tourGuideShowing = false;
                $scope.showTemplateFieldsPopup();
                return;
            };
            var tourStepEl = jQuery('.nbd-tourStep'),
                bgTourTop = jQuery('.bgTour-top'),
                bgTourRight = jQuery('.bgTour-right'),
                bgTourBottom = jQuery('.bgTour-bottom'),
                bgTourLeft = jQuery('.bgTour-left'),
                height = targetEl.outerHeight(),
                width = targetEl.outerWidth();
            if($scope.tourGuide.firstTime){
                width = 75;
                $scope.tourGuide.firstTime = false;
            }
            var offset = targetEl.offset(),
                top = offset.top,
                left = offset.left,
                bottom = jQuery(window).outerHeight() - height - top,
                right = jQuery(window).outerWidth() - left - width;
            bgTourTop.css({
                height: top + 'px'
            });
            bgTourBottom.css({
                height: bottom + 'px'
            });
            bgTourRight.css({
                top: top + 'px',
                left: left + width + 'px',
                height: height + 'px'
            });
            bgTourLeft.css({
                top: top + 'px',
                width: left + 'px',
                height: height + 'px'
            });
            if (jQuery(window).width() > (left * 2)) {
                tourStepEl.attr('data-pos', 'left');
                tourStepEl.css({
                    top: top + 'px',
                    left: left + width + 7 + 'px'
                });
            }else{
                tourStepEl.attr('data-pos', 'right');
                tourStepEl.css({
                    top: top + 'px',
                    left: left - 7 + 'px'
                });
            }
            jQuery('.tour-guide').addClass('active');
        };
        $scope.nextTour = function(){
            if( $scope.tourGuide.currentStep < ($scope.tourGuide.steps.length - 1) ){
                $scope.tourGuide.currentStep++;
                $scope.processTourComponents();
            }
        };
        $scope.prevTour = function(){
            if( $scope.tourGuide.currentStep > 0 ){
                $scope.tourGuide.currentStep--;
                $scope.processTourComponents();
            }
        };
        $scope.updateMaskedLayers = function( stage_id ){
            function getLayerbyId( canvas, id ){
                var layer;
                canvas.forEachObject(function(obj, idx) {
                    if( obj.get('itemId') == id ) layer = obj;
                });
                return layer;
            }
            var _canvas = $scope.stages[stage_id].canvas,
            needRender = false;
            _canvas.forEachObject(function(obj, layerIndex) {
                if(!!obj.get('maskId')){
                    var id = obj.get('maskId'),
                    maskLayer = getLayerbyId( _canvas, id );
                    if( maskLayer ){
                        needRender = true;
                        maskLayer.set({opacity: 0.001, fill: '#ffffff'});
                        obj.set({clipPath: maskLayer});
                    }
                }
            });
            if( needRender ){
                $scope.renderStage( stage_id );
            }
        };
        $scope.duplicateStageIndex = -1;
        $scope.addStage = function( duplicate ){
            // disabled dynamic side
            return;
            var new_stage = {}, new_side_config = {}, stageLen = $scope.stages.length, currentStage = $scope.currentStage;
            var _canvas = $scope.stages[$scope.currentStage].canvas;
            angular.copy($scope.stages[$scope.currentStage], new_stage);
            if( angular.isDefined($scope.settings.product_data.option.new_side_name) ){
                if( angular.isUndefined($scope.settings.product_data.origin_product) ){
                    $scope.settings.product_data.origin_product = [];
                    angular.copy($scope.settings.product_data.product, $scope.settings.product_data.origin_product);
                }
                new_stage.config.name = $scope.settings.product_data.option.new_side_name;
                var max_number_side = parseInt($scope.settings.product_data.option.max_number_side);
                if( ($scope.settings.product_data.origin_product.length + max_number_side ) ==  $scope.stages.length ){
                    $scope.resource.canAdd = false;
                    return;
                }
            }
            $scope.preventLoadDesign = true;
            angular.copy($scope.settings.product_data.product[$scope.currentStage], new_side_config);
            $scope.settings.product_data.product.splice($scope.currentStage + 1, 0, new_side_config);
            $scope.resource.config.qty++;
            if( duplicate ){
                if(stageLen > ($scope.currentStage + 1)){
                    $scope.duplicateStageIndex = $scope.currentStage + 1;
                }
                $scope.resource.jsonDesign[$scope.currentStage + 1] = {};
                angular.copy(_canvas.toJSON($scope.includeExport), $scope.resource.jsonDesign[$scope.currentStage + 1]);
            }
            $scope.stages.splice($scope.currentStage + 1, 0, new_stage);
            $scope.updateApp();
            if( angular.isDefined($scope.settings.product_data.option.max_number_side) ){
                if( ($scope.settings.product_data.origin_product.length + parseInt( $scope.settings.product_data.option.max_number_side ) ) ==  $scope.stages.length ){
                    $scope.resource.canAdd = false;
                }
            };
            $timeout(function(){
                $scope.switchStage($scope.currentStage, 'next');
                if(stageLen == (currentStage + 1)){
                    if($scope.settings.dynamicStage) {
                        $scope.contextAddLayers = 'normal';
                    } else {
                        $scope.contextAddLayers = 'template';
                    }              
                    $scope.onloadTemplate = true;
                    $scope.stages[stageLen].canvas.loadFromJSON($scope.resource.jsonDesign[stageLen], function() {
                        $scope.onloadTemplate = false;
                        $scope.contextAddLayers = 'normal';
                    });
                }
            }, 100);
        };
        $scope.showTemplateFieldsPopup = function( force ){
            if( !$scope.settings.is_mobile && ( $scope.settings.ui_mode == 1 || $scope.settings.ui_mode == 2 ) && $scope.settings.nbdesigner_enable_template_mapping == 'yes' 
                    && $scope.firstTimeShowTemplateFiledsPopup && $scope.settings.is_logged != 1 && !$scope.tourGuideShowing && $scope.templateHolderFields.length > 0 ){
                $timeout(function(){
                    jQuery( '.popup-template-fields' ).nbShowPopup();
                    $scope.firstTimeShowTemplateFiledsPopup = false;
                }, 400);
            }
            if( angular.isDefined( force ) ){
                jQuery( '.popup-template-fields' ).nbShowPopup();
            }
        };
        /* Tool */
        $scope.currentCombinationColor = 0;
        $scope.currentForegroundColor = 0;
        $scope.currentBackgroundColor = 0;
        $scope.selectCombinationColor = function ( $index ) {
            var bgColor = $scope.settings.nbes_settings.combination_colors.bg_codes[$index],
                fgColor = $scope.settings.nbes_settings.combination_colors.fg_codes[$index];
            $scope.changeBackgroundCanvas( bgColor );
            $scope.changeFillAllLayers( fgColor, true );
            $scope.__colorPalette = [fgColor];
            $scope.stages[$scope.currentStage].states.text.fill = fgColor;
            $scope.currentCombinationColor = $index;
        };
        $scope.changeFillAllLayers = function(color, needRender){
            _.each($scope.stages, function(stage, index){
                var canvas = stage.canvas;
                canvas.forEachObject(function(obj) {
                    switch( obj.type ) {
                        case 'i-text':
                        case 'text':
                        case 'textbox':
                        case 'curvedText':
                            obj.set({fill: color});
                            break;
                        case 'rect':
                        case 'triangle':
                        case 'line':
                        case 'polyline':
                        case 'polygon':
                        case 'circle':
                        case 'ellipse':
                        case 'path-group':
                        case 'path':
                        case 'group':
                            _.each(obj._objects, function(path, index){
                                if( path.get('fill') != '' ){
                                    path.set({fill: color});
                                }
                                if( path.get('stroke') != null ){
                                    path.set({stroke: color});
                                }
                            });
                            break;
                    }
                    if( obj.get('fill') != '' ){
                        obj.set({fill: color});
                    }
                    if( obj.get('stroke') != null ){
                        obj.set({stroke: color});
                    }
                });
                if( needRender ) canvas.renderAll();
            });
        };
        $scope.changeFill = function(color){
            var _stage = $scope.stages[$scope.currentStage],
                _canvas = _stage.canvas;
            if( angular.equals({}, _canvas) ) return;
            var item = _canvas.getActiveObject();
            $scope.beforeObjectModify(item);
            if( !_stage.states.isPath ){
                _stage.states.text.fill = color;
                item.set({fill: color});
                if( $scope.stages[$scope.currentStage].states.isShape ){
                    _stage.states.svg.groupPath[_stage.states.svg.currentPath].color = color;
                }
            }else{
                item.set({dirty: true});
                _.each(_stage.states.svg.groupPath[_stage.states.svg.currentPath].index, function(path_index){
                    if( path_index == -2 ){
                        item.set({fill: color});
                    }else{
                        if( path_index > -1 ){
                            item._objects[path_index].set({fill: color});
                        }else{
                            item.set({stroke: color});
                        }
                    }
                });
                _stage.states.svg.groupPath[_stage.states.svg.currentPath].color = color;
            }
            if( angular.isDefined( $scope.settings.nbes_enable_settings ) && $scope.settings.nbes_enable_settings.combination != 1 
                    && $scope.settings.nbes_enable_settings.foreground == 1 && angular.isDefined( $scope.settings.nbes_settings ) && $scope.settings.nbes_settings.force_fg == 1
                    && angular.isDefined( $scope.settings.nbes_settings.foreground_colors ) && $scope.settings.nbes_settings.foreground_colors.codes.length > 0 ){
                $scope.changeFillAllLayers( color, false );
                var index = $scope.settings.nbes_settings.foreground_colors.codes.indexOf( color );
                $scope.currentForegroundColor = index > -1 ? index : 0;
            }
            $scope.renderStage();
            $scope.afterObjectModify();
        };
        $scope.forceForeground = function( item ){
            if( angular.isDefined( $scope.settings.nbes_enable_settings ) && angular.isDefined( $scope.settings.nbes_settings ) ){
                var foreFill = false, color = '';
                if( $scope.settings.nbes_enable_settings.combination == 1 && angular.isDefined( $scope.settings.nbes_settings.combination_colors ) && $scope.settings.nbes_settings.combination_colors.fg_codes.length > 0 ){
                    foreFill = true;
                    color = $scope.settings.nbes_settings.combination_colors.fg_codes[ $scope.currentCombinationColor ];
                } else if( $scope.settings.nbes_enable_settings.foreground == 1 && $scope.settings.nbes_settings.force_fg == 1 && angular.isDefined( $scope.settings.nbes_settings.foreground_colors ) 
                        && $scope.settings.nbes_settings.foreground_colors.codes.length > 0 ){
                    foreFill = true;
                    color = $scope.settings.nbes_settings.foreground_colors.codes[ $scope.currentForegroundColor ];
                }
                if( foreFill ){
                    switch( item.type ) {
                        case 'i-text':
                        case 'text':
                        case 'textbox':
                        case 'curvedText':
                            item.set({fill: color});
                            break;
                        case 'rect':
                        case 'triangle':
                        case 'line':
                        case 'polygon':
                        case 'circle':
                        case 'ellipse':
                        case 'path-group':
                        case 'path':
                        case 'group':
                            _.each(item._objects, function(path, index){
                                if( path.get('fill') != '' ){
                                    path.set({fill: color});
                                }
                                if( path.get('stroke') != null ){
                                    path.set({stroke: color});
                                }
                            });
                            break;
                    }
                    if( item.get('fill') != '' ){
                        item.set({fill: color});
                    }
                    if( item.get('stroke') != null ){
                        item.set({stroke: color});
                    }
                }
            }
        };
        $scope.changeBackgroundCanvas = function (color) {
            var _stage = $scope.stages[$scope.currentStage],
                _canvas = _stage.canvas;
            $scope.showDesignTab();
            _canvas.backgroundColor = color;
            $scope.addColor(color);
            _canvas.forEachObject(function(obj) {
                if( obj.isBgImg ){
                    _canvas.remove(obj);
                    $scope.updateLayersList();
                }
            });
            _canvas.renderAll();
            $scope.afterObjectModify();
        };
        $scope.removeBackgroundCanvas = function(){
            var _stage = $scope.stages[$scope.currentStage],
                _canvas = _stage.canvas;
            _canvas.backgroundColor = null;
            _canvas.forEachObject(function(obj) {
                if( obj.isBgImg ){
                    _canvas.remove(obj);
                }
            });
            _canvas.renderAll();
            $scope.afterObjectModify();
        };
        $scope.addColor = function(color){
            var _color = angular.isDefined(color) ? color : $scope.currentColor;
            $scope.listAddedColor.push(_color);
            $scope.listAddedColor = _.uniq($scope.listAddedColor);
            jQuery('.nbd-perfect-scroll').perfectScrollbar('update');
        };
        $scope.initEyeDropper2 = function($event, global){
            var _stage = $scope.stages[$scope.currentStage],
            _canvas = _stage.canvas,
            ctx = _canvas.getContext('2d'),
            canvasEl = jQuery('#stage-container-' + $scope.currentStage + ' .lower-canvas'),
            canvasOffset = canvasEl.offset();

            jQuery('.nbd-eyedropper-inner-wrap').css({
                left: canvasOffset.left,
                top: canvasOffset.top,
                width: _canvas.width,
                height: _canvas.height
            });
            jQuery('.nbd-color-palette').removeClass('show');
            jQuery('.nbd-eyedropper-wrap').addClass('active');
            jQuery('.nbd-eyedropper-inner-wrap').off('mouseenter').on('mouseenter', function(){
                jQuery(this).addClass('active');
            });
            jQuery('.nbd-eyedropper-inner-wrap').off('mouseleave').on('mouseleave', function(){
                jQuery(this).removeClass('active');
            });
            jQuery('.nbd-eyedropper-inner-wrap').off('mousemove').on('mousemove', function(evt){
                var infoLeft = evt.clientX - (((evt.clientX + 100) >= window.innerWidth) ? 90 : -5),
                infoTop = evt.clientY - (((evt.clientY - 15) <= 0) ? -20 : 25),
                canvasLeft =  evt.clientX - canvasOffset.left,
                canvasTop = evt.clientY - canvasOffset.top + 21;
                if( canvasLeft > 0 && canvasTop > 0 && canvasLeft <= _canvas.width && canvasTop <= _canvas.height ){
                    var data = ctx.getImageData(canvasLeft, canvasTop, 1, 1).data;
                    if( data[3] == 0 ){
                        data[0] = data[1] = data[2] = 255;
                    }
                    var color = tinycolor({r: data[0], g: data[1], b: data[2]}).toHexString();
                    jQuery('.nbd-eyedropper-info-wrap').removeClass('out-stage');
                    jQuery('.nbd-eyedropper-info-wrap').css({
                        left: infoLeft,
                        top: infoTop
                    });
                    jQuery('.nbd-eyedropper-color').css({background: color});
                    jQuery('.nbd-eyedropper-color-code').text(color.toUpperCase());
                }else{
                    jQuery('.nbd-eyedropper-info-wrap').addClass('out-stage');
                }
            });
            jQuery('.nbd-eyedropper-inner-wrap').off('mousedown').on('mousedown', function(evt){
                jQuery(this).removeClass('active');
                jQuery('.nbd-eyedropper-wrap').removeClass('active');
                var canvasLeft = evt.clientX - canvasOffset.left,
                canvasTop = evt.clientY - canvasOffset.top + 21;
                if( canvasLeft > 0 && canvasTop > 0 && canvasLeft <= _canvas.width && canvasTop <= _canvas.height ){
                    var data = ctx.getImageData(canvasLeft, canvasTop, 1, 1).data;
                    if( data[3] == 0 ){
                        data[0] = data[1] = data[2] = 255;
                    }
                    var color = tinycolor({r: data[0], g: data[1], b: data[2]}).toHexString();
                    if( global ){
                        $scope.globalPicker.color = color;
                        $scope.addColor( $scope.globalPicker.color );
                        $scope.changeFill( $scope.globalPicker.color );
                    }else{
                        $scope.currentColor = color;
                        $scope.addColor();
                        $scope.changeFill(color);
                    }
                }
            });
            jQuery('.nbd-eyedropper-wrap').off('mousedown').on('mousedown', function(evt){
                jQuery(this).removeClass('active');
            });
        };
        /* Ruler and ruler guide line */
        $scope.toggleRuler = function(){
            $scope.settings.showRuler = !$scope.settings.showRuler;
            if($scope.settings.showRuler && appConfig.isModern){
                $scope.initRuler();
            }else{
                $scope.clearGuides();
            };
        };
        $scope.initRuler = function(){
            var viewPort = $scope.calcViewport();
            $timeout(function(){
                _.each($scope.settings.product_data.product, function(side, index){
                    var stage = $scope.stages[index];
                    stage.hozRuler = jQuery('#hoz-ruler-'+index).nbdRuler({layout: 'horizontal', viewPort: viewPort, config: stage.config, zoomRatio: stage.states.scaleRange[stage.states.currentScaleIndex].ratio, unit: $scope.settings.nbdesigner_dimensions_unit});
                    stage.verRuler = jQuery('#ver-ruler-'+index).nbdRuler({layout: 'vertical', viewPort: viewPort, config: stage.config, zoomRatio: stage.states.scaleRange[stage.states.currentScaleIndex].ratio, unit: $scope.settings.nbdesigner_dimensions_unit});
                    stage.hozRuler.render();
                    stage.verRuler.render();
                });
            }, 100);
        };
        $scope.clearGuides = function(){
            $scope.stages[$scope.currentStage].rulerLines = {vers: [], hors: []};
        };
        $scope.fitRectangle = function(x1, y1, x2, y2, fill){
            var rec = {};
            if(x2 < x1 && y2 < y1){
                if(fill){
                    if(x1/y1 > x2/y2){
                        rec.width = x2 * y1 / y2;
                        rec.height = y1;
                        rec.top = 0;
                        rec.left = (x1 * y2 - x2 * y1) / y2 / 2;
                    }else {
                        rec.width = x1;
                        rec.height = x1 * y2 / x2;
                        rec.top = (x2 * y1 - x1 * y2) / x2 / 2;
                        rec.left = 0;
                    }
                }else {
                    rec.top = (x1 - x2) / 2;
                    rec.left = (y1 - y2) / 2;
                    rec.width = x2;
                    rec.height = y2;
                }
            } else if( x1/y1 > x2/y2 ){
                rec.width = x2 * y1 / y2;
                rec.height = y1;
                rec.top = 0;
                rec.left = (x1 * y2 - x2 * y1) / y2 / 2;
            } else {
                rec.width = x1;
                rec.height = x1 * y2 / x2;
                rec.top = (x2 * y1 - x1 * y2) / x2 / 2;
                rec.left = 0;
            }
            return rec;
        };
        /* Screen */
        $scope.enableFullScreenMode = function(){
            var ele = document.getElementById('nbd-stages');
            requestFullScreen(ele);  
        };
        $scope.exitFullscreenMode = function(){
            exitFullscreen();
        };
        $scope.toggleStageFullScreenMode = function(){
            _.each($scope.stages, function(stage, index){
                var zoomIndex = $scope.fullScreenMode ?  stage.states.fullScreenScaleIndex : stage.states.fitScaleIndex;
                $scope.zoomStage(zoomIndex, index);
                $scope.deactiveAllLayer(index);
                $scope.renderStage(index);
            });
        };
        /* Design tools */
        $scope.setGeometricalObjectAttr = function( type, value ){
            var _stage = $scope.stages[$scope.currentStage],
                _states = _stage.states,
                _canvas = _stage['canvas'],
                item = _canvas.getActiveObject();
            if( !item ) return;
            switch( type ){
                case 'fill':
                    item.set({fill: value});
                    _states.geoObject.fill = value;
                    break;
                case 'strokeUniform':
                    item.set({strokeUniform: value});
                    break;
                case 'stroke':
                    if( value === false ){
                        item.set({stroke: null});
                        _states.geoObject.stroke = '#ffffff';
                    }else{
                        item.set({stroke: value});
                        _states.geoObject.stroke = value;
                    }
                    break;
                case 'strokeWidth':
                    var strokeWidth = value * 1;
                    strokeWidth =  isNaN( strokeWidth ) ? 0 : Math.abs( strokeWidth ),
                    item.set({strokeWidth: strokeWidth});
                    break;
                case 'strokeDashArray':
                    var dash1 = value[0] * 1,
                    dash2 = value[1] * 1;
                    if( isNaN( dash1 ) || isNaN( dash2 ) || dash1 == 0 || dash2 == 0 ){
                        item.set({strokeDashArray: null});
                    }else{
                        var i = isNaN( dash1 ) ? 0 : Math.abs( dash1 ),
                        j = isNaN( dash2 ) ? 0 : Math.abs( dash2 );
                        item.set({strokeDashArray: [i, j]});
                    }
                    break;
            }
            item.setCoords();
            $scope.afterObjectModify();
            $scope.renderStage();
        };
        $scope.addGeometricalObject = function( type ){
            var _canvas = $scope.stages[$scope.currentStage]['canvas'];
            var object;
            $scope.disableDrawMode();
            switch(type){
                case 'rect':
                    object = new fabric.Rect({
                        width: 50,
                        height: 50
                    });
                    break;
                case 'circle':
                    object = new fabric.Circle({
                        radius: 50
                    });
                    break;
                case 'triangle':
                    object = new fabric.Triangle({
                        width: 50,
                        height: 50
                    });
                    break;
                case 'hexagon':
                    object = new fabric.Polygon( [{x: 10,y: 17.321},{x: -10,y: 17.321},{x: -20,y: 0},{x: -10,y: -17.321},{x: 10,y: -17.321},{x: 20,y: 0}] );
                    break;
                case 'line':
                    object = new fabric.Line([0, 20, 100, 20], {stroke: printcart_default_settings.color});
                    break;
                case 'polyline':
                    object = new fabric.Polyline([
                        { x: 10, y: 10 },
                        { x: 50, y: 30 },
                        { x: 40, y: 70 },
                        { x: 60, y: 50 },
                        { x: 100, y: 150 },
                        { x: 40, y: 100 }
                    ]);
                    break;
                case 'ellipse':
                    object = new fabric.Ellipse({
                        rx: 80,
                        ry: 50
                    });
                    break;
            }
            _canvas.add(object);
        };
        /* Click Chuột phải trong canvas */
        $scope.$on('nbd:contextmenu', function(event, e){
            $scope.contextMenu(e);
        });
        $scope.ctxMenuStyle = {
            'top': '17%',
            'left': '33%',
            'visibility': 'hidden'
        };
        $scope.contextMenu = function(e){
            if( $scope.stages[$scope.currentStage].states.isEditing || $scope.stages[$scope.currentStage].states.isMask ) return;
            e.preventDefault();
            var posX = e.pageX,
                posY = e.pageY;
            var contextEl = angular.element(document.getElementById('nbd-context-menu'))[0],
                height = contextEl.clientHeight,
                width = contextEl.clientWidth; 
            if($scope.workBenchWidth < (posX + width + 15)) posX = $scope.workBenchWidth - width - 15;
            if($scope.workBenchHeight < (posY + height + 15)) posY = $scope.workBenchHeight - height - 15;
            $scope.ctxMenuStyle = {
                'visibility': 'visible',
                top: posY,
                left: posX
            }
            $scope.updateApp();
        };
        /* Function chuột phải */
        $scope.rotateLayer = function(command){
            var _canvas = this.stages[this.currentStage]['canvas'],
            item = _canvas.getActiveObject();
            $scope.beforeObjectModify(item);
            switch(command){
                case 'reflect-hoz':
                    item.toggle("flipY");
                    break;
                case 'reflect-ver':
                    item.toggle("flipX");
                    break;
                case '90cw':
                    var angle = item.get('angle') + 90;
                    if (angle > 360) angle = angle - 360;
                    if (angle < 0) angle = angle + 360;
                    item.set({angle: angle});
                    break;
                case '90ccw':
                    var angle = item.get('angle') - 90;
                    if (angle > 360) angle = angle - 360;
                    if (angle < 0) angle = angle + 360;
                    item.set({angle: angle});
                    break;
                case '180':
                    var angle = item.get('angle') + 180;
                    if (angle > 360) angle = angle - 360;
                    if (angle < 0) angle = angle + 360;
                    item.set({angle: angle});
                    break;
                default:
                    var angle = parseInt(command);
                    item.set({angle: angle});
            };   
            item.setCoords();
            this.renderStage();
            $scope.afterObjectModify();
        };
        $scope.fitToStage = function( direction, item ){
            var stage = $scope.stages[$scope.currentStage],
                _canvas = stage.canvas,
                item = angular.isDefined(item) ? item : _canvas.getActiveObject();
            if(!item) return;
            direction = angular.isDefined(direction) ? direction : 'both';
            var originX = item.get('originX'),
            originY = item.get('originY'),
            scale = stage.states.scaleRange[stage.states.currentScaleIndex].ratio;
            switch(direction){
                case 'width':
                    var _left = originX == 'center' ? _canvas.width / 2 /scale : 0;
                    item.set({
                        left: _left,
                        scaleX: _canvas.width / item.width / scale,
                        scaleY: _canvas.width / item.width / scale
                    });
                    _canvas.viewportCenterObjectV(item);
                    break;
                case 'height':
                    var _top = originY == 'center' ? _canvas.height / 2 /scale : 0;
                    item.set({
                        top: _top,
                        scaleX: _canvas.height / item.height / scale,
                        scaleY: _canvas.height / item.height / scale
                    });
                    _canvas.viewportCenterObjectH(item);
                    break;
                default:
                    var _top = originY == 'center' ? _canvas.height / 2 /scale : 0;
                    var _left = originX == 'center' ? _canvas.width / 2 /scale : 0;
                    item.set({
                        top: _top,
                        left: _left,
                        scaleX: _canvas.width / item.width / scale,
                        scaleY: _canvas.height / item.height / scale
                    });
                    _canvas.viewportCenterObjectH(item);
                    _canvas.viewportCenterObjectV(item);
            }
            item.setCoords();
            $scope.updateCorners();
            $scope.renderStage(); 
            $scope.afterObjectModify();
        };
        $scope.setAsBackground = function(){
            var _stage = $scope.stages[$scope.currentStage],
            _canvas = _stage.canvas,
            item = _canvas.getActiveObject(),
            scale = _stage.states.scaleRange[_stage.states.currentScaleIndex].ratio;
            if( item ){
                if( !!item.isBgImg ) return;
                if(!!item.get('maskId')){
                    return;
                }
                _canvas.backgroundColor = null;
                _canvas.forEachObject(function(obj) {
                    if( obj.isBgImg ){
                        _canvas.remove(obj);
                    }
                });
                var min_width = _canvas.width / scale,
                min_height = _canvas.height / scale,
                new_width = min_width,
                new_height = min_height;
                if( ( item.width / item.height ) > ( min_width / min_height ) ){
                    new_height = min_height;
                    new_width = new_height / item.height * item.width;
                }else{
                    new_width = min_width;
                    new_height = new_width / item.width * item.height;
                }
                item.set({
                    scaleX: new_width / item.width,
                    scaleY: new_height / item.height,
                    selectable: false,
                    isBgImg: 1
                });
                _canvas.viewportCenterObject(item);
                item.sendToBack();
                $scope.deactiveAllLayer();
                _canvas.renderAll();
                $scope.afterObjectModify();
            }
        };
        $scope.setStackPosition = function(command, onLayer, _item){
            var item = _item ? _item : $scope.stages[$scope.currentStage]['canvas'].getActiveObject();
            $scope.beforeObjectModify(item);
            switch(command){
                case 'bring-front':
                    item.bringToFront();
                    $scope.setStackLayerAlwaysOnTop();
                    break;
                case 'bring-forward':
                    item.bringForward();
                    break;
                case 'send-backward':
                    item.sendBackwards();
                    break;
                case 'send-back':
                    item.sendToBack();
                    break;
                default:
                    var index = parseInt(command);
                    item.moveTo(index);
                    break;
            }
            $scope.setStackLayerAlwaysOnBottom();
            $scope.renderStage();
            $scope.afterObjectModify();
            if(!onLayer) $scope.updateLayersList();
        };
        $scope.translateLayer = function(command){
            var stage = $scope.stages[$scope.currentStage],
                _canvas = stage.canvas,
                item = _canvas.getActiveObject();
            if(!item) return;
                var  bound = item.getBoundingRect(),
                scale = stage.states.scaleRange[stage.states.currentScaleIndex].ratio,
                left = item.get('left'),
                top = item.get('top'),
                originX = item.get('originX'),
                originY = item.get('originY');
            $scope.beforeObjectModify(item);
            stage.states.isShowToolBox = false;
            switch(command) {
                case 'horizontal':
                    _canvas.viewportCenterObjectH(item);
                    break;
                case 'vertical':
                    _canvas.viewportCenterObjectV(item);
                    break;
                case 'center':
                    _canvas.viewportCenterObjectH(item);
                    _canvas.viewportCenterObjectV(item);
                    break;
                case 'top':
                    var _top = originY == 'center' ? bound.height / 2 /scale : top - bound.top / scale;
                    item.set({top: _top});
                    break;
                case 'top-left':
                    var _top = top - bound.top / scale, _left = left - bound.left / scale;
                    if( originX == 'center' ){
                        _left = bound.width / 2 /scale;
                    }
                    if( originY == 'center' ){
                        _top = bound.height / 2 /scale;
                    }
                    item.set({top: _top, left: _left});
                    break;
                case 'top-center':
                    _canvas.viewportCenterObjectH(item);
                    var _top = originY == 'center' ? bound.height / 2 /scale : top - bound.top / scale;
                    item.set({top: _top});
                    break; 
                case 'top-right':
                    var _top = originY == 'center' ? bound.height / 2 /scale : top - bound.top / scale,
                    _left = left + (_canvas.width - bound.width - bound.left)/scale;
                    item.set({top: _top, left: _left});
                    break;
                case 'bottom':
                    var _top = top + (_canvas.height - bound.height - bound.top)/scale;
                    item.set({top: _top});
                    break;
                case 'bottom-left':
                    var _left = originX == 'center' ? bound.width / 2 /scale :  left - bound.left / scale,
                    _top = top + (_canvas.height - bound.height - bound.top)/scale;
                    item.set({left: _left, top: _top});
                    break; 
                case 'bottom-center':
                    _canvas.viewportCenterObjectH(item);
                    var _top = top + (_canvas.height - bound.height - bound.top)/scale;
                    item.set({top: _top});
                    break;
                case 'bottom-right':
                    var _left = left + (_canvas.width - bound.width - bound.left)/scale,
                    _top = top + (_canvas.height - bound.height - bound.top)/scale;
                    item.set({left: _left, top: _top});
                    break;
                case 'left':
                    var _left = originX == 'center' ? bound.width / 2 /scale :  left - bound.left / scale;
                    item.set({left: _left});
                    break;
                case 'middle-left':
                    _canvas.viewportCenterObjectV(item);
                    var _left = originX == 'center' ? bound.width / 2 /scale : left - bound.left / scale;
                    item.set({left: _left});
                    break;
                case 'right':
                    var _left = left + (_canvas.width - bound.width - bound.left)/scale;
                    item.set({left: _left});
                    break;
                case 'middle-right':
                    _canvas.viewportCenterObjectV(item);
                    var _left = left + (_canvas.width - bound.width - bound.left)/scale;
                    item.set({left: _left});
                    break;
            };
            item.setCoords();
            $scope.renderStage();
            $scope.afterObjectModify();
        };
        $scope.alignLayer = function(command){
            var _canvas = this.stages[this.currentStage].canvas,
                group = _canvas.getActiveObject(),
                items = _canvas.getActiveObjects(),
                _bound = items[0].getBoundingRect(),
                position = {
                    left: _bound.left,
                    top: _bound.top,
                    right: _bound.left + _bound.width,
                    bottom: _bound.top + _bound.height
                };  
            var _leftPosition = [],
                _topPosition = [],
                totalWidth = 0,
                totalHeight = 0;

            items.forEach(function(item, index){
                var bound = item.getBoundingRect();
                if(bound.left < position.left) position.left = bound.left;
                if(bound.top < position.top) position.top = bound.top;
                if(bound.left + bound.width > position.right) position.right = bound.left + bound.width;
                if(bound.top + bound.height > position.bottom) position.bottom = bound.top + bound.height;
                _leftPosition.push({index: index, value: bound.left});
                _topPosition.push({index: index, value: bound.top});
                totalWidth += bound.width;
                totalHeight += bound.height;
            });
            switch(command) {
                case 'horizontal':
                    items.forEach(function(item){
                        var bound = item.getBoundingRect();
                        item.set({top: item.get('top') + (position.top + position.bottom) / 2 - bound.top - bound.height / 2});
                        item.setCoords();
                    });
                    break;
                case 'vertical':
                    items.forEach(function(item){
                        var bound = item.getBoundingRect();
                        item.set({left: item.get('left') + (position.left + position.right) / 2 - bound.left - bound.width / 2});
                        item.setCoords();
                    });
                    break;
                case 'top':
                    items.forEach(function(item){
                        var bound = item.getBoundingRect();
                        item.set({top: item.get('top') + position.top - bound.top });
                        item.setCoords();
                    });
                    break;
                case 'bottom':
                    items.forEach(function(item){
                        var bound = item.getBoundingRect();
                        item.set({top: item.get('top') + position.bottom - bound.top - bound.height });
                        item.setCoords();
                    });
                    break;  
                case 'left':
                    items.forEach(function(item){
                        var bound = item.getBoundingRect();
                        item.set({left: item.get('left') - bound.left + position.left});
                        item.setCoords();
                    });
                    break;
                case 'right':
                    items.forEach(function(item){
                        var bound = item.getBoundingRect();
                        item.set({left: item.get('left') - bound.left + position.right - bound.width});
                        item.setCoords();
                    });
                    break;
                case 'dis-horizontal':
                    var leftPosition = _.sortBy(_leftPosition, [function(o) { return o.value; }]);
                    var space = (position.right - position.left - totalWidth) / (items.length - 1);
                    leftPosition.forEach(function(_item, _index){
                        var index = _item.index;
                        if(_index > 0 && _index < items.length - 1){
                            var item = items[index],
                            previous_item = items[leftPosition[_index-1].index],
                            bound = item.getBoundingRect(),
                            previous_item_bound = previous_item.getBoundingRect();
                            item.set({'left': item.get('left') - bound.left +  previous_item_bound.left + previous_item_bound.width + space });
                            item.setCoords();
                        }
                    });
                    break;
                case 'dis-vertical':
                    var topPosition = _.sortBy(_topPosition, [function(o) { return o.value; }]);
                    var space = (position.bottom - position.top - totalHeight) / (items.length - 1);
                    topPosition.forEach(function(_item, _index){
                        var index = _item.index;
                        if(_index > 0 && _index < items.length - 1){
                            var item = items[index],
                            previous_item = items[topPosition[_index-1].index],
                            bound = item.getBoundingRect(),
                            previous_item_bound = previous_item.getBoundingRect();
                            item.set({'top': item.get('top') - bound.top + previous_item_bound.top + previous_item_bound.height + space });
                            item.setCoords();
                        }
                    });
                    break;
            };    
            group.addWithUpdate();
            this.renderStage();
        };
        $scope.copyLayers = function(){
            if( !$scope.canAddMoreLayer() ) return;
            var _canvas = this.stages[$scope.currentStage]['canvas'];
            if( !_canvas.getActiveObject() ) return;
            var activeObject = _canvas.getActiveObject();
            activeObject.clone(function(cloned) {
                var _clipboard = cloned;
                function _clone(__clipboard, mask){
                    $timeout(function(){
                        __clipboard.clone(function(clonedObj) {
                            _canvas.discardActiveObject();
                            clonedObj.set({
                                left: clonedObj.left + 10,
                                top: clonedObj.top + 10,
                                evented: true
                            });
                            if (clonedObj.type === 'activeSelection') {
                                clonedObj.canvas = _canvas;
                                clonedObj.forEachObject(function(obj) {
                                    $scope.contextAddLayers = 'copy';
                                    _canvas.add(obj);
                                });
                                clonedObj.setCoords();
                            } else {
                                $scope.contextAddLayers = 'copy';
                                _canvas.add(clonedObj);
                                if( angular.isDefined( mask ) ){
                                    clonedObj.set({
                                        clipPath: mask, 
                                        maskId: mask.get('itemId'),
                                        centeredScaling: true
                                    });
                                    $scope.updateMaskLayer();
                                }
                            }
                            _canvas.setActiveObject(clonedObj);
                            _canvas.requestRenderAll();
                        });
                    }, 10);
                }
                if( cloned.type != 'activeSelection' && !!activeObject.get('maskId') ){
                    var maskLayer = $scope.getMaskLayer( activeObject.get('maskId') );
                    if( maskLayer ){
                        maskLayer.clone(function(cloned) {
                            var _maskClipboard = cloned;
                            $timeout(function(){
                                _clone( _maskClipboard );
                                $timeout(function(){
                                    var mask = _canvas.item( _canvas.getObjects().length - 1 );
                                    mask.set({
                                        isMask: 1,
                                        absolutePositioned: true,
                                        selectable: false
                                    });
                                    _clone( _clipboard, mask );
                                }, 10);
                            }, 10);
                        });
                    }else{
                        _clone( _clipboard );
                    }
                }else{
                    _clone( _clipboard );
                }
            });
        };
        /* Hotkeys */
        $scope.$on('nbd:keypress', function(event, e){
            $scope.keypressHandle(e);
        });
        $scope.$on('nbd:keydown', function(event, e){
            $scope.keydownHandle(e);
        });
        $scope.keydownHandle = function(e){};
        $scope.keypressHandle = function(e){
            var targetEl = e.target.tagName.toUpperCase();
            if( targetEl == 'INPUT' || targetEl == 'TEXTAREA' ||  $scope.stages[$scope.currentStage].states.isEditing ){
                if( !(e.ctrlKey && (e.which == 66 || e.which == 73))  ){
                    return;
                }
            }
            var _stage = $scope.stages[$scope.currentStage],
            _states = _stage.states;
            if(e.ctrlKey || e.metaKey){
                var keepDefault = [67, 116];
                if( _.includes(keepDefault, e.which) ) return;
                e.preventDefault();
                if( e.shiftKey ){
                    switch( e.which ) { 
                        case 221:
                            /* Hold Ctrl + Shift + ] Bring layer to front */ 
                            $scope.setStackPosition('bring-front');
                            break;
                        case 219:
                            /* Hold Ctrl + Shift + [ Send layer to back */ 
                            $scope.setStackPosition('send-back');
                            break;
                        case 86:
                            /* Hold Ctrl + Shift + V → Align layer center vertical */
                            $scope.translateLayer('vertical');
                            break;
                        case 73:
                            /* Hold Ctrl + Shift + I → Import Design */ 
                            $scope.importDesign();
                            break;
                        case 69:
                            /* Hold Ctrl + Shift + E → Export Design */ 
                            $scope.exportDesign();
                            break;
                        case 83:
                            /* Hold Ctrl + Shift + S → Save Design for later*/ 
                            // $scope.saveData('saveforlater');
                            break;
                        case 76:
                            /* Hold Ctrl + Shift + L → clear all stages*/ 
                            $scope.clearAllStage();
                            break;
                        case 79:
                            /* Hold Ctrl + Shift + O → Load My Design in Cart*/ 
                            // $scope.loadMyDesign(null, true);
                            break;
                        case 188:
                            /* Hold Ctrl + Shift + < → Decreate font size*/ 
                            if( _states.isText ){
                                _states.text.ptFontSize -= 1;
                                $scope.setTextAttribute('fontSize', _states.text.ptFontSize);
                            }
                            $scope.updateApp();
                            break;
                        case 190:
                            /* Hold Ctrl + Shift + > → Increate font size*/ 
                            if( _states.isText ){
                                _states.text.ptFontSize += 1;
                                $scope.setTextAttribute('fontSize', _states.text.ptFontSize);
                            }
                            $scope.updateApp();
                            break; 
                        case 71:
                            /* Hold Ctrl + Shift + G → Ungroup */ 
                            if( _states.isNativeGroup ){
                                $scope.unGroupLayers();
                            }
                            $scope.updateApp();
                            break;
                    }
                }else{
                    switch( e.which ) {
                        case 65:
                            /* Hold Ctrl press A → select all layers */
                            $scope.selectAllLayers();
                            break;
                        case 66:
                            /* Hold Ctrl press B → set font weight bold */
                            if( _states.isText 
                                    && (_states.text.font.file.b 
                                    && ( _states.text.fontStyle != 'italic' || ( _states.text.fontStyle == 'italic'  && _states.text.font.file.bi ) )) ){
                                $scope.setTextAttribute('fontWeight', _states.text.fontWeight == 'bold' ? 'normal' : 'bold');
                            }
                            $scope.updateApp();
                            break;
                        case 80:
                            /* Hold Ctrl press P → duplicate layers */
                            $scope.copyLayers();
                            break;
                        case 73:
                            /* Hold Ctrl press I → set text style italic */
                            if( _states.isText 
                                    && (_states.text.font.file.i 
                                    && ( _states.text.fontWeight != 'bold' || ( _states.text.fontWeight == 'bold'  && _states.text.font.file.bi ) )) ){                    
                                $scope.setTextAttribute('fontStyle', _states.text.fontStyle == 'italic' ? 'normal' : 'italic');
                            }
                            $scope.updateApp();
                            break; 
                        case 68:
                            /* Hold Ctrl press D → deactive all layers */
                            $scope.deactiveAllLayer();
                            break;
                        case 69:
                            /* Hold Ctrl press E → clear stage */
                            $scope.clearStage();
                            break;
                        case 90:
                            /* Hold Ctrl press Z → Undo */
                            if( _states.isUndoable ){
                                $scope.undo();
                            }
                            break;
                        case 89:
                            /* Hold Ctrl press Y → Undo */
                            if( _states.isRedoable ){
                                $scope.redo();
                            }
                            break;
                        case 71:
                            /* Hold Ctrl press G → Group Layers */
                            if( _states.isGroup ){
                                $scope.groupLayers();
                            }
                            $scope.updateApp();
                            break;
                        case 76:
                            /* Hold Ctrl press L → Toggle Bleed Line */
                            $scope.settings.bleedLine = !$scope.settings.bleedLine;
                            $scope.updateApp();
                            break;
                        case 82:
                            /* Hold Ctrl press R → Toggle Ruler */
                            $scope.toggleRuler();
                            $scope.updateApp();
                            break;
                        case 72:
                            /* Hold Ctrl press H → Align layer center horizontal */
                            $scope.translateLayer('horizontal');
                            break;
                        case 107:
                            /* Hold Ctrl press + → Zoom In stage */
                            if( _states.currentScaleIndex < _states.scaleRange.length - 1 ){
                                $scope.zoomStage(_states.currentScaleIndex + 1);
                                $scope.updateApp();
                            }
                            break;
                        case 109:
                            /* Hold Ctrl press - → Zoom out stage */
                            if( _states.currentScaleIndex > 0 ){
                                $scope.zoomStage(_states.currentScaleIndex - 1);
                                $scope.updateApp();
                            }
                            break;
                        case 48:
                        case 96:
                            /* Hold Ctrl press 0 → Resize stage to fit */
                            $scope.zoomStage(_states.fitScaleIndex);
                            $scope.updateApp();
                            break;
                        case 49:
                        case 97:
                            /* Hold Ctrl press 1 → Resize stage to origin size */
                            if(_states.fillScaleIndex == -1){
                                $scope.zoomStage(_states.fitScaleIndex);
                            }else{
                                $scope.zoomStage(_states.fillScaleIndex);
                            };
                            $scope.updateApp();
                            break;
                        case 221:
                            /* Hold Ctrl press ] Bring layer forward */ 
                            $scope.setStackPosition('bring-forward');
                            break;
                        case 219:
                            /* Hold Ctrl press [ Bring layer backward */ 
                            $scope.setStackPosition('send-backward');
                            break;  
                        case 79:
                            /* Hold Ctrl press O → Load My Design */ 
                            // $scope.loadMyDesign(null, false);
                            break;
                    }
                }   
            }else if( e.altKey ){
                e.preventDefault();
                switch( e.which ) {
                    case 37:
                        /* Hold Alt press left arrow */
                        $scope.moveLayer('left', 'alt');
                        break;
                    case 38:
                        /* Hold Alt press up arrow */
                        $scope.moveLayer('up', 'alt');
                        break;
                    case 39:
                        /* Hold Alt press right arrow */
                        $scope.moveLayer('right', 'alt');
                        break;
                    case 40:
                        /* Hold Alt press down arrow */
                        $scope.moveLayer('down', 'alt');
                        break;   
                    case 85:
                        /* Hold Alt press U */
                        if( _states.isText ) $scope.setTextAttribute('is_uppercase', true);
                        $scope.updateApp();
                        break;
                    case 76:
                        /* Hold Alt press U */
                        if( _states.isText ) $scope.setTextAttribute('is_uppercase', false);
                        $scope.updateApp();
                        break;
                } 
            } else if( e.shiftKey ){
                switch( e.which ) {
                    case 107:
                        /* Hold Shift press + → zoom out layer */
                        $scope.scaleLayer('+');
                        break;
                    case 109:
                        /* Hold Shift press - → zoom in layer */
                        $scope.scaleLayer('-');
                        break; 
                    case 71:
                        /* Hold Shift + G → Toggle Grid */ 
                        $scope.settings.showGrid = !$scope.settings.showGrid;
                        $scope.updateApp();
                        break;
                    case 76:
                        /* Hold Shift + L → clear all guidelines*/ 
                        $scope.clearGuides();
                        break;
                    case 68:
                        /* Hold Shift + D → Toggle Dimension */ 
                        $scope.settings.showDimensions = !$scope.settings.showDimensions;
                        $scope.updateApp();
                        break;
                }
            } else {
                switch( e.which ) {
                    case 27:
                        /* Press Esc */
                        $scope.deactiveAllLayer();
                        break;
                    case 37:
                        /* Press left arrow */
                        if( _states.isActiveLayer )
                            $scope.moveLayer('left');
                        break;
                    case 38:
                        /* Press up arrow */
                        if( _states.isActiveLayer )
                            $scope.moveLayer('up');
                        break;
                    case 39:
                        /* Press right arrow */
                        if( _states.isActiveLayer )
                            $scope.moveLayer('right');
                        break;
                    case 40:
                        /* Press down arrow */
                        if( _states.isActiveLayer )
                            $scope.moveLayer('down');
                        break; 
                    case 46:
                    case 8:
                        /* Press "delete" → delete layers */
                        $scope.deleteLayers();
                        break;
                    case 86:
                        /* Press "V" → disable draw mode */
                        if( $scope.resource.drawMode.status ) jQuery('.item[data-type="draw"]').triggerHandler('click');
                        break;
                    case 66:
                        /* Press "B" → enable draw mode */
                        if( !$scope.resource.drawMode.status ) jQuery('.item[data-type="draw"]').triggerHandler('click');
                        break;
                }
            }
        };
        /* General */
        $scope._clearAllStage = function(){
            if( !$scope.canDeleteLayer() ) return;
            jQuery('.nbd-popup.clear-all-stage-alert').nbShowPopup();
        };
        $scope.clearAllStage = function(){
            _.each($scope.stages, function(stage, index){
                stage.canvas.clear();
                stage.layers = [];
            });
            $scope.initStagesSettingWithoutTemplate();
            jQuery('.clear-all-stage-alert .close-popup').triggerHandler('click');
        };
        $scope.deleteStage = function(){ 
            jQuery('.delete-stage-alert .close-popup').triggerHandler('click');
            $scope._deleteStage( $scope.stageWillBeDelete );
        };
        $scope._deleteStage = function( stage_id, callback ){
            if( $scope.stages.length == $scope.settings.minNoOfStage ) return;
            stage_id = angular.isDefined( stage_id ) ? stage_id : $scope.currentStage;
            $scope.preventLoadDesign = true;
            appConfig.ready = false;
            if( angular.isUndefined($scope.settings.product_data.origin_product) ){
                $scope.settings.product_data.origin_product = [];
                angular.copy($scope.settings.product_data.product, $scope.settings.product_data.origin_product);
            }
            if( $scope.currentStage == stage_id && $scope.currentStage > 0 ){
                $scope.switchStage($scope.currentStage, 'prev', 'top-bottom', true);
            }
            if( $scope.currentStage == 0 ){
                $scope.switchStage($scope.currentStage, 'next', 'top-bottom', true);
            }
            if( $scope.currentStage >= stage_id && $scope.currentStage > 0 ){
                $scope.currentStage--;
            }
            $scope.settings.product_data.product.splice(stage_id, 1);
            $scope.stages.splice(stage_id, 1);
            $timeout(function(){
                appConfig.ready = true;
                $scope.updateApp();
                if( typeof callback == 'function' ){
                    callback();
                }
            }, 100);
        };
        $scope.$on('stage:move', function(event, from, to){
            $scope.moveStage( from, to );
        });
        $scope.moveStage = function( from, to, callback ){
            if( from == to || from == ( to - 1 ) ) return;
            var from_stage = {}, from_product_stage = {}, currentStage = $scope.currentStage, 
            _to = from > to ? to : ( to - 1 ),
            from_design = $scope.stageToJson( from );

            angular.copy($scope.settings.product_data.product[from], from_product_stage);
            angular.copy($scope.stages[from], from_stage);
            $scope.settings.product_data.product.splice(from, 1);
            $scope.stages.splice(from, 1);
            $scope.preventLoadDesign = true;
            appConfig.ready = false;

            $scope.settings.product_data.product.splice(_to, 0, from_product_stage);
            $scope.stages.splice(_to, 0, from_stage);
            jQuery('.popup-nbd-stage-grid-view .overlay-main').addClass('active');

            $timeout(function(){
                $scope._loadStageFromJson( _to, from_design, function(){
                    $scope.preventLoadDesign = false;
                    appConfig.ready = true;
                    $scope.switchStageTo( currentStage );
                    $scope.updateApp();
                    jQuery('.popup-nbd-stage-grid-view .overlay-main').removeClass('active');
                    if( typeof callback == 'function' ){
                        callback();
                    }
                }, true);
            }, 300);
        };
        $scope.switchStageTo = function( id, direction ){
            $scope.currentStage = id;
            jQuery('.stage').addClass('_nbd_hidden')
                .removeClass('fadeInUp').removeClass('fadeInDown').removeClass('fadeOutDown').removeClass('fadeOutUp')
                .removeClass('fadeInLeft').removeClass('fadeInRight').removeClass('fadeOutRight').removeClass('fadeOutLeft');
            var idCurrentStage = '#stage-container-' + id,
            fadeInClass = direction == 'left-right' ? 'fadeInRight' : 'fadeInUp';
            jQuery(idCurrentStage).removeClass('_nbd_hidden').addClass(fadeInClass);
        };
        $scope.switchStage = function(id, command, direction, onRemoveStage){
            var idCurrentStage = 'stage-container-' + id,
                next =  parseInt(id) + 1;
            if(command == 'prev')  {
                next  = parseInt(id) - 1;
            };
            if(angular.isDefined($scope.settings.product_data.product[next])) {
                $scope.getTemplatesBySide($scope.settings.product_data.product[next].id);
            }
            jQuery('.temporary-hidden').addClass('nb-opacity-0');
            $timeout(function(){
                jQuery('.temporary-hidden').removeClass('nb-opacity-0');
            }, 600);
            jQuery('.nbd-stages .ps__scrollbar-x-rail, .nbd-stages .ps__scrollbar-y-rail').addClass('nbd-hiden');
            $timeout(function(){
                jQuery('.nbd-stages .ps__scrollbar-x-rail, .nbd-stages .ps__scrollbar-y-rail').removeClass('nbd-hiden');
            }, 700);
            direction = angular.isDefined(direction) ? direction : 'top-bottom';
            var fadeInNext = 'fadeInUp', fadeInPrev = 'fadeInDown', fadeOutNext = 'fadeOutDown', fadeOutPrev = 'fadeOutUp';
            if( direction == 'left-right' ){
                fadeInNext = 'fadeInRight'; 
                fadeInPrev = 'fadeInLeft';
                fadeOutNext = 'fadeOutRight';
                fadeOutPrev = 'fadeOutLeft';
            };

            var idNextStage = 'stage-container-' + next;
            var currentStage = angular.element(document.getElementById(idCurrentStage)),
            nextStage = angular.element(document.getElementById(idNextStage));
            if( direction == 'left-right' ){
                currentStage.removeClass('fadeInUp').removeClass('fadeInDown').removeClass('fadeOutDown').removeClass('fadeOutUp');
                nextStage.removeClass('fadeInUp').removeClass('fadeInDown').removeClass('fadeOutDown').removeClass('fadeOutUp');
            }else{
                currentStage.removeClass('fadeInLeft').removeClass('fadeInRight').removeClass('fadeOutRight').removeClass('fadeOutLeft');
                nextStage.removeClass('fadeInLeft').removeClass('fadeInRight').removeClass('fadeOutRight').removeClass('fadeOutLeft');
            }
            currentStage.addClass('animated');
            currentStage.removeClass(fadeInNext);
            currentStage.removeClass(fadeInPrev);
            nextStage.addClass('animated');
            nextStage.removeClass('_nbd_hidden');
            nextStage.removeClass(fadeOutNext);
            nextStage.removeClass(fadeOutPrev);
            if(command == 'prev'){
                currentStage.removeClass(fadeOutNext);
                currentStage.addClass(fadeOutPrev);
                nextStage.addClass(fadeInPrev);
            }else {
                currentStage.removeClass(fadeOutPrev);
                currentStage.addClass(fadeOutNext);
                nextStage.addClass(fadeInNext);
            };

            if(angular.isUndefined(onRemoveStage)) $scope.currentStage = next;
            if(appConfig.isVisual){
                $scope.deactiveAllLayer();
            }
            $scope.renderStage();
            $scope.updateLayersList();
        };
        $scope.cancelDeleteStage = function( stage_id ){
            jQuery('.delete-stage-alert .close-popup').triggerHandler('click');
        };
        $scope.stageToJson = function(stage_id){
            stage_id = angular.isDefined( stage_id ) ? stage_id :  $scope.currentStage;
            $scope.renderStage(stage_id);
            var json = this.stages[stage_id]['canvas'].toJSON($scope.includeExport);
            return json;
        };
        $scope.copyStage = function( stage_id ){
            stage_id = angular.isDefined( stage_id ) ? stage_id :  $scope.currentStage;
            $scope.tempStageDesign = {
                id: stage_id,
                design: $scope.stageToJson()
            };
        };
        $scope.pasteStage = function( dist_stage ){
            dist_stage = angular.isDefined( dist_stage ) ? dist_stage :  $scope.currentStage;
            if( $scope.tempStageDesign.id == dist_stage ) return;
            $scope.loadStageFromJson( dist_stage, $scope.tempStageDesign.design );
        };
        $scope.duplicateStage = function( stage_id ){
            // disabled dynamic side
            return;
            if( $scope.stages.length == $scope.settings.maxNoOfStage ) return;
            stage_id = angular.isDefined( stage_id ) ? stage_id :  $scope.currentStage;
            $scope.copyStage();
            $scope._addStage( stage_id );
            $timeout(function(){
                $scope.loadStageFromJson( stage_id * 1 + 1, $scope.tempStageDesign.design );
            }, 100);
        };
        $scope.maybeAddStage = function( stage_id ){
            if( !$scope.settings.dynamicStage ) return;
            $scope._addStage( stage_id - 1 );
        };
        $scope._addStage = function( stage_id ){
            // disabled dynamic side
            return;
            if( $scope.stages.length == $scope.settings.maxNoOfStage ) return;
            stage_id = angular.isDefined( stage_id ) ? stage_id :  $scope.currentStage;
            $scope.preventLoadDesign = true;
            if( angular.isUndefined($scope.settings.product_data.origin_product) ){
                $scope.settings.product_data.origin_product = [];
                angular.copy($scope.settings.product_data.product, $scope.settings.product_data.origin_product);
            }
            var new_stage = {}, new_product_stage = {};

            angular.copy($scope.settings.product_data.product[stage_id], new_product_stage);
            $scope.settings.product_data.product.splice(stage_id * 1 + 1, 0, new_product_stage);

            angular.copy($scope.stages[stage_id], new_stage);
            new_stage.design = '';
            new_stage.config.name += ' (copy)';
            $scope.stages.splice(stage_id * 1 + 1, 0, new_stage);
        };
        $scope.stageWillBeDelete = 0;
        $scope.confirmDeleteStage = function( stage_id ){
            stage_id = angular.isDefined( stage_id ) ? stage_id : $scope.currentStage;
            $scope.stageWillBeDelete = stage_id;
            jQuery('.delete-stage-alert').nbShowPopup();
        };
        $scope.showGridView = function(){
            $scope.toggleStageLoading();
            $scope.saveDesign();
            _showGridView = function(){
                $scope.toggleStageLoading();
                jQuery('.nbd-popup.popup-nbd-stage-grid-view').nbShowPopup();
                $scope.settings.gridViewMode = true;
            }
            if( $scope.checkSaveStatus() ){
                _showGridView();
            }else{
                var interval = $interval(function(){
                    if( $scope.checkSaveStatus() ){
                        $interval.cancel( interval );
                        _showGridView();
                    }
                }, 100);
            }
        };
        $scope.maybeZoomStage = false;
        $scope.stageSaveStatus = [];
        $scope.originPDFs = [];
        $scope.pdfStacks = [];
        $scope.partialSvgs = [];
        $scope.checkSaveStatus = function(){
            var status = true;
            $scope.stageSaveStatus.forEach(function(stageStatus){
                if( !stageStatus ){
                    status = false;
                }
            });
            return status;
        };
        $scope.createPreviewWithClippath = function( index, callback ){
            var stage = $scope.stages[index];
            if( angular.isUndefined( stage ) ) return;

            var design = stage.design,
            _canvas = stage.canvas,
            width = _canvas.width,
            height = _canvas.height;

            if( !design ) return;

            function createPreviewSvg(){
                var svg = '<svg version="1.1" width="' + width + '" height="' + height + '"' + ' viewBox="0 0 ' + width + ' ' + height + '" ' + ' xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">';
                svg += '<defs>';
                svg +=      '<clipPath id="area-design-shape-' + index + '"><path d="' + $scope.areaDesignClipPaths[index] + '" /></clipPath>';
                svg += '</defs>';

                svg += '<g clip-path="url(#area-design-shape-' + index + ')">';
                if( stage.config.bgType == 'color' ){
                    svg += '<rect x="0" y="0" width="' + width + '" height="' + height + '" fill="' + stage.config.bgColor + '" />';
                }

                svg +=      '<image x="0" y="0" width="' + width + '" height="' + height + '"' + ' xlink:href="' + design + '" />';
                svg += '</g>';
                svg += '</svg>';
                return svg;
            }

            var previewSvg = createPreviewSvg(),
            img = new Image();
            url = "data:image/svg+xml;charset=utf-8," + encodeURIComponent( previewSvg );
            img.onload = function() {
                var kanvas = document.createElement("canvas");
                kanvas.width = width;
                kanvas.height = height;
                context = kanvas.getContext('2d');
                context.drawImage(img, 0, 0, width, height, 0, 0, width, height);
                stage.design = kanvas.toDataURL();
                if( typeof callback == 'function' ){
                    $timeout(function(){
                        callback();
                    });
                }
            }
            img.src = url;
        };
        /* Draw mode */
        $scope.disableDrawMode = function(){
            $scope.resource.drawMode.status = false;
            _.each($scope.stages, function(stage, index){
                stage.canvas.isDrawingMode = false;
            });
            $scope.changeBush();
            $scope.updateApp();
        };
        $scope.enableDrawMode = function(){
            $scope.resource.drawMode.status = true;
            _.each($scope.stages, function(stage, index){
                stage.canvas.isDrawingMode = true;
            });
            $scope.updateApp();
        };
        $scope.changeBush = function(color){
            if(color) $scope.resource.drawMode.brushColor = color;
            _.each($scope.stages, function(stage, index){
                stage.canvas.freeDrawingBrush = new fabric[$scope.resource.drawMode.brushType + "Brush"](stage.canvas);
                stage.canvas.freeDrawingBrush.color = $scope.resource.drawMode.brushColor;
                stage.canvas.freeDrawingBrush.width = $scope.resource.drawMode.brushWidth;
            });
        };

        /* Save Data */
        $scope.messageCreatedSuccess = {
            header: 'Created project success!',
            content: 'Your project has been created successfully!',
        };
        $scope.onSaveData = false;
        $scope.saveData = function(type){
            $scope.onSaveData = true;
            if( angular.isUndefined(type) ) type = $scope.settings.task;
            if(type != 'share' && type != 'save_draft' ) $scope.toggleStageLoading();
            if(type == 'typography') $scope.resource.usedFonts = [];
            var excludeType = ['saveforlater', 'share', 'download-pdf', 'preview_mockup', 'save_draft', 'download-jpg', 'change-product'];
            if( !_.includes(excludeType, type) ) $scope.maybeZoomStage = true;
            if( _.includes(['saveforlater', 'share', 'preview_mockup', 'save_draft', 'change-product'], type) ) $scope.onSaveData = false;
            if( $scope.settings.nbdesigner_dimensions_unit == 'px' && type == 'share' ) $scope.maybeZoomStage = true;

            function _saveData(){
                $scope.resource.config.viewport = $scope.viewPort; 
                /* Backward compatible version 1.x */
                $scope.resource.config.scale =  ($window.innerWidth > ($window.innerHeight - 120) ? $window.innerHeight - 120 : $window.innerWidth) / 500;  
                $scope.resource.config.product = $scope.settings.product_data.product;
                if( angular.isDefined($scope.settings.product_data.origin_product) ){
                    $scope.resource.config.origin_product = $scope.settings.product_data.origin_product;
                }
                $scope.resource.config.dpi = $scope.settings.product_data.option.dpi;
                // if( $scope.settings.product_data.option.option_dpi ){
                //     $scope.resource.config.option_dpi = true;
                // }
                if( angular.isDefined( $scope.areaDesignShapes ) && $scope.areaDesignShapes.length ){
                    $scope.resource.config.areaDesignShapes = $scope.areaDesignShapes;
                }
                $scope.resource.config.originPDFs = $scope.originPDFs;
                $scope.resource.config.pdfStacks = $scope.pdfStacks;
                if ( angular.isDefined( $scope.settings.nbes_enable_settings ) && angular.isDefined( $scope.settings.nbes_settings ) 
                      && $scope.settings.nbes_enable_settings.combination == 1 && angular.isDefined( $scope.settings.nbes_settings.combination_colors ) ) {
                    $scope.resource.config.combinationColor = $scope.currentCombinationColor;
                }
                var formData = new FormData();
                var headers = apiAuthBearer;
                headers['Content-Type'] = undefined;

                var formDataDesign = new FormData();
                var postType = 'designs';
                var url_post_design = apiPre + 'designs/batch';
                var isMethodPost = true;
                // Create form preview Image
                var formPreviewImage = new FormData();
                var previewImage = $scope.stages[0].canvas.toDataURL();
                formPreviewImage.append( 'file', $scope.makeblob(previewImage));
                formPreviewImage.append( 'type', 'designs' );

                if(is_template || $scope.settings.task == 'create_template' || $scope.settings.task == 'edit_template' || $scope.settings.task == 'edit' ) {
                    url_post_design = apiPre + 'templates';
                    let svg_obj = new Blob([$scope.stages[0].svg], {type: "image/svg"});
                    if( ($scope.settings.task == 'edit_template' && template_id) || ($scope.settings.task == 'edit' && design_id) ) {
                        isMethodPost = false;
                        url_post_design = $scope.settings.task == 'edit_template' ? apiPre + 'templates/' + template_id : apiPre + 'designs/' + design_id;
                        var formDataImage = new FormData();
                        headers = apiAuthBearer;
                        headers['Content-Type'] = undefined;
                        formDataImage.append( 'file', new File([svg_obj], "frame_"+0+"_svg.svg"));
                        formDataImage.append( 'type', 'designs' );
                        function postDesignImage() {
                            return $http({
                                method: 'POST',
                                url: apiPre + 'images',
                                headers: headers,
                                transformRequest: angular.identity,
                                transformResponse: angular.identity,
                                data: formDataImage,
                            });
                        }
                        function postPreviewImage() {
                            return $http({
                                method: 'POST',
                                url: apiPre + 'images',
                                headers: headers,
                                transformRequest: angular.identity,
                                transformResponse: angular.identity,
                                data: formPreviewImage,
                            });
                        }
                        Promise.all([postDesignImage(), postPreviewImage()])
                        .then( function(results) {
                            if( angular.isDefined(results[0]) && angular.isDefined(results[1]) && results[0].status === 201 && results[1].status === 201 ) {
                                var resultImageDesign = JSON.parse(results[0].data).data;
                                var resultImagePreview = JSON.parse(results[1].data).data;

                                var objTemplate = {
                                    side_id: $scope.settings.product_data.product[0].id,
                                    layers: JSON.stringify($scope.resource.jsonDesign['frame_' + 0].objects),
                                    viewport_width: $scope.viewPort.width,
                                    viewport_height: $scope.viewPort.height,
                                    preview_image_id: resultImagePreview.id,
                                };
                                if($scope.settings.task == 'edit_template') {
                                    objTemplate['template_image_id'] = resultImageDesign.id;
                                } else {
                                    objTemplate['design_image_id'] = resultImageDesign.id;
                                }
                                headers['Content-Type'] = 'application/json';
                                $http({
                                    method: 'PUT',
                                    url: url_post_design,
                                    headers: headers,
                                    transformRequest: angular.identity,
                                    transformResponse: angular.identity,
                                    data: JSON.stringify(objTemplate),
                                }).then(function successCallback(responsePut){
                                    if( responsePut.status != 200 ) {
                                        $scope.toggleStageLoading();
                                        alert(JSON.parse(responsePut.data).message);
                                        return;
                                    }
                                    if($scope.settings.task == 'edit_template') {
                                        $scope.messageCreatedSuccess = {
                                            header: 'Updated template success!',
                                            content: 'Your template has been updated successfully!',
                                        };
                                    } else {
                                        $scope.messageCreatedSuccess = {
                                            header: 'Updated design success!',
                                            content: 'Your design has been updated successfully!',
                                        };
                                    }

                                    window.parent.postMessage({message: 'finishUpdate', data: JSON.parse(responsePut.data)}, parentUrl);
                                    
                                    $scope.toggleStageLoading();
                                    jQuery('.nbd-popup.created-project-success-alert').nbShowPopup();
                                }, function errorCallback(responsePut) {
                                    console.log('Fail to Process!');
                                    $scope.toggleStageLoading();
                                });
                            } else {
                                $scope.toggleStageLoading();
                                alert('Fail to created image!');
                                return;
                            }
                        });
                    }
                    if($scope.settings.task == 'create_template') {
                        formDataDesign.append( 'side_id', $scope.settings.product_data.product[0].id );
                        formDataDesign.append( 'template_file', new File([svg_obj], "frame_"+0+"_svg.svg") );
                        formDataDesign.append( 'layers', JSON.stringify($scope.resource.jsonDesign['frame_' + 0].objects) );
                        formDataDesign.append( 'viewport_width', $scope.viewPort.width );
                        formDataDesign.append( 'viewport_height', $scope.viewPort.height );
                    }
                } else {
                    var is_post_images = true;
                    var list_images = [];
                    var designIndex = 0;
                    var formPreviewImage = new FormData();
                    formPreviewImage.append( 'type', 'designs' );
                    _.each($scope.stages, function(stage, index){
                        if(angular.isDefined($scope.resource.jsonDesign['frame_' + index]) && $scope.resource.jsonDesign['frame_' + index].objects.length > 0) {
                            var previewImage = stage.canvas.toDataURL();
                            formPreviewImage.append( 'files['+designIndex+']', $scope.makeblob(previewImage));
                            let svg_obj = new Blob([stage.svg], {type: "image/svg"});
                            formDataDesign.append( postType+'['+designIndex+'][side_id]', angular.isDefined($scope.settings.product_data.product[index]) ? $scope.settings.product_data.product[index].id : $scope.settings.product_data.product[0].id);
                            formDataDesign.append( postType+'['+designIndex+'][design_file]', new File([svg_obj], "frame_"+index+"_svg.svg"));
                            formDataDesign.append( postType+'['+designIndex+'][layers]', JSON.stringify($scope.resource.jsonDesign['frame_' + index].objects));
                            formDataDesign.append( postType+'['+designIndex+'][viewport_height]', $scope.viewPort.height);
                            formDataDesign.append( postType+'['+designIndex+'][viewport_width]', $scope.viewPort.width);
                            list_images.push(index);
                            designIndex ++;
                        }
                    })
                }
                if(isMethodPost) {
                    var url_post_images = angular.isDefined(is_post_images) && is_post_images ? apiPre + 'images/batch' : apiPre + 'images';
                    $http({
                        method: 'POST',
                        url: url_post_images,
                        headers: headers,
                        transformRequest: angular.identity,
                        transformResponse: angular.identity,
                        data: formPreviewImage,
                    }).then(function successCallback(response){
                        if( response.status == 201 && angular.isDefined(response.data) && angular.isDefined(JSON.parse(response.data).data) ) {
                            var dataImage = JSON.parse(response.data).data;

                            if(angular.isDefined(dataImage.length) && dataImage.length > 0 && angular.isDefined(list_images) && list_images.length > 0 ) {
                                 _.each(list_images, function(design_image, index){
                                    if(angular.isDefined(dataImage[index]) && angular.isDefined(dataImage[index].id)) {
                                        formDataDesign.append( postType+'['+index+'][preview_image_id]', dataImage[index].id);
                                    }
                                })
                            } else {
                                formDataDesign.append( 'preview_image_id' , dataImage.id);
                            }
                            $http({
                                method: 'POST',
                                url: url_post_design,
                                headers: headers,
                                transformRequest: angular.identity,
                                transformResponse: angular.identity,
                                data: formDataDesign,
                            }).then(function successCallback(response){
                                if( response.status != 201 ) {
                                    $scope.toggleStageLoading();
                                    alert(JSON.parse(response.data).message);
                                    return;
                                }
                                // var listDesignIds = [];
                                var designs_data = JSON.parse(response.data);
                                // if(angular.isDefined(designs_data) && angular.isDefined(designs_data.data) && designs_data.data.length > 0) {
                                //     angular.forEach(designs_data.data, function(obj) {
                                //         if(angular.isDefined(obj.id)) listDesignIds.push(obj.id);
                                //     })
                                // }
                                
                                window.parent.postMessage({message: 'finishProcess', data: designs_data}, parentUrl);

                                if( $scope.is_template ) {
                                    $scope.messageCreatedSuccess = {
                                        header: 'Created template success!',
                                        content: 'Your template has been created successfully!',
                                    };
                                }
                                $scope.toggleStageLoading();
                                jQuery('.nbd-popup.created-project-success-alert').nbShowPopup();
                            }, function errorCallback(response) {
                                console.log('Fail to Process!');
                                $scope.toggleStageLoading();

                                window.parent.postMessage({message: 'uploadError', data: response}, parentUrl);
                            });
                        } else {
                            alert('Fail to created design image!');
                        }
                    });
                }
                _.each($scope.stages, function(stage, index){
                    // $scope.toggleStageLoading();
                    $scope.zoomStage(stage.states.fitScaleIndex, index);
                });
            };

            function waitForSaveDesign(){
                $scope.saveDesign();
                if( $scope.checkSaveStatus() ){
                    _saveData();
                }else{
                    var interval = $interval(function(){
                        if( $scope.checkSaveStatus() ){
                            $interval.cancel( interval );
                            _saveData();
                        }
                    }, 100);
                }
            }

            waitForSaveDesign();
        };


        // Update fontPaths;
        $scope.createFontPaths = function(canvas) {
            if(!canvas) return false;
            var fontPaths = {}, objects = canvas.getObjects();
            for (var i = 0, len = objects.length; i < len; i++) {
                obj = objects[i];
                fontFamily = obj.fontFamily;
                if( angular.isDefined(obj.font) && angular.isDefined(obj.font.url) ) {
                    fontPaths[fontFamily] = obj.font.url; 
                }
            }
            fabric['fontPaths'] = fontPaths;
        };
        $scope.saveDesign = function( downloadType ){
            if( $scope.settings.nbdesigner_dimensions_unit == 'px' && angular.isDefined( downloadType ) && downloadType == 'png' ){
                $scope.maybeZoomStage = true;
            }
            $scope.stageSaveStatus = [];
            $scope.partialSvgs = [];
            _.each($scope.stages, function(stage, index){
                $scope.stageSaveStatus[index] = false;
                $scope.deactiveAllLayer(index);
                var zoomIndex = stage.states.fillScaleIndex != -1 ? stage.states.fillScaleIndex : stage.states.fitScaleIndex;
                if( $scope.maybeZoomStage ) $scope.zoomStage(zoomIndex, index);
                var _canvas = stage.canvas,
                    key = 'frame_' + index;
                $scope.createFontPaths(_canvas); // update fontPaths before create SVG file;
                $scope.renderStage(index);
                $scope.resource.jsonDesign[key] = _canvas.toJSON($scope.includeExport);
                stage.svg = _canvas.toSVG();
                stage.design = _canvas.toDataURL();
                stage.config.svgWidth = _canvas.width;
                stage.config.svgHeight = _canvas.height;

                $scope.pdfStacks[index] = '';
                if( angular.isDefined( $scope.originPDFs[index] ) && $scope.originPDFs[index].length ){
                    var objectLen = _canvas.getObjects().length, 
                        pdfLen = $scope.originPDFs[index].length,
                        part = 0,
                        first, last;

                    function storePartialSvg( first, last, part ){
                        var count = 0;
                        _canvas.forEachObject(function(obj, objIndex) {
                            if( objIndex > first && objIndex < last ){
                                obj.set({excludeFromExport: false});
                                count++;
                            }else{
                                obj.set({excludeFromExport: true});
                            }
                        });
                        if( count ) {
                            $scope.partialSvgs[index] = $scope.partialSvgs[index] || [];
                            $scope.partialSvgs[index][part] = _canvas.toSVG();
                            return true;
                        }
                        return false;
                    }

                    var stack = '';
                    $scope.originPDFs[index].forEach(function(pdf, pdfIndex){
                        if( pdfIndex == 0 ){
                            first = -1;
                            last = pdf.index;
                            if( storePartialSvg( first, last, part ) ){
                                part++;
                                stack = '0';
                            }
                        }

                        first = pdf.index;
                        if( pdfIndex < ( pdfLen - 1 ) ){
                            last = $scope.originPDFs[index][pdfIndex + 1].index;
                        } else {
                            last = objectLen;
                        }

                        stack += '_P';

                        if( storePartialSvg( first, last, part ) ){
                            stack += '_' + part;
                            part++;
                        }
                    });
                    if( stack.startsWith("_") ){
                        stack = stack.substr(1);
                    }
                    $scope.pdfStacks[index] = stack;

                    _canvas.forEachObject(function(obj) {
                        obj.set({excludeFromExport: false});
                    });
                }
                $scope.stageSaveStatus[index] = true;

                $scope.resource.usedFonts = _.concat($scope.resource.usedFonts, stage.states.usedFonts);
            });
            $scope.resource.usedFonts = _.uniqBy($scope.resource.usedFonts, 'alias');
            $scope.maybeZoomStage = false;
            if( downloadType ){
                $scope.toggleStageLoading();
                $timeout(function(){
                    $scope.toggleStageLoading();
                    _.each($scope.stages, function(stage, index){
                        $timeout(function(){
                            var filename = (index + 1) + ( downloadType == 'png' ? '.png' : '.svg' ),
                            a = document.createElement('a');

                            function download(){
                                a.setAttribute('download', filename);
                                a.style.display = 'none';
                                document.body.appendChild(a);
                                a.click();
                                document.body.removeChild(a);
                                if( navigator.userAgent.indexOf("Edge") > -1 ){
                                    setTimeout(function() {
                                        return window.URL.revokeObjectURL( _data );
                                    }, 1000);
                                }
        
                                if( $scope.settings.nbdesigner_dimensions_unit == 'px' && angular.isDefined( downloadType ) && downloadType == 'png' ){
                                    $scope.zoomStage(stage.states.fitScaleIndex, index);
                                }
                            }

                            if( downloadType == 'png' ){
                                function downloadPng(){
                                    var _data = stage.design;
                                    if( navigator.userAgent.indexOf("Edge") > -1 ){
                                        var blob;
                                        blob = $scope.makeblob( _data );
                                        _data = window.URL.createObjectURL(blob);
                                    }
                                    a.setAttribute('href', _data);
                                    download();
                                }
                                if( angular.isDefined( $scope.areaDesignClipPaths[index] ) && $scope.areaDesignClipPaths[index] ){
                                    $timeout(function(){
                                        $scope.createPreviewWithClippath( index, function(){
                                            downloadPng();
                                        } );
                                    }, 300);
                                }else{
                                    downloadPng();
                                }
                            } else {
                                if( angular.isDefined( $scope.areaDesignZoomedClipPaths[index] ) && $scope.areaDesignZoomedClipPaths[index] ){
                                    var clipPath = '<clipPath id="area-design-shape-' + index + '"><path d="' + $scope.areaDesignZoomedClipPaths[index] + '" /></clipPath>';
                                    var bg = '';
                                    if( stage.config.bgType == 'color' ){
                                        bg = '<rect x="0" y="0" width="' + stage.config.svgWidth + '" height="' + stage.config.svgHeight + '" fill="' + stage.config.bgColor + '" />';
                                    }
                                    var newSvg = stage.svg.replace('<\/defs>', clipPath + '<\/defs><g clip-path="url(#area-design-shape-' + index + ')">' + bg);
                                    newSvg = newSvg.replace('<\/svg>', '<\/g><\/svg>');
                                    stage.svg = newSvg;
                                }
                                var url = "data:image/svg+xml;charset=utf-8," + encodeURIComponent( stage.svg );
                                a.setAttribute('href', url);
                                download();
                            }
                        }, index * 500);
                    });
                }, 300);
            }
        };
        $scope.makeblob = function (dataURL) {
            var BASE64_MARKER = ';base64,';
            if (dataURL.indexOf(BASE64_MARKER) == -1) {
                var parts = dataURL.split(',');
                var contentType = parts[0].split(':')[1];
                var raw = decodeURIComponent(parts[1]);
                return new Blob([raw], { type: contentType });
            }
            var parts = dataURL.split(BASE64_MARKER);
            var contentType = parts[0].split(':')[1];
            var raw = window.atob(parts[1]);
            var rawLength = raw.length;
            var uInt8Array = new Uint8Array(rawLength);
            for (var i = 0; i < rawLength; ++i) {
                uInt8Array[i] = raw.charCodeAt(i);
            }
            return new Blob([uInt8Array], { type: contentType });
        };

        /* Get Media */
        $scope.getMedia = function(type, context){
            jQuery('#tab-element .loading-photo').show();
            $scope.resource.element.type = type;
            if( $scope.resource.element.type != type || context == 'search' ){
                $scope.resource[type].data = [];
                $scope.resource[type].filter.total = 0;
                $scope.resource[type].filter.currentPage = 1;
            };
            $scope.resource.element.type = type;
            var category = type == 'shape' ? 66 : (type == 'line' ? 78 : 73);
            var search = ( type == 'icon' || type == 'flaticon' || type == 'storyset' ) ? $scope.resource.element.contentSearch : '';
            if( type == 'icon' ){
                if( $scope.resource.icon.filter.currentCat != null ){
                    category = $scope.resource.icon.filter.currentCat.id;
                }
                if( search != '' ){
                    category = '';
                }
            }
            switch( type ){
                case 'flaticon':
                    function getFlaticon(){
                        $http({
                            method: "GET",
                            url: 'https://api.flaticon.com/v2/search/icons/selection?q=' + encodeURIComponent( search ) + '&page=' + $scope.resource.flaticon.filter.currentPage + '&limit=' + $scope.resource.flaticon.filter.perPage,
                            headers: {
                                'Authorization': 'Bearer ' + $scope.resource.flaticon.token,
                                'Accept': 'application/json'
                            }
                        }).then(function successCallback(response){
                            var data = response.data;
                            _.each(data.data, function(item, key) {
                                $scope.resource[type].data.push({
                                    url: item.images.svg,
                                    preview: item.images.png['128'],
                                    name: item.description
                                });
                            });
                            $scope.resource.flaticon.filter.totalPage = Math.ceil( data.metadata.total / $scope.resource.flaticon.filter.perPage );
                        }, function errorCallback(response) {
                            console.log('Fail to load: ' + type);
                        });
                    }
                    if( $scope.resource.flaticon.token != '' ){
                        getFlaticon();
                    }
                    break;
                case 'storyset':
                    $http({
                        method: "GET",
                        url: 'https://stories.freepiklabs.com/api/vectors?order=recent&page=' + $scope.resource[type].filter.currentPage + '&query=' + encodeURIComponent( search ),
                    }).then(function successCallback(response){
                        var data = response.data;
                        _.each(data.data, function(item, key) {
                            $scope.resource[type].data.push({
                                url: item.src,
                                preview: item.preview,
                                name: item.illustration.name
                            });
                        });
                        $scope.resource.storyset.filter.totalPage = data.meta.last_page;
                    }, function errorCallback(response) {
                        console.log('Fail to load: ' + type);
                    });
                    break;
                default:
                    $http({
                        method: 'GET',
                        url: mediaUrl + '/clipart?limit=20&category=' + category + '&search=' + search + '&start=' + ($scope.resource[type].filter.currentPage-1) * 20
                    }).then(function successCallback(response){
                        if( angular.isDefined( response.data.cliparts ) ){
                            var data = response.data.cliparts;
                            _.each(data.items, function(item, key) {
                                $scope.resource[type].data.push({
                                    url: item.file,
                                    name: item.name
                                });
                            });
                            $scope.resource[type].filter.totalPage = data.pagesTotal;
                            if( type == 'icon' && $scope.resource[type].first ){
                                $scope.resource[type].cat = data.categories;
                                $scope.resource[type].first = false;
                                $scope.resource.icon.filter.currentCat = _.filter($scope.resource.icon.cat, { id: '' +category })[0];
                            }
                        }
                    }, function errorCallback(response) {
                        console.log('Fail to load: ' + type);
                    });
                    break;
            }
        };
        /* Design */
        $scope.exportDesign = function(){
            return;
            $scope.saveDesign();
            var json = {config: {}};
            json.config.viewport = $scope.calcViewport();
            json.config.home_url = $scope.settings.home_url;
            json.fonts = $scope.resource.usedFonts;
            json.design = $scope.resource.jsonDesign;
            var filename = 'design.json',
            text = JSON.stringify(json),
            a = document.createElement('a');
            a.setAttribute('href', 'data:application/json;charset=utf-8,'+ encodeURIComponent(text));
            a.setAttribute('download', filename);
            a.style.display = 'none';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        };
        $scope.importDesign = function(){
            if(!$scope.settings.is_admin) return;
            var input = document.createElement('input');
            input.type = 'file';
            input.accept = 'text/json|application/json';
            input.style.display = 'none';
            input.addEventListener('change', onChange.bind(input), false);
            document.body.appendChild(input);
            input.click();
            function onChange(){
                if (this.files.length > 0) {
                    var file = this.files[0],
                    reader = new FileReader();
                    reader.onload = function(event){
                        if (event.target.readyState === 2) {
                            var result = JSON.parse(reader.result);
                            $scope.importImages( result, function( new_design, fonts, extenalDesign ){
                                var temp = {fonts: fonts, design: new_design, viewport: result.config.viewport};
                                if( !!extenalDesign ) temp.doNotShowLoading = true;
                                $scope.insertTemplate(true, temp);
                            } );
                            destroy();
                        }
                    };
                    reader.readAsText(file);
                }
            }
            function destroy() {
                input.removeEventListener('change', onChange.bind(input), false);
                document.body.removeChild(input);
            }
        };
        $scope.importImages = function( result, callback ){
            var images = [], extenalDesign = false,
            design = result.design, fonts = result.fonts, new_fonts = fonts;
            if( angular.isDefined( result.config.home_url ) ){
                if( $scope.settings.home_url != result.config.home_url ){
                    new_fonts = [];
                    _.each(fonts, function(font, index){
                        if( font.type == "google" ){
                            new_fonts.push( font );
                        }
                    });
                }
            }

            _.each(design, function(side, sideIndex){
                var objects = side.objects;
                _.each(objects, function(object, objectIndex){
                    var type = object.type, src = object.src;
                    if( type == 'image' || type == 'custom-image' ){
                        // if( src.indexOf( $scope.settings.home_url ) == -1 && src.indexOf( 'data:im' ) == -1 ){ // bỏ chức năng improt bằng link ảnh
                        if( false ){
                            var __index = sideIndex + '_' + objectIndex;
                            ['src', 'origin_url', 'origin_src'].forEach(function(val){
                                if( angular.isDefined( object[val] ) ){
                                    var _index = __index + '_' + val;
                                    images[_index] = object[val];
                                    extenalDesign = true;
                                }
                            });
                        }
                    }
                });
            });
            if( extenalDesign ){
                $scope.toggleStageLoading();
                // var dataObj = {images: images, nonce: NBDESIGNCONFIG['nonce']};
                var dataObj = {images: images, nonce: 'f65e05b30a'};
                NBDDataFactory.get('nbd_import_images', dataObj, function(data){
                    data = JSON.parse(data);
                    if( data.flag == 1 ){
                        var new_images = data.images;
                        _.each(design, function(side, sideIndex){
                            var objects = side.objects;
                            _.each(objects, function(object, objectIndex){
                                var type = object.type;
                                if( type == 'image' || type == 'custom-image' ){
                                    var __index = sideIndex + '_' + objectIndex;
                                    ['src', 'origin_url', 'origin_src'].forEach(function(val){
                                        var _index = __index + '_' + val;
                                        if( angular.isDefined( new_images[_index] ) ){
                                            if( angular.isDefined( object[val] ) ){
                                                object[val] = new_images[_index];
                                            }
                                        }
                                    });
                                }
                            });
                        });
                        callback( design, new_fonts, extenalDesign );
                    } else {
                        alert( 'Import images fail!' );
                    }
                });
            }else{
                callback( design, new_fonts );
            }
        };
        $scope.onloadTemplate = false;
        $scope.currentLocalTempId = 0;
        $scope.templateHolderFields = [];
        $scope.insertTemplate = function(local, temp, action = '', dataDesignLayers){
            $scope.currentLocalTempId = temp.id;
            if( angular.isUndefined( temp.doNotShowLoading ) ){
                $scope.toggleStageLoading( 6E4 );
                $scope.showDesignTab();
            }
            $scope.onloadTemplate = true;
            $scope.contextAddLayers = 'template';
            function loadDesign(design, viewport, konfig){
                var stageIndex = 0;
                function loadStage(stageIndex){
                    var _index = 'frame_' + stageIndex,
                    stage = $scope.stages[stageIndex],
                    _canvas = stage['canvas'],
                    layerIndex = 0;
                    _canvas.clear();
                    // if( angular.isUndefined(design[_index]) ){
                    //     design[_index] = {version:"2.3.3",objects:[]};
                    // };
                    // if( angular.isDefined(design[_index].background) ){
                    //     _canvas.backgroundColor = design[_index].background;
                    // };
                    if(action == 'api') {
                        var objects = design;
                    } else {
                        var objects = design[_index].objects;
                    }
                    function loadLayer(layerIndex){
                        function continueLoadLayer(){
                            layerIndex++;
                            if( objects.length != 0 && layerIndex < objects.length ){
                                loadLayer(layerIndex);
                            }else{
                                stageIndex++;
                                if( stageIndex < $scope.stages.length ){
                                    loadStage(stageIndex);
                                }else{
                                    _.each($scope.stages, function(_stage, index){
                                        $scope.renderStage(index);
                                        var layers = _stage.canvas.getObjects();
                                        $scope.renderTextAfterLoadFont(layers, function(){
                                            $scope.deactiveAllLayer();
                                            $scope.renderStage(index);
                                            $timeout(function(){
                                                $scope.deactiveAllLayer();
                                                $scope.renderStage(index);
                                                if( index == $scope.stages.length - 1 ){
                                                    $scope.onloadTemplate = false;
                                                    $scope.contextAddLayers = 'normal';
                                                    if( angular.isDefined(viewport) ){
                                                        $scope.resizeStages(viewport);
                                                    } else if( angular.isDefined(konfig) &&  angular.isDefined(konfig.scale) ){
                                                        viewport = {width: konfig.scale * 500, height: konfig.scale * 500};
                                                        $scope.resizeStages(viewport);
                                                    }else{
                                                        $scope.toggleStageLoading();
                                                    }
                                                    $scope.afterInsertTemplate();
                                                }
                                            }, 1000);
                                        });
                                    });
                                }
                            }
                        };
                        function loadFont(font, callback) {
                            _stage = $scope.stages[stageIndex];
                            if(!_.filter($scope.resource.font.data, ['alias', font.alias]).length){
                                // if( angular.isDefined(font.file) && angular.isDefined(font.file.r) )$scope.resource.font.data.push(font);

                                if( angular.isDefined(font.url) )$scope.resource.font.data.push({ r: font.url });
                            };
                            if(!_.filter(_stage.states.usedFonts, ['alias', font.alias]).length){
                                _stage.states.usedFonts.push($scope.formatFont(font));
                            };
                            $scope.insertTemplateFont(font.alias, function(){
                                if( typeof callback == 'function' ) callback();
                                if(!_.filter($scope.resource.usedFonts, ['alias', font.alias]).length){
                                    $scope.resource.usedFonts.push($scope.formatFont(font));
                                };
                            });
                        }
                        if( objects.length > 0 ){
                            var item = objects[layerIndex],
                            type = item.type;
                            var mustInsert = true;
                            if( type == 'image' || type == 'custom-image' ){
                                if( angular.isDefined(item.avatar) ){
                                    if( angular.isDefined($scope.settings.contact_sheets) ){
                                        item.src = $scope.settings.contact_sheets.avatar;
                                    }
                                }
                                if(mustInsert){
                                    fabric.Image.fromObject(item, function(_image){
                                        _canvas.add(_image);
                                        continueLoadLayer();
                                    });
                                }else{
                                    continueLoadLayer();
                                }
                            }else{
                                var klass = fabric.util.getKlass(type);
                                // if( ['i-text', 'text', 'textbox', 'curvedText'].indexOf( type ) > -1  ){
                                //     if(!_.filter(stage.states.usedFonts, ['alias', item.fontFamily]).length){
                                //         stage.states.usedFonts.push($scope.formatFont(item.font));
                                //     };
                                // };
                                ['first_name', 'last_name', 'full_name', 'company', 'address', 'postcode', 'city', 'phone', 'email', 'mobile', 'website', 'title'].forEach(function(val){
                                    if( angular.isDefined(item[val]) ){
                                        if( angular.isDefined($scope.settings.user_infos) ){
                                            item.text = $scope.settings.user_infos[val].value;
                                        }
                                    }
                                });
                                if( angular.isDefined( item.field_mapping ) && !$scope.isTemplateMode ){
                                    var field = _.filter($scope.settings.template_fields, { key: item.field_mapping })[0];
                                    if( angular.isDefined( field ) ){
                                        if( field.value != '' ){
                                            if( angular.isDefined( item.is_uppercase ) ){
                                                item.text = item.is_uppercase ? field.value.toUpperCase() : field.value.toLowerCase();
                                            }else{
                                                item.text = field.value;
                                            }
                                        }else{
                                            var mapping_field = _.filter($scope.templateHolderFields, { key: item.field_mapping })[0];
                                            if( angular.isUndefined( mapping_field ) ){
                                                $scope.templateHolderFields.push( JSON.parse( JSON.stringify( field ) ) );
                                            }
                                        }
                                    }
                                }
                                if( angular.isDefined(item.v_card) && !$scope.isTemplateMode && $scope.settings.is_logged == '1' ){
                                    $scope.generateVcard( function( newObject ){
                                        var config = {
                                            left: item.left,
                                            top: item.top,
                                            scaleX: item.scaleX,
                                            scaleY: item.scaleY,
                                            fill: object.fill
                                        };
                                        newObject.set( config );
                                        newObject.scaleToWidth(item.width * item.scaleX);
                                        newObject.scaleToWidth(item.width * item.scaleX);
                                        if( ['i-text', 'text', 'textbox', 'curvedText'].indexOf( type ) > -1  ){
                                            if(!_.filter(stage.states.usedFonts, ['alias', item.fontFamily]).length){
                                                stage.states.usedFonts.push($scope.formatFont(item.font));
                                            };
                                        };
                                        if( ['i-text', 'text', 'textbox', 'curvedText'].indexOf( type ) > -1 && angular.isDefined(item.font) ){
                                            loadFont(item.font, function() {
                                                _canvas.add( newObject );
                                            })
                                        } else {
                                            _canvas.add( newObject );
                                        }
                                        
                                        continueLoadLayer();
                                    });
                                } else {
                                    if( angular.isDefined(item.vcard) ){
                                        var config = {
                                            left: item.left,
                                            top: item.top,
                                            vcard: 1
                                        };
                                        $scope.strVcard = '';
                                        if( angular.isDefined($scope.settings.user_infos) ){
                                            var infos = $scope.settings.user_infos;
                                            $scope.strVcard += 'BEGIN:VCARD\nVERSION:3.0\n';
                                            $scope.strVcard += 'N:'+infos.last_name.value+';'+infos.first_name.value+'\n'+ 'FN:'+infos.full_name.value;
                                            $scope.strVcard += '\nADR;TYPE=home:;;'+infos.address.value+';'+infos.city.value+';;'+infos.postcode.value+';'+infos.country.value;
                                            $scope.strVcard += '\nTEL;TYPE=home:'+infos.phone.value;
                                            $scope.strVcard += '\nTEL;TYPE=work:'+infos.mobile.value;
                                            $scope.strVcard += '\nEMAIL;TYPE=internet,work:'+infos.email.value;
                                            $scope.strVcard += '\nURL;TYPE=work:'+infos.website.value;
                                            $scope.strVcard += '\nEND:VCARD';
                                            var qr = qrcode('0', 'M');
                                            qr.addData( $scope.strVcard );
                                            qr.make();
                                            var _qrcode = qr.createSvgTag();
                                            fabric.loadSVGFromString(_qrcode, function(ob, op) {        
                                                var object = fabric.util.groupSVGElements(ob, op);
                                                object.set(config);
                                                object.scaleToWidth(item.width * item.scaleX);
                                                object.scaleToHeight(item.height * item.scaleY);
                                                object.vcard = 1;
                                                if( ['i-text', 'text', 'textbox', 'curvedText'].indexOf( type ) > -1 && angular.isDefined(item.font) ){
                                                    loadFont(item.font, function() {
                                                        _canvas.add(object);
                                                    })
                                                } else {
                                                    _canvas.add(object);
                                                }
                                                continueLoadLayer();
                                            });
                                        }else{
                                            klass.fromObject(item, function(item){
                                                if( ['i-text', 'text', 'textbox', 'curvedText'].indexOf( type ) > -1 && angular.isDefined(item.font) ){
                                                    loadFont(item.font, function() {
                                                        _canvas.add(item);
                                                    })
                                                } else {
                                                    _canvas.add(item);
                                                }
                                                continueLoadLayer();
                                            });
                                        }
                                    }else{
                                        if(mustInsert){
                                            if( type == 'text' ){
                                                var text = item.text;
                                                var textobj = {};
                                                angular.copy(item, textobj);
                                                delete textobj.text;
                                                delete textobj.type;
                                                var textbox = new fabric.IText(text, textobj);
                                                _canvas.add(textbox);
                                                if( angular.isDefined(item.font) ){
                                                    loadFont(item.font, function() {
                                                        _canvas.add(textbox);
                                                    })
                                                } else {
                                                    _canvas.add(textbox);
                                                }
                                                continueLoadLayer();
                                            } else if( !!item.isTemMask && !$scope.isTemplateMode ){
                                                klass.fromObject(item, function(item){
                                                    item.set({
                                                        isMask: 1,
                                                        absolutePositioned: true,
                                                        strokeWidth: 0,
                                                        lockRotation: true,
                                                        selectable: false,
                                                        _isTemMask: true,
                                                        fill: '#ffffff',
                                                        opacity: 0.001
                                                    });
                                                    delete item.isTemMask;
                                                    if( ['i-text', 'text', 'textbox', 'curvedText'].indexOf( type ) > -1 && angular.isDefined(item.font) ){
                                                        loadFont(item.font, function() {
                                                            _canvas.add(item);
                                                        })
                                                    } else {
                                                        _canvas.add(item);
                                                    }
                                                    var maskLayer = _canvas.item(_canvas.getObjects().length - 1),
                                                    maskId = maskLayer.get( 'itemId' ),
                                                    defaultMaskImageUrl = $scope.settings.assets_url + 'images/placeholder.png';
                                                    fabric.Image.fromURL(defaultMaskImageUrl, function(op) {
                                                        var top = maskLayer.get('top'),
                                                        left = maskLayer.get('left'),
                                                        scaleX = maskLayer.get('scaleX'),
                                                        scaleY = maskLayer.get('scaleY'),
                                                        width = maskLayer.get('width'),
                                                        height = maskLayer.get('height'),
                                                        realWidth = width * scaleX,
                                                        realHeight = height * scaleY,
                                                        newWidth = realWidth,
                                                        newHeight = realHeight;
                                                        if( ( op.width / op.height ) > ( realWidth / realHeight ) ){
                                                            newWidth = op.width / op.height * newHeight;
                                                        }else{
                                                            newHeight = op.height / op.width * newWidth;
                                                        }
                                                        var d = new Date(),
                                                        itemId = d.getTime() + Math.floor(Math.random() * 1000);
                                                        op.set({
                                                            clipPath: maskLayer,
                                                            perPixelTargetFind: true,
                                                            centeredScaling: true,
                                                            maskId: maskId,
                                                            scaleX: newWidth / op.width,
                                                            scaleY: newHeight / op.height,
                                                            top: top + realHeight / 2,
                                                            left: left + realWidth / 2,
                                                            itemId: itemId,
                                                            isEmptyMask: true,
                                                            srcChanged: false
                                                        });
                                                        if( !!maskLayer.get('forceLock') ) op.set({lockMask: true});
                                                        _canvas.add(op);
                                                        continueLoadLayer();
                                                    }, {crossOrigin: 'anonymous'});
                                                });
                                            }else{
                                                klass.fromObject(item, function(item){
                                                    if( ['i-text', 'text', 'textbox', 'curvedText'].indexOf( type ) > -1 && angular.isDefined(item.font) ){
                                                        loadFont(item.font, function() {
                                                            _canvas.add(item);
                                                        })
                                                    } else {
                                                        _canvas.add(item);
                                                    }
                                                    continueLoadLayer();
                                                });
                                            }
                                        }else{
                                            continueLoadLayer();
                                        }
                                    }
                                }
                            }
                        }else{
                            continueLoadLayer();
                        }
                    };
                    loadLayer(layerIndex);
                };
                loadStage(stageIndex);
            }
            if( local ){
                loadDesign(temp.design, temp.viewport);
            }else{
                var urlGetLayer = apiPre + 'templates/' + temp.id;
                if($scope.settings.task == 'edit') {
                    var urlGetLayer = apiPre + 'designs/' + temp.id;
                }
                var headers = apiAuthBearer;

                function getLayers() {
                    if( angular.isUndefined(dataDesignLayers) ) {
                        return $http({
                            method: "GET",
                            url: urlGetLayer,
                            headers: headers,
                        });
                    }
                    return;
                }
                Promise.all([getLayers()])
                .then( function(results) {
                    var layers = angular.isDefined(dataDesignLayers.layers) ? dataDesignLayers.layers : null;
                    var viewport = angular.isDefined(dataDesignLayers.viewport) ? dataDesignLayers.viewport : null;
                    if(angular.isDefined(results[0]) && results[0].status === 200) {
                        layers = results[0].data.data.layers;
                        viewport = results[0].data.data.viewport;
                    }
                    if(layers && viewport) {
                        loadDesign(layers, viewport);
                    } else {
                        alert('Error load page');
                    }
                });
            }
        };
        $scope.getGlobalTemplateDefault = function(id, callback){
            var url = apiPre + "templates/" + id;
            var headers = apiAuthBearer;
            headers['Content-Type'] = undefined;
            $http({
                method: "GET",
                headers: headers,
                url: url,
            }).then(function successCallback(response){
                if(response.status == 200 && response.data.data){
                    var designs = {};
                    if(angular.isDefined(response.data.data.layers)) {
                        designs['layers'] = response.data.data.layers;
                    }
                    if(angular.isDefined(response.data.data.viewport)) {
                        designs['viewport'] = response.data.data.viewport;
                    }
                    if( typeof callback == 'function' ) callback(designs);
                }else{
                    $scope.toggleStageLoading();
                    console.log('Error load global template!');
                };
            }, function errorCallback(response) {
                $scope.toggleStageLoading();
                console.log('Error load global template!');
            });
        };
        $scope.getGlobalTemplate = function(id, callback){
            var url = apiPre + "templates/" + id;
            var headers = apiAuthBearer;
            headers['Content-Type'] = undefined;
            $http({
                method: "GET",
                headers: headers,
                url: url,
            }).then(function successCallback(response){
                if(response.status == 200 && response.data.data){
                    var designs = {};
                    if(angular.isDefined(response.data.data.layers)) {
                        designs['layers'] = response.data.data.layers;
                    }
                    if(angular.isDefined(response.data.data.viewport)) {
                        designs['viewport'] = response.data.data.viewport;
                    }
                    $scope.toggleStageLoading();
                    if( typeof callback == 'function' ) callback(designs);
                }else{
                    $scope.toggleStageLoading();
                    console.log('Error load global template!');
                };
            }, function errorCallback(response) {
                $scope.toggleStageLoading();
                console.log('Error load global template!');
            });
        };

        $scope.insertGlobalTemplate = function(id){
            $scope.showDesignTab();
            $scope.clearHistory();
            $scope.toggleStageLoading();
            $scope.getGlobalTemplate(id, function(data){
                $scope.insertTemplate(false, {id: id}, 'api' , data);
            });
        };

        $scope.insertGlobalTemplateDefault = function(id){
            $scope.showDesignTab();
            $scope.clearHistory();
            $scope.toggleStageLoading();
            $scope.getGlobalTemplateDefault(id, function(data){
                var design = data;
                var viewport = angular.isUndefined(design.viewport) ? design.viewport : {width: 200, height: 200};    
                $scope.onloadTemplate = true;
                $scope.contextAddLayers = 'template';
                var stageIndex = 0;
                function afterLoadStage(){
                    $scope.onloadTemplate = false;
                    $scope.contextAddLayers = 'normal';
                    $scope.toggleStageLoading();
                    $scope.afterInsertTemplate();
                }
                function loadStage(stageIndex){
                    if( angular.isUndefined($scope.stages[stageIndex]) || stageIndex >= $scope.stages.length ){
                        if( stageIndex >= $scope.stages.length ) afterLoadStage();
                        return;
                    }
                    stage = $scope.stages[stageIndex],
                    _canvas = stage['canvas'],
                    layerIndex = 0;
                    stage.states.usedFonts = [];
                    _canvas.clear();
                    var objects = design.layers;
                    if( objects.length == 0 ) {
                        return;
                    }
                    var stageLayers = [];
                    function loadLayer(layerIndex){
                        function continueLoadLayer(){
                            layerIndex++;
                            if( layerIndex < objects.length ){
                                loadLayer(layerIndex);
                            }else{
                                fitTemplateWithStage();
                                stageIndex++;
                                if( stageIndex < $scope.stages.length ){
                                    loadStage(stageIndex);
                                }else{
                                    afterLoadStage();
                                }
                            }
                        }
                        function fitTemplateWithStage(){
                            var rec = $scope.fitRectangle(stage.config.width, stage.config.height, viewport.width, viewport.height, true),
                            factor = rec.width / viewport.width;
                            _.each(stageLayers, function(obj){
                                var scaleX = obj.get('scaleX'),
                                scaleY = obj.get('scaleY'),
                                top = obj.get('top'),
                                left = obj.get('left');
                                obj.set({
                                    scaleX: scaleX * factor,
                                    scaleY: scaleY * factor,
                                    left: left * factor + rec.left,
                                    top: top * factor + rec.top
                                });
                                obj.setCoords();
                            });
                            $scope.deactiveAllLayer(stageIndex);
                            $scope.renderStage(stageIndex);
                        }
                        function addLayer(_item, callback){
                            _canvas.add(_item);
                            var __item = _canvas.item(_canvas.getObjects().length - 1);
                            if(typeof callback === 'function') callback(__item);
                            stageLayers.push(__item);
                            continueLoadLayer();
                        }

                        var item = objects[layerIndex],
                        type = item.type;
                        if( type === 'image' || type === 'custom-image' ){
                            fabric.Image.fromObject(item, function(_image){
                                addLayer(_image);
                            });
                        }else{

                            var klass = fabric.util.getKlass(type);
                            var is_text = false;
                            if( ['i-text', 'text', 'textbox', 'curvedText'].indexOf( type ) > -1  ){
                                // update font
                                
                                if(!_.filter($scope.resource.font.data, ['alias', item.font.alias]).length){
                                    $scope.resource.usedFonts.push($scope.formatFont(item.font));
                                };   
                                var font_id = item.font.name.replace(/\s/gi, '').toLowerCase();
                                if( !jQuery('#' + font_id).length ){
                                    jQuery('head').append('<link id="' + font_id + '" href="https://fonts.googleapis.com/css?family='+ item.font.name.replace(/\s/gi, '+') +':400,400i,700,700i" rel="stylesheet" type="text/css">');
                                }
                                if(!_.filter(stage.states.usedFonts, ['alias', item.fontFamily]).length){
                                    var layerFont = $scope.getFontInfo(item.fontFamily);
                                    stage.states.usedFonts.push($scope.formatFont(item.font));
                                };
                                is_text = true;
                            };
                            klass.fromObject(item, function(item){
                                if(is_text){
                                    var fontFamily = item.fontFamily,
                                    fontWeight = angular.isDefined(item.fontWeight) ? item.fontWeight : '',
                                    fontStyle = angular.isDefined(item.fontStyle) ? item.fontStyle : '',
                                    _font = $scope.getFontInfo(fontFamily);
                                    item.set({objectCaching: false});

                                    var font = new FontFaceObserver(fontFamily, {weight: fontWeight, style: fontStyle});
                                    font.load($scope.settings.subsets[_font.subset]['preview_text']).then(function () {
                                        fabric.util.clearFabricFontCache();
                                        addLayer(item, function(__item){
                                            __item.initDimensions();
                                            __item.setCoords();
                                        });
                                    }, function () {
                                        console.log('Error load font: '+fontFamily);
                                        addLayer(item);
                                    });
                                }else{
                                    addLayer(item);
                                }
                            });
                        }
                    }
                    loadLayer(layerIndex);
                }
                loadStage(stageIndex);
            });
        };

        $scope.clearHistory = function(){
            var _stage = this.stages[this.currentStage];
            _stage.undos = [];
            _stage.redos = [];
            _stage.states.isRedoable = false;
            _stage.states.isUndoable = false;
            $scope.updateApp();
        };
        /* Stage */
        $scope.resizeStages = function(viewport){
            _.each($scope.stages, function(stage, index){ 
                var currentViewport = $scope.viewPort;
                var newFitRec = $scope.fitRectangle(viewport.width, viewport.height, stage.config._width, stage.config._height, true);
                var oldFitRec = $scope.fitRectangle(currentViewport.width, currentViewport.height, stage.config._width, stage.config._height, true);
                var factor = oldFitRec.width / newFitRec.width;
                if( factor != 1 ){
                    stage.canvas.forEachObject(function(obj) {
                        var scaleX = obj.scaleX,
                        scaleY = obj.scaleY,
                        left = obj.left,
                        top = obj.top,
                        tempScaleX = scaleX * factor,
                        tempScaleY = scaleY * factor,
                        tempLeft = left * factor,
                        tempTop = top * factor;

                        obj.scaleX = tempScaleX;
                        obj.scaleY = tempScaleY;

                        obj.left = tempLeft;
                        obj.top = tempTop;

                        if( obj.clipPath && obj.clipPath.absolutePositioned & !obj.clipPath._isTemMask ){
                            var scaleX = obj.clipPath.scaleX,
                            scaleY = obj.clipPath.scaleY,
                            left = obj.clipPath.left,
                            top = obj.clipPath.top,
                            tempScaleX = scaleX * factor,
                            tempScaleY = scaleY * factor,
                            tempLeft = left * factor,
                            tempTop = top * factor;
                            obj.clipPath.scaleX = tempScaleX;
                            obj.clipPath.scaleY = tempScaleY;
                            obj.clipPath.left = tempLeft;
                            obj.clipPath.top = tempTop;
                        }
                        if( obj.clipPath && obj.clipPath.absolutePositioned & obj.clipPath._isTemMask ){
                            delete obj.clipPath._isTemMask;
                        }
                        obj.setCoords();
                    });
                    stage.canvas.calcOffset();
                    $scope.renderStage(index);
                }
                if( index == $scope.stages.length - 1 ){
                    $scope.toggleStageLoading();
                }
            });
        };
        $scope.closePopupClearStage = function(){
            jQuery('.clear-stage-alert .close-popup').triggerHandler('click');
        };
        /* Fonts */
        $scope.loadFontFailAction = function( font ){
            _.remove($scope.settings.gg_fonts, {
                id: font.id
            });
            $scope.resource.font.filteredFonts = filterFontFilter($scope.resource.font.data, $scope.resource.font.filter);
            $scope.updateApp();
        };

        $scope.tabActived = 1;
        $scope.showTabFont = function(action){
            var isOpen = false;
            var $tab = $('.nbd-sidebar .tabs-nav .tab');
            var $tabFont = $('.nbd-sidebar .tabs-content .tab#tab-font');
            var $tabContent = $('.nbd-sidebar .tabs-content .tab');
            if($tabFont.hasClass('active')) isOpen = true;
            if( action != 'click' && !$tabFont.hasClass('active') ) return;
            if (checkMobileDevice()) {
                $('.nbd-workspace .main').removeClass('active');
                $('.nbd-sidebar .tabs-content').addClass('active');
                $('.nbd-sidebar .tabs-content').removeClass('nbd-prevent-click');
                $('.nbd-sidebar .tabs-content').removeClass('nbd-hidden');
            }
            if( !isOpen ) {
                $tabFont.addClass('active');
                $tabFont.removeClass('after');
            } else {
                $tabFont.removeClass('active');
            }
            $tabContent.each(function (j) {
                if( !isOpen ) {
                    if( $(this).hasClass('active') && $(this).data('type') != 'font' ) {
                        $scope.tabActived = $(this).index() - 1;
                    }
                    if( $(this).data('type') != 'font' ) {
                        $(this).removeClass('active');
                    }
                } else {
                    if( j+1 == $scope.tabActived) {
                        if (checkMobileDevice()) {
                            $(this).prevAll().addClass('left');
                            $(this).nextAll().addClass('right');
                        }else {
                            $(this).prevAll().addClass('before');
                            $(this).nextAll().addClass('after');
                        }
                        $(this).addClass('active');
                        $tabFont.removeClass('active');
                    }
                }
            });
        };


        // Tip
        $scope.tips = {
            total: 3,
            current: 1,
            firstTime: true
        };
        $scope.toggleTip = function( close ){
            var first_visitor = getCookie("nbdesigner_user");
            if( angular.isDefined( close ) ){
                if( close ){
                    jQuery('.nbd-tip').removeClass('nbd-show');
                    if( $scope.tips.firstTime ){
                        $timeout(function(){
                            $scope.tips.current = 2;
                            $scope.toggleTip( false );
                        }, 10000);
                    }
                    $scope.tips.firstTime = false;
                }else{
                    jQuery('.nbd-tip').addClass('nbd-show');
                }
            }else{
                if (first_visitor == "") {
                    setCookie("nbdesigner_user", 'Hello World', 0.5);
                    jQuery('.nbd-tip').addClass('nbd-show');
                }
            }
        };
        $scope.nextTip = function(){
            $scope.tips.current = $scope.tips.current == $scope.tips.total ? 1 : ( $scope.tips.current + 1 );
        };

        /* Close Deisgn tool */
        $scope.closeDesignTool = function() {
            window.parent.postMessage({message: 'closeDesignTool', closeDesignTool: true}, parentUrl);
        }
    }
    /* End */
]);

/* Fabric config */
var fabricConfig = {
    nbdesigner_default_color: '#cc324b',
    nbdesigner_object_center_scaling: 'no',
    nbdesigner_enable_text_free_transform: 'no',
    nbdesigner_text_rotate: 1,
    nbdesigner_enable_cloud2print_api: 'no',
    nbdesigner_enable_font_to_outlines: 'no',
}
function buildSvgFilter( jOptions, _in ){
    var options = JSON.parse( jOptions ),
    filter = '';
    _in = angular.isDefined( _in ) ? _in : 'SourceGraphic';
    switch( options.type ){
        case 'blur':
            var value = angular.isDefined( options.value ) ? options.value : 5;
            filter += '<feGaussianBlur stdDeviation="' + value + '" in="' + _in + '" result="' + options.type + '"/>';
            break;
        case 'desaturate':
            filter += '<feColorMatrix type="saturate" in="' + _in + '" values="0" result="' + options.type + '"/>';
            break;
        case 'contrast':
            var slope = angular.isDefined( options.slope ) ? options.slope : 5;
            var intercept = -(0.3 * slope) + 0.3;
            filter += '<feComponentTransfer in="' + _in + '" result="' + options.type + '">';
            filter +=       '<feFuncR type="linear" slope="' + slope + '" intercept="' + intercept + '"/>';
            filter +=       '<feFuncG type="linear" slope="' + slope + '" intercept="' + intercept + '"/>';
            filter +=       '<feFuncB type="linear" slope="' + slope + '" intercept="' + intercept + '"/>';
            filter += '</feComponentTransfer>';
            break;
        case 'sepiatone':
            filter += '<feColorMatrix type="matrix" in="' + _in + '" values=".343 .669 .119 0 0 .249 .626 .130 0 0 .172 .334 .111 0 0 .000 .000 .000 1 0" result="' + options.type + '"/>';
            break;
        case 'hue':
            var rotate = angular.isDefined( options.value ) ? options.value : 180;
            filter += '<feColorMatrix type="hueRotate" values="' + rotate + '" in="' + _in + '" result="' + options.type + '"/>';
            break;
        case 'luminance':
            filter += '<feColorMatrix type="luminanceToAlpha" in="' + _in + '" result="' + options.type + '"/>';
            break;
        case 'colorize':
            filter += '<feColorMatrix type="matrix" in="' + _in + '" values="1.0 0 0 0 0 0 0.2 0 0 0 0 0 0.2 0 0 0 0 0 1.0 0" result="' + options.type + '"/>';
            break;
        case 'posterize':
            filter += '<feComponentTransfer in="' + _in + '" result="' + options.type + '">';
            filter +=       '<feFuncR type="discrete" tableValues="0 0.2 0.4 0.6 0.8 1" />';
            filter +=       '<feFuncG type="discrete" tableValues="0 0.2 0.4 0.6 0.8 1" />';
            filter +=       '<feFuncB type="discrete" tableValues="0 0.2 0.4 0.6 0.8 1" />';
            filter += '</feComponentTransfer>';
            break;
        case 'darken':
            filter += '<feComponentTransfer in="' + _in + '" result="' + options.type + '">';
            filter +=       '<feFuncR type="linear" slope="0.2" />';
            filter +=       '<feFuncG type="linear" slope="0.2" />';
            filter +=       '<feFuncB type="linear" slope="0.2" />';
            filter += '</feComponentTransfer>';
            break;
        case 'lighten':
            filter += '<feComponentTransfer in="' + _in + '" result="' + options.type + '">';
            filter +=       '<feFuncR type="linear" slope="1.5" intercept="0.2" />';
            filter +=       '<feFuncG type="linear" slope="1.5" intercept="0.2" />';
            filter +=       '<feFuncB type="linear" slope="1.5" intercept="0.2" />';
            filter += '</feComponentTransfer>';
            break;
        case 'invert':
            filter += '<feComponentTransfer in="' + _in + '" result="' + options.type + '">';
            filter +=       '<feFuncR type="table" tableValues="1 0" />';
            filter +=       '<feFuncG type="table" tableValues="1 0" />';
            filter +=       '<feFuncB type="table" tableValues="1 0" />';
            filter += '</feComponentTransfer>';
            break;
        case 'gamma1':
            filter += '<feComponentTransfer in="' + _in + '" result="' + options.type + '">';
            filter +=       '<feFuncR type="gamma" amplitude="1" exponent="0.5" offset="0" />';
            filter +=       '<feFuncG type="gamma" amplitude="1" exponent="0.5" offset="0" />';
            filter +=       '<feFuncB type="gamma" amplitude="1" exponent="0.5" offset="0" />';
            filter += '</feComponentTransfer>';
            break;
    }
    return filter;
};
function requestFullScreen(element) {
    var requestMethod = element.requestFullScreen || element.webkitRequestFullScreen || element.mozRequestFullScreen || element.msRequestFullScreen;
    if (requestMethod) { 
        requestMethod.call(element);
    } else if (typeof window.ActiveXObject !== "undefined") {
        var wscript = new ActiveXObject("WScript.Shell");
        if (wscript !== null) {
            wscript.SendKeys("{Esc}");
        }
    }
};
function exitFullscreen(){
    var a = document.webkitExitFullscreen || document.mozCancelFullScreen || document.msExitFullscreen || document.exitFullscreen;
    a && a.call(document);
};
function setCookie(cname, cvalue, exdays) {
    var d = new Date();
    d.setTime(d.getTime() + (exdays * 24 * 60 * 60 * 1000));
    var expires = "expires=" + d.toUTCString();
    document.cookie = cname + "=" + cvalue + "; " + expires;
};
function getCookie(cname) {
    var name = cname + "=";
    var ca = document.cookie.split(';');
    for (var i = 0; i < ca.length; i++) {
        var c = ca[i];
        while (c.charAt(0) == ' ') {
            c = c.substring(1);
        }
        if (c.indexOf(name) == 0) {
            return c.substring(name.length, c.length);
        }
    }
    return "";
};
nbdApp.factory('FabricWindow', ['$window', function($window) {
    /* Fabric configuration */
    fabric.disableStyleCopyPaste = true;
    fabric.Object.NUM_FRACTION_DIGITS = 10;
    $window.fabric.Object.prototype.set({ 
        transparentCorners: false,
        borderColor: 'rgba(79, 84, 103,0.7)',
        cornerStyle: 'circle',
        cornerColor: 'rgba(255,255,255,1)',
        borderDashArray:[2,2],
        cornerStrokeColor: 'rgba(63, 70, 82,1)',
        fill : fabricConfig.nbdesigner_default_color, 
        hoverCursor: 'pointer',
        borderOpacityWhenMoving: 0
    });
    if( defaultSettings.nbdesigner_object_center_scaling == 'yes' ){
        $window.fabric.Object.prototype.set({centeredScaling: true });
    };
    if( checkMobileDevice() ) $window.fabric.Object.prototype.set({cornerSize: 17});
    $window.fabric.IText.prototype.set({
        cursorWidth: 1,
        cursorColor: '#000',
        selectionColor: "rgba(1, 196, 204, 0.3)",
        cursorDuration: 500,
        strokeWidth: 0
    });
    if( fabricConfig.nbdesigner_enable_text_free_transform == 'no' ){
        $window.fabric.IText.prototype.set({
            _controlsVisibility: {
                tl: true,
                tr: true,
                br: true,
                bl: true,
                ml: false,
                mt: false,
                mr: false,
                mb: false,
                mtr: fabricConfig.nbdesigner_text_rotate == '1' ? true : false
            }
        });
    }
    $window.fabric.Canvas.prototype.set({
        preserveObjectStacking : true,
        controlsAboveOverlay: true,
        selectionColor: 'rgba(1, 196, 204, 0.3)',
        selectionBorderColor: '#01c4cc',
        selectionLineWidth: 0.5,
        centeredKey: "shiftKey",
        uniScaleKey: "altKey"
    });  
    $window.fabric.Textbox.prototype.set({
        _controlsVisibility: {
            tl: true,
            tr: true,
            br: true,
            bl: true,
            ml: true,
            mt: false,
            mr: true,
            mb: false,
            mtr: fabricConfig.nbdesigner_text_rotate == '1' ? true : false
        },
        paintFirst: fabricConfig.nbdesigner_enable_cloud2print_api == 'yes' ? "stroke" : "fill",
        /* strokeLineJoin: 'round' */
    });
    // Fix resize group
    $window.fabric.Group.prototype.set({
        _controlsVisibility: {
            tl: true,
            tr: true,
            br: true,
            bl: true,
            ml: false,
            mt: false,
            mr: false,
            mb: false,
            mtr: true,
        },
        /* strokeLineJoin: 'round' */
    });
    $window.fabric.Image.prototype.set({
        originX: 'center',
        originY: 'center'
    });
    $window.fabric.CurvedText.prototype.set({
        originX: 'center',
        originY: 'top'
    }); 
    fabric.enableGLFiltering = false;
    fabric.PathGroup = { };
    fabric.PathGroup.fromObject = function (object, callback) {
        var originalPaths = object.paths;
        delete object.paths;
        if (typeof originalPaths === 'string') {
            fabric.loadSVGFromURL(originalPaths, function (elements) {
                var pathUrl = originalPaths;
                var group = fabric.util.groupSVGElements(elements, object, pathUrl);
                group.type = 'group';
                object.paths = originalPaths;
                callback(group);
            });
        } else {
            fabric.util.enlivenObjects(originalPaths, function (enlivenedObjects) {
                enlivenedObjects.forEach(function (obj) {
                    obj._removeTransformMatrix();
                });
                var group = new fabric.Group(enlivenedObjects, object);
                group.type = 'group';
                object.paths = originalPaths;
                callback(group);
            });
        }
    };
    fabric.Image.prototype._toSVG = function() {
        var svgString = [], imageMarkup = [], strokeSvg,
            x = -this.width / 2, y = -this.height / 2, clipPath = '', imageFilter = '';
        if (this.hasCrop()) {
            var clipPathId = fabric.Object.__uid++;
            svgString.push(
            '<clipPath id="imageCrop_' + clipPathId + '">\n',
            '\t<rect x="' + x + '" y="' + y + '" width="' + this.width + '" height="' + this.height + '" />\n',
            '</clipPath>\n'
            );
            clipPath = ' clip-path="url(#imageCrop_' + clipPathId + ')" ';
        }
        if( this.filters.length ){
            var width = this._element.width || this._element.naturalWidth,
            height = this._element.height || this._element.height;
            if( !!this.origin_url && !angular.isDefined( this.cropped ) ){
                width = this.origin_width;
                height = this.origin_height;
            }
            var filters = this.filters,
            d = new Date(),
            randomId = d.getTime() + Math.floor(Math.random() * 1000),
            filterId = 'filter_' + randomId,
            filterCode = '<filter id="' + filterId + '" x="' + ( x - this.cropX ) + '" y="' + ( y - this.cropY ) + '" width="' + width + '" height="' + height + '" filterUnits="userSpaceOnUse">';
            filters.forEach(function(filter, index) {
                var _in;
                if( index > 0 ){
                    var options = JSON.parse( filters[index - 1].jOptions );
                    _in  = options.type;
                }
                filterCode += buildSvgFilter( filter.jOptions, _in );
            });
            filterCode += '</filter>';
            imageMarkup.push( filterCode );
            imageFilter = ' filter="url(#' + filterId + ')"';
        }
        if( !!this.origin_url && !angular.isDefined( this.cropped ) ){
            imageMarkup.push('\t<image ', 'COMMON_PARTS', 'xlink:href="', this.origin_url,
            '" x="', x - this.cropX, '" y="', y - this.cropY,
            '" width="', this.origin_width,
            '" height="', this.origin_height,
            '"', clipPath, imageFilter,
            '></image>\n');
        }else{
            imageMarkup.push('\t<image ', 'COMMON_PARTS', 'xlink:href="', this.getSvgSrc(false),
            '" x="', x - this.cropX, '" y="', y - this.cropY,
            '" width="', this._element.width || this._element.naturalWidth,
            '" height="', this._element.height || this._element.height,
            '"', clipPath, imageFilter,
            '></image>\n');
        }
        if (this.stroke || this.strokeDashArray) {
            var origFill = this.fill;
            this.fill = null;
            strokeSvg = [
            '\t<rect ',
            'x="', x, '" y="', y,
            '" width="', this.width, '" height="', this.height,
            '" style="', this.getSvgStyles(),
            '"/>\n'
            ];
            this.fill = origFill;
        }
        if (this.paintFirst !== 'fill') {
            svgString = svgString.concat(strokeSvg, imageMarkup);
        }
        else {
            svgString = svgString.concat(imageMarkup, strokeSvg);
        }
        return svgString;
    };

    fabric.Image.prototype.applyFilters =  function(filters, callback, reset) {
        filters = filters || this.filters || [];
        filters = filters.filter(function(filter) { return filter && !filter.isNeutralState(); });
        this.set('dirty', true);
  
        this.removeTexture(this.cacheKey + '_filtered');
  
        if (filters.length === 0) {
          this._element = this._originalElement;
          this._filteredEl = null;
          this._filterScalingX = 1;
          this._filterScalingY = 1;
          if( typeof callback == 'function' ) callback();
          return this;
        }

        if( reset ){
            this._element = this._originalElement;
            this._filteredEl = null;
        }

        var imgElement = this._originalElement,
            sourceWidth = imgElement.naturalWidth || imgElement.width,
            sourceHeight = imgElement.naturalHeight || imgElement.height;

        if (this._element === this._originalElement) {
          var canvasEl = fabric.util.createCanvasElement();
          canvasEl.width = sourceWidth;
          canvasEl.height = sourceHeight;
          this._element = canvasEl;
          this._filteredEl = canvasEl;
        }
        else {
          this._element = this._filteredEl;
          this._filteredEl.getContext('2d').clearRect(0, 0, sourceWidth, sourceHeight);
          this._lastScaleX = 1;
          this._lastScaleY = 1;
        }
        if (!fabric.filterBackend) {
          fabric.filterBackend = fabric.initFilterBackend();
        }
        fabric.filterBackend.applyFilters(
          filters, this._originalElement, sourceWidth, sourceHeight, this._element, this.cacheKey, callback);
        if (this._originalElement.width !== this._element.width ||
          this._originalElement.height !== this._element.height) {
          this._filterScalingX = this._element.width / this._originalElement.width;
          this._filterScalingY = this._element.height / this._originalElement.height;
        }
        return this;
    };
    fabric.Canvas2dFilterBackend.prototype.applyFilters = async function(filters, sourceElement, sourceWidth, sourceHeight, targetCanvas, cacheKey, callback){
        var ctx = targetCanvas.getContext('2d');
        ctx.drawImage(sourceElement, 0, 0, sourceWidth, sourceHeight);
        var imageData = ctx.getImageData(0, 0, sourceWidth, sourceHeight);
        var originalImageData = ctx.getImageData(0, 0, sourceWidth, sourceHeight);
        var pipelineState = {
          sourceWidth: sourceWidth,
          sourceHeight: sourceHeight,
          imageData: imageData,
          originalEl: sourceElement,
          originalImageData: originalImageData,
          canvasEl: targetCanvas,
          ctx: ctx,
          filterBackend: this,
        };
        for (const filter of filters) {
            await filter.applyTo2d(pipelineState);
            if (pipelineState.imageData.width !== sourceWidth || pipelineState.imageData.height !== sourceHeight) {
                targetCanvas.width = pipelineState.imageData.width;
                targetCanvas.height = pipelineState.imageData.height;
            }
            ctx.putImageData(pipelineState.imageData, 0, 0);
        }
        if( typeof callback == 'function' ) callback();
        return pipelineState;
    };
    var canvas2dBackend = new fabric.Canvas2dFilterBackend();
    fabric.filterBackend = canvas2dBackend;
    var filters = fabric.Image.filters,
    createClass = fabric.util.createClass;
    filters.CustomFilter = createClass(filters.BaseFilter, {
        type: 'CustomFilter',
        initialize: function(options) {
            this.callSuper('initialize', options);
        },
        jOptions: '',
        mainParameter: 'jOptions',
        applyTo2d: function(options) {
            var imageData = options.imageData,
                width = imageData.width, 
                height = imageData.height,
                originUrl = options.canvasEl.toDataURL(),
                jOptions = this.jOptions;
            var d = new Date(),
            randomId = d.getTime() + Math.floor(Math.random() * 1000);
            return new Promise( function( resolve, reject ) {
                function buildSvg(){
                    var id = 'filter_' + randomId,
                    svg      = '';

                    svg     += '<svg version="1.1" width="' + width + '" height="' + height + '"' + ' viewBox="0 0 ' + width + ' ' + height + '" ' + ' xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">';
                    svg     +=      '<defs>';
                    svg     +=          '<filter id="' + id + '" x="0" y="0" width="100%" height="100%">';
                    svg     +=              buildSvgFilter( jOptions );
                    svg     +=          '</filter>';
                    svg     +=      '</defs>';
                    svg     +=      '<image xlink:href="' + originUrl + '" x="0" y="0" width="100%" height="100%" filter="url(#' + id + ')"></image>';
                    svg     += '</svg>';

                    return svg;
                }

                var filterdSvg = buildSvg(),
                img = new Image();
                url = "data:image/svg+xml;charset=utf-8," + encodeURIComponent( filterdSvg );
                
                img.onload = function() {
                    var kanvas = document.createElement("canvas");
                    kanvas.width = width;
                    kanvas.height = height,
                    context = kanvas.getContext('2d');
                    context.drawImage(img, 0, 0, width, height, 0, 0, width, height);

                    options.imageData = context.getImageData(0, 0, width, height);
                    return resolve({status: jOptions});
                }
                img.src = url;
            });
        }
    });
    fabric.Image.filters.CustomFilter.fromObject = fabric.Image.filters.BaseFilter.fromObject;

    if ( fabricConfig.nbdesigner_enable_font_to_outlines == 'yes' ) {
        fabric.Text.prototype._createTextCharSpan = function (_char, styleDecl, left, top) {
            var toFixed = fabric.util.toFixed,
                multipleSpacesRegex = /  +/g;
            var shouldUseWhitespace = _char !== _char.trim() || _char.match(multipleSpacesRegex),
                styleProps = this.getSvgSpanStyles(styleDecl, shouldUseWhitespace),
                fillStyles = styleProps ? 'style="' + styleProps + '"' : '',
                dy = styleDecl.deltaY, dySpan = '',
                NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;
            if (dy) {
                dySpan = ' dy="' + toFixed(dy, NUM_FRACTION_DIGITS) + '" ';
            }

            var fontName = this.fontFamily,
                fontWeight = this.fontWeight,
                fontStyle = this.fontStyle;

            if (fontWeight == 'bold') {
                if (fontStyle == 'italic') {
                    fontName += '__bi';
                } else {
                    fontName += '__b';
                }
            } else {
                if (fontStyle == 'italic') {
                    fontName += '__i';
                }
            }
            if( $window.outlineFonts[fontName] ){
                var path = $window.outlineFonts[fontName].getPath(fabric.util.string.escapeXml(_char), toFixed(left, NUM_FRACTION_DIGITS), toFixed(top, NUM_FRACTION_DIGITS), this.fontSize)
                    pathMarkup = path.toSVG(NUM_FRACTION_DIGITS);

                return pathMarkup;
            }else{
                return [
                    '<tspan x="', toFixed(left, NUM_FRACTION_DIGITS), '" y="',
                    toFixed(top, NUM_FRACTION_DIGITS), '" ', dySpan,
                    fillStyles, '>',
                    fabric.util.string.escapeXml(_char),
                    '</tspan>'
                ].join('');
            }
        };
        fabric.Text.prototype._wrapSVGTextAndBg = function (textAndBg) {
            var noShadow = true;
            if( _.isEmpty( $window.outlineFonts ) ){
                var textDecoration = this.getSvgTextDecoration(this);
                return [
                  textAndBg.textBgRects.join(''),
                  '\t\t<text xml:space="preserve" ',
                  (this.fontFamily ? 'font-family="' + this.fontFamily.replace(/"/g, '\'') + '" ' : ''),
                  (this.fontSize ? 'font-size="' + this.fontSize + '" ' : ''),
                  (this.fontStyle ? 'font-style="' + this.fontStyle + '" ' : ''),
                  (this.fontWeight ? 'font-weight="' + this.fontWeight + '" ' : ''),
                  (textDecoration ? 'text-decoration="' + textDecoration + '" ' : ''),
                  'style="', this.getSvgStyles(noShadow), '"', this.addPaintOrder(), ' >',
                  textAndBg.textSpans.join(''),
                  '</text>\n'
                ];
            }else{
                return [
                    textAndBg.textBgRects.join(''),
                    '\t\t<g ',
                    'style="', this.getSvgStyles(noShadow), '"', this.addPaintOrder(), ' >',
                    textAndBg.textSpans.join(''),
                    '</g>\n'
                ];
            }
        };
    }

    return $window.fabric;
}]);
// get Canvas
var firtRenderCanvas = false;
nbdApp.directive('nbdCanvas', ['FabricWindow', '$timeout', '$rootScope', function(FabricWindow, $timeout, $rootScope){
        return {
        restrict: "AE",
        scope: {
            stage: '=stage',
            index: '@',
            last: '@'
        },
        link: function( scope, element, attrs ) {
            if(firtRenderCanvas) {
                $timeout(function() {
                    scope.stage.canvas = new FabricWindow.Canvas('nbd-stage-'+scope.index);
                    scope.$emit('canvas:created', scope.index, scope.last);
                    element.parent().children().on("contextmenu", function(e){
                        e.preventDefault();
                        scope.$emit('nbd:contextmenu', e);
                    });
                });  
            } else {
                firtRenderCanvas = true;
            }
        }
    }
}]);
// Bắt sự kiện nhấn nút
nbdApp.directive('keypress', ['$window', function($window){
    return {
        restrict: "AE",
        link: function( scope, element, attrs ) {
            $window.document.addEventListener("keydown", function(e){
                scope.$emit('nbd:keypress', e);
            }, false);
        }
    }
}]);
// nbd-scroll
nbdApp.directive('nbdScroll', ['$timeout', function($timeout){
    return {
        restrict: "AE",
        scope: {
            container: '@',
            type: '@',
            offset: '@',
            currentType: '@',
            action: '&nbdScroll'
        },
        link: function( scope, element, attrs ) {
            $timeout(function() {
                // var el = scope.type != 'font' ? jQuery(scope.container + ' .tab-scroll') : jQuery(scope.container),
                var el = jQuery(scope.container + ' .tab-scroll'),
                    offset = parseInt(scope.offset),
                    elInfo = jQuery(scope.container + ' .info-support');
                el.on('ps-scroll-y', function(){
                    if( scope.type == 'globalTemplate' && angular.isDefined( scope.currentType ) && scope.currentType != 'global' ) return;
                    if(el.prop("clientHeight") != el.prop("scrollHeight") && ((el.prop("scrollTop") + el.prop("clientHeight") - el.prop("scrollHeight") + offset) > 0) ){
                        scope.action({container: scope.container, type: scope.type});
                    };
                    if( elInfo.length ){
                        el.prop("scrollTop") > 1500 && elInfo.addClass('slideInDown animated show') || elInfo.removeClass('slideInDown animated show');
                    }
                });
            });
        }
    }
}]);
// ruler-guideline
nbdApp.directive('rulerGuideline', ['$timeout',  function($timeout){
    return {
       restrict: "AE",
        scope: {
            direction: '@rulerGuideline',
            preventClick: '=preventClick',
            offset: '=offset',
            ratio: '@ratio',
            cwidth: '@cwidth'
        },
        link: function( scope, element, attrs ){
            $timeout(function(){
                var el = jQuery(element);
                var stageEl = el.parents('.stage');
                el.on('mousedown', function(event) {
                    stageEl.find('.guide-backdrop').removeClass('nbd-prevent-event');
                    stageEl.on('mousemove.nbd-move-guideline', function(event){
                        var ratio = parseFloat(scope.ratio);
                        var cwidth = parseFloat(scope.cwidth);
                        var stagePos = stageEl.offset(),
                        top = event.pageY - stagePos.top + stageEl.scrollTop(),
                        left = event.pageX - stagePos.left + stageEl.scrollLeft();
                        top = top <= 40 ? top : (40 + (top - 40) / ratio);
                        var stageElWidth = stageEl.width();
                        var additionalPadding = (cwidth * ratio - stageElWidth) / 2;
                        if( additionalPadding < 0  ){
                            left = left > 50 ? (stageElWidth / 2 - (stageElWidth / 2 + 50 - left)/ratio + 50) : left;
                        }else{
                            left = stageElWidth / 2 - (stageElWidth / 2 + 50 + additionalPadding - left)/ratio + 50;
                        };
                        scope.offset = scope.direction == 'hor' ? top : left;
                    });
                    event.preventDefault();
                }).on('mouseup', function(event){
                    stageEl.off('mousemove.nbd-move-guideline');
                    stageEl.find('.guide-backdrop').addClass('nbd-prevent-event');
                });
                stageEl.on('mouseup', function(){
                    stageEl.off('mousemove.nbd-move-guideline');
                    stageEl.find('.guide-backdrop').addClass('nbd-prevent-event');
                });
                el.trigger('mousedown');
            });
        }
    };
}]);
// nbd-color-picker
nbdApp.directive("nbdColorPicker", ['$timeout', function($timeout) {
    return {
        restrict: "C",
        scope: {
            cattr: '@',
            color: '@',
            type: '@'
        },
        link: function(scope, element) {
            jQuery(element).on('click', function(){
                $timeout(function() {
                    jQuery('#nbd-global-color-palette').addClass('show');
                });
                scope.$emit('nbd:picker', scope.cattr, scope.color, scope.type);
            });
        }
    };
}]);
// nbd-clear-stage
nbdApp.directive("nbdClearStage", function() {
    return {
        restrict: "A",
        link: function(scope, element) {
            jQuery(element).on('click', function(){
                // if( NBDESIGNCONFIG.nbdesigner_prevent_delete_template_layer == 'yes' && !( NBDESIGNCONFIG.task == 'create' || ( NBDESIGNCONFIG.task == 'edit' && NBDESIGNCONFIG.design_type == 'template' ) ) ) return;
                jQuery('.nbd-popup.clear-stage-alert, .v-popup.v-popup-select').nbShowPopup();
            });
        }
    };
});
// nbd-perfect-scroll
nbdApp.directive("nbdPerfectScroll", function($timeout) {
    return {
        restrict: "A",
        link: function(scope, element) {
            $timeout(function(){
                jQuery(element).perfectScrollbar();
            })
        }
    };    
});
// nbd-drop-zone
nbdApp.directive("nbdDropZone", ['$timeout', function($timeout) {
    return {
        restrict: "A",
        scope: {
            uploadFile: '&nbdDropZone'
        },
        link: function(scope, element) {
            $timeout(function() {
                var dropArea = jQuery('#nbd-stages');
                dropArea.on('drop', handleDrop);
                function handleDrop(e) {
                    if(e.originalEvent.dataTransfer){
                        if(e.originalEvent.dataTransfer.files.length) {
                            e.preventDefault();
                            e.stopPropagation();
                            handleFiles(e.originalEvent.dataTransfer.files);
                        }
                    }
                };
                function handleFiles(files) {
                    if(files.length > 0) scope.uploadFile({files: files});
                } 
            });
        }
    };
}]);
// nbd-layer
nbdApp.directive('nbdLayer', ['$timeout', function($timeout){
    return {
        restrict: "AE",
        scope: {
            action: '&nbdLayer'
        },
        link: function( scope, element, attrs ) {
            $timeout(function() {
                jQuery(element).sortable({
                    placeholder: "sortable-placeholder",
                    containment: '#tab-layer',
                    stop: function(event, ui) {
                        var srcIndex = jQuery(this).attr('data-prev-index'),
                            oldIndex = jQuery(this).attr('data-previndex'),
                            newIndex = ui.item.index(),
                            dstIndex = 0;
                        if( oldIndex > newIndex ){
                            dstIndex = jQuery(ui.item).next().attr('data-index')
                        }else {
                            dstIndex = jQuery(ui.item).prev().attr('data-index')
                        };
                        jQuery(this).removeAttr('data-previndex');
                        jQuery(this).removeAttr('data-prev-index');
                        scope.action({srcIndex: srcIndex, dstIndex: dstIndex});
                    },
                    start: function(e, ui) {
                        jQuery(this).attr('data-prev-index', jQuery(ui.item).attr('data-index'));
                        jQuery(this).attr('data-previndex', ui.item.index());
                    },
                });
            });
        }
    };
}]);
// end-repeat-color-picker
nbdApp.directive('endRepeatColorPicker', ['$timeout', function($timeout){
    return {
        restrict: "A",
        link: function( scope, element, attrs ) {
            $timeout(function() {
                jQuery(element).nbdColorPalette();
            });
        }
    }    
}]);
// font-on-load
nbdApp.directive("fontOnLoad", [ function() {
    return {
        restrict: "A",
        scope: {
            font: '=',
            preview: '=',
            loadFontFailAction: '&'
        },
        link: function(scope, element) {
            var fontName = scope.font.alias,
                fontType = scope.font.type;
            if( fontName == '' ) return;
            var font_id = fontName.replace(/\s/gi, '').toLowerCase();
            if( !jQuery('#' + font_id).length ){
                if(fontType == 'google'){
                    jQuery('head').append('<link id="' + font_id + '" href="https://fonts.googleapis.com/css?family='+ fontName.replace(/\s/gi, '+') +':400,400i,700,700i" rel="stylesheet" type="text/css">');
                }else{
                    var css = "<style type='text/css' id='" + font_id + "' >";
                    _.each(scope.font.file, function (file, index) {
                        var font_url = file;
                        if(! (file.indexOf("http") > -1)) font_url = defaultSettings.folder_font + file;
                        css += "@font-face {font-family: '" + fontName + "';";
                        css += "src: ";
                        css += "url('" + font_url + "') format('truetype');";
                        switch(index){
                            case "r":
                                css += "font-weight: normal;font-style: normal;"
                                break;
                            case "b":
                                css += "font-weight: bold;font-style: normal;"
                                break;
                            case "i":
                                css += "font-weight: normal;font-style: italic;"
                                break;
                            case "bi":
                                css += "font-weight: bold;font-style: italic;"
                                break;
                        };
                        css += "}";
                    });
                    css += "</style>";
                    jQuery("head").append(css);
                }
            };
            var font = new FontFaceObserver(fontName);
            font.load(scope.preview, 3E4).then(function () {
                element.removeClass('font-loading');
            }, function () {
                scope.loadFontFailAction({font: scope.font});
            }); 
            element.addClass('font-loading');
        }
    }
}]);
// repeat-end
nbdApp.directive('repeatEnd', [ function(){
    return {
        restrict: "AE",
        link: function( scope, element, attrs ) {
            if(scope.$last) {
                scope.$eval(attrs.repeatEnd);
            }
        }
    }
}]);
// nbd-dnd-file
nbdApp.directive("nbdDndFile", ['$timeout', function($timeout) {
    return {
        restrict: "A",
        scope: {
            uploadFile: '&nbdDndFile'
        },
        link: function(scope, element) {
            $timeout(function() {
                var dropArea = jQuery(element),
                Input = dropArea.find('input[type="file"]');
                _.each(['dragenter', 'dragover'], function(eventName, key) {
                    dropArea.on(eventName, highlight)
                });
                _.each(['dragleave', 'drop'], function(eventName, key) {
                    dropArea.on(eventName, unhighlight)
                });
                function highlight(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    dropArea.addClass('highlight');
                };
                function unhighlight(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    dropArea.removeClass('highlight');
                };
                dropArea.on('drop', handleDrop);
                function handleDrop(e) {
                    if( jQuery('#accept-term').length && !jQuery('#accept-term').is(':checked') ) {
                        alert(langs.alert_upload_term);
                        return;
                    }else{
                        if(e.originalEvent.dataTransfer){
                            if(e.originalEvent.dataTransfer.files.length) {
                                e.preventDefault();
                                e.stopPropagation();
                                handleFiles(e.originalEvent.dataTransfer.files);
                            }
                        }
                    }
                };
                dropArea.on('click', function(e){
                    Input.click();
                });
                Input.on('click', function(e){
                    e.stopPropagation();
                    if( jQuery('#accept-term').length && !jQuery('#accept-term').is(':checked') ) {
                        alert(langs.alert_upload_term);
                        e.preventDefault();
                        return;
                    }
                });
                Input.on('change', function(){
                    handleFiles(this.files);
                });
                function handleFiles(files) {
                    if(files.length > 0) scope.uploadFile({files: files});
                }
            });
        }
    }
}]);
// stage-cell
nbdApp.directive("stageCell", ['$timeout', function($timeout) {
    return {
        restrict: "E",
        transclude: true,
        template: '<ng-transclude></ng-transclude>'
    };
}]);
// nbd-drag
nbdApp.directive("nbdDrag", [ function() {
    return {
        restrict: "AE",
        scope: {
            url: '=nbdDrag',
            img: '=nbdImg',
            extenal: '@extenal',
            type: '@type'
        },
        link: function( scope, element, attrs ) {
            element.attr("draggable", "true");
            element.on('dragstart', function(event) {
                event.originalEvent.dataTransfer.setData("src",scope.url);
                event.originalEvent.dataTransfer.setData("extenal",scope.extenal);
                event.originalEvent.dataTransfer.setData("type",scope.type);
                if( angular.isDefined( scope.img ) && angular.isDefined( scope.img.origin_url ) ){
                    event.originalEvent.dataTransfer.setData("origin_url", scope.img.origin_url);
                    event.originalEvent.dataTransfer.setData("origin_width", scope.img.width);
                    event.originalEvent.dataTransfer.setData("origin_height", scope.img.height);
                }
            });
        }
    }
}]);
// stage-cell-inner
nbdApp.directive("stageCellInner", ['$timeout', function($timeout) {
    return {
        restrict: "A",
        link: function(scope, element) {
            $timeout(function(){
                jQuery(element).on('dragstart', function(e){
                    from = jQuery(this).attr('data-position');
                    e.originalEvent.dataTransfer.setData('data_position', from);
                    e.originalEvent.dataTransfer.setData('data_active', 1);
                });
                jQuery(element).on('dragover', function(e){
                    e.preventDefault();

                    var position = jQuery(this).attr('data-position'),
                    next = position * 1 + 1;
                    if( e.originalEvent.pageX > ( jQuery(element).offset().left + jQuery(element).width() / 2 ) ){
                        jQuery( '.stage-space[data-position="' + next + '"]' ).addClass('active');
                        jQuery( '.stage-space[data-position="' + position + '"]' ).removeClass('active');
                        jQuery(element).attr('data-drop-position', next);
                    }else{
                        jQuery( '.stage-space[data-position="' + position + '"]' ).addClass('active');
                        jQuery( '.stage-space[data-position="' + next + '"]' ).removeClass('active');
                        jQuery(element).attr('data-drop-position', position);
                    }
                });
                jQuery(element).on('dragleave', function(e){
                    var position = jQuery(this).attr('data-position'),
                    next = position * 1 + 1;
                    jQuery( '.stage-space[data-position="' + position + '"], .stage-space[data-position="' + next + '"]' ).removeClass('active');
                    jQuery(element).removeAttr('data-drop-position');
                    jQuery('.stage-space').removeClass('active');
                });
                jQuery(element).on('drop', function(e){
                    e.preventDefault();
                    jQuery(this).removeClass('active');
                    var from = e.originalEvent.dataTransfer.getData('data_position'),
                    active = e.originalEvent.dataTransfer.getData('data_active'),
                    position = jQuery(this).attr('data-position');
                    if( position != from ){
                        var to = jQuery(this).attr('data-drop-position');
                        if( active == '1' ){
                            scope.$emit('stage:move', from * 1, to * 1);
                        }
                    }
                    jQuery(element).removeAttr('data-drop-position');
                    jQuery('.stage-space').removeClass('active');
                });
            });
        }
    }
}]);
// stage-space
nbdApp.directive("stageSpace", ['$timeout', function($timeout) {
    return {
        restrict: "A",
        link: function(scope, element) {
            $timeout(function(){
                jQuery(element).on('dragenter', function(e){
                    jQuery(this).addClass('active');
                });
                jQuery(element).on('dragover', function(e){
                    e.preventDefault();
                    jQuery(this).addClass('active');
                });
                jQuery(element).on('dragleave', function(e){
                    jQuery(this).removeClass('active');
                });
                jQuery(element).on('drop', function(e){
                    e.preventDefault();
                    jQuery(this).removeClass('active');
                    var from = e.originalEvent.dataTransfer.getData('data_position'),
                    active = e.originalEvent.dataTransfer.getData('data_active');
                    var to = jQuery(this).attr('data-position');
                    if( active == '1' ){
                        scope.$emit('stage:move', from * 1, to * 1);
                    }
                });
            });
        }
    }
}]);
// nbd-popup-trigger
nbdApp.directive("nbdPopupTrigger", ['$timeout', function($timeout) {
    return {
        restrict: "A",
        link: function(scope, element) {
            $timeout(function() {
                jQuery(element).on('click', function () {
                    var target = jQuery(this).attr('data-popup');
                    jQuery('.' + target).nbShowPopup();
                });
            });
        }
    };
}]);
/*photo-frame*/
nbdApp.directive('photoFrame', function() {
    return {
        restrict: "EA",
        scope: {
            frame: "="
        },
        template: '<div class=\"frame-wrap-inner\" ng-style=\"getFrameStyle()\">'+
                   '<div class=\"frame-panel\" ng-repeat=\"panel in framePanel\" ng-style=\"{\'grid-area\': panel + \'/\' + panel + \'/\' + panel + \'/\' + panel}\"></div>' + 
                   '</div>',
        controller: function( $scope ){
            $scope.framePanel = [];
            function init(){
                var rows = $scope.frame.areas.match(/[^"]+(?=(" ")|"$)/g),
                    panels = [];
                rows.forEach(function(row){
                    panels = panels.concat( row.split(" ") );
                });
                $scope.framePanel = _.uniq(panels);
            }
            init();
            $scope.getFrameStyle = function(){
                var objStyle = {};
                if( $scope.frame.areas != '' ){
                    objStyle['grid-template-areas'] = $scope.frame.areas;
                }
                if( $scope.frame.rows != '' ){
                    objStyle['grid-template-rows'] = $scope.frame.rows;
                }
                if( $scope.frame.columns != '' ){
                    objStyle['grid-template-columns'] = $scope.frame.columns;
                }
                return objStyle;
            };
        }
    }
});
// nbd-capture
nbdApp.directive("nbdCapture", ['$timeout', function($timeout) {
    return {
        restrict: "A",
        scope: {
            nbdCapture: '&'
        },
        link: function(scope, element) {
            $timeout(function() {
                jQuery(element).unbind( "paste" );
                jQuery(element).bind('paste', function(e){
                    var clipboard = e.originalEvent.clipboardData;
                    if( clipboard ){
                        if ( clipboard.items ) {
                            var items = clipboard.items;
                            for ( var i = 0; i < items.length; ++i ) {
                                if ( items[i].kind === 'file' && items[i].type.indexOf('image/') !== -1 ) {
                                    scope.nbdCapture( {
                                        file: items[i].getAsFile(),
                                        type: items[i].type
                                    });
                                    return;
                                }
                            }
                        }
        
                        if ( clipboard.files ) {
                            var items = clipboard.files;
                            for ( var i = 0; i < items.length; ++i ) {
                                if ( items[i].type.indexOf('image/') !== -1 ) {
                                    scope.nbdCapture( {
                                        file: items[i],
                                        type: items[i].type
                                    });
                                    return;
                                }
                            }
                        }
                    }
                });
            });
        }
    };
}]);

nbdApp.factory('NBDDataFactory', function($http){
    return {
        get : function(action, data, callback, progressCallback) {
            var formData = new FormData();
            formData.append("action", action);
            var nonce = action == 'nbd_get_resource' ? 'a3c9bbe351' : 'f65e05b30a';
            formData.append("nonce", nonce);
            var isUploadFile = false;
            angular.forEach(data, function (value, key) {
                var keepDefault = ['file', 'design', 'config', 'product', 'upload', 'used_font', 'option', 'preview', 'template_thumb'];
                if( typeof value != 'object' || _.includes(keepDefault, key) || key.indexOf("frame") > -1 ){
                    formData.append(key, value);
                }else{
                    var keyName;
                    for (var k in value) {
                        if (value.hasOwnProperty(k)) {
                            keyName = [key, '[', k, ']'].join('');
                            formData.append(keyName, value[k]);
                        }
                    }
                }
                if( key == 'file' ) isUploadFile = true;
            });
            var config = {
                transformRequest: angular.identity,
                transformResponse: angular.identity,
                headers: {
                    'Content-Type': undefined
                }
            };
            if( isUploadFile ){
                config.uploadEventHandlers = {
                    progress: function (e) {
                        if (e.lengthComputable) {
                            var progressBar = (e.loaded / e.total) * 100;
                            progressCallback(progressBar);
                        }
                    }
                };
            }
            // var url = NBDESIGNCONFIG['ajax_url'];
            var url = '';
            if( data.type == 'typography' || data.type == 'get_typo' ) url = 'https://studio.cmsmart.net/v1/typo';
            if( data.source == 'media' ) url = 'https://studio.cmsmart.net/v1/template';
            $http.post(url, formData, config).then(
                function(response) {
                    callback(response.data);
                },
                function(response) {
                    console.log(response);
                }
            );
        }
    }
});

/* filter */
nbdApp.filter('keyboardShortcut', function($window) {
    return function(str) {
        if (!str)
            return;
        var keys = str.split('-');
        var isOSX = /Mac OS X/.test($window.navigator.userAgent);
        var seperator = (!isOSX || keys.length > 2) ? '+' : '';
        var abbreviations = {
            M: isOSX ? '⌘' : 'Ctrl',
            A: isOSX ? 'Option' : 'Alt',
            S: 'Shift'
        };
        return keys.map(function (key, index) {
            var last = index == keys.length - 1;
            return last ? key : abbreviations[key];
        }).join(seperator);
    };
});
nbdApp.filter("filterFont", function() {
    return function(fonts, filterFont) {
        var arrFont = [];
        angular.forEach(fonts, function(font, key) {
            var check = [];
            check['limit'] = arrFont.length > ( filterFont.perPage * filterFont.currentPage  - 1 ) ? false : true;
            if( !!filterFont.search ){
                check['name'] = font.name.toLowerCase().indexOf(filterFont.search.toLowerCase()) >= 0 ? true : false;
                if( angular.isDefined( font.display_name ) && font.display_name != '' ){
                    check['name'] = check['name'] || (font.display_name.toLowerCase().indexOf(filterFont.search.toLowerCase()) >= 0 ? true : false);
                }
            }else{
                check['name'] = true;
            };
            if( check['limit'] && check['name'] )arrFont.push(font);
        });
        arrFont = _.sortBy(arrFont, [function(o) { return o.name; }]);
        return arrFont
    }
});
nbdApp.filter("filterArt", function() {
    return function(arts, filterArt) {
        var arrArt = [];
        angular.forEach(arts, function(art, key) {
            var check = [];
            check['limit'] = arrArt.length > ( filterArt.perPage * filterArt.currentPage  - 1 ) ? false : true;
            if( !!filterArt.search ){
               check['name'] = art.name.toLowerCase().indexOf(filterArt.search.toLowerCase()) >= 0 ? true : false;
            }else{
                check['name'] = true;
            };
            if( check['limit'] && check['name'] ) arrArt.push(art);
        });
        return arrArt
    }
});
nbdApp.filter('reverse', function() {
    return function(items) {
        return items ? items.slice().reverse() : items;
    };
});
nbdApp.filter('range', [ function(){
    return function (input, total) {
        total = parseInt(total);
        for (var i = 0; i < total; i++) {
            input.push(i);
        }
        return input;
    };
}]);